================================================================================
// FILE: php-backend\composer.json
================================================================================

{
    "require": {
        "firebase/php-jwt": "^6.11",
        "phpmailer/phpmailer": "^6.10"
    }
}


================================================================================
// FILE: php-backend\composer.lock
================================================================================

{
    "_readme": [
        "This file locks the dependencies of your project to a known state",
        "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies",
        "This file is @generated automatically"
    ],
    "content-hash": "40b54d365bff242b65f4772b5d5c9c12",
    "packages": [
        {
            "name": "firebase/php-jwt",
            "version": "v6.11.1",
            "source": {
                "type": "git",
                "url": "https://github.com/firebase/php-jwt.git",
                "reference": "d1e91ecf8c598d073d0995afa8cd5c75c6e19e66"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/firebase/php-jwt/zipball/d1e91ecf8c598d073d0995afa8cd5c75c6e19e66",
                "reference": "d1e91ecf8c598d073d0995afa8cd5c75c6e19e66",
                "shasum": ""
            },
            "require": {
                "php": "^8.0"
            },
            "require-dev": {
                "guzzlehttp/guzzle": "^7.4",
                "phpspec/prophecy-phpunit": "^2.0",
                "phpunit/phpunit": "^9.5",
                "psr/cache": "^2.0||^3.0",
                "psr/http-client": "^1.0",
                "psr/http-factory": "^1.0"
            },
            "suggest": {
                "ext-sodium": "Support EdDSA (Ed25519) signatures",
                "paragonie/sodium_compat": "Support EdDSA (Ed25519) signatures when libsodium is not present"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "Firebase\\JWT\\": "src"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Neuman Vong",
                    "email": "neuman+pear@twilio.com",
                    "role": "Developer"
                },
                {
                    "name": "Anant Narayanan",
                    "email": "anant@php.net",
                    "role": "Developer"
                }
            ],
            "description": "A simple library to encode and decode JSON Web Tokens (JWT) in PHP. Should conform to the current spec.",
            "homepage": "https://github.com/firebase/php-jwt",
            "keywords": [
                "jwt",
                "php"
            ],
            "support": {
                "issues": "https://github.com/firebase/php-jwt/issues",
                "source": "https://github.com/firebase/php-jwt/tree/v6.11.1"
            },
            "time": "2025-04-09T20:32:01+00:00"
        },
        {
            "name": "phpmailer/phpmailer",
            "version": "v6.10.0",
            "source": {
                "type": "git",
                "url": "https://github.com/PHPMailer/PHPMailer.git",
                "reference": "bf74d75a1fde6beaa34a0ddae2ec5fce0f72a144"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/PHPMailer/PHPMailer/zipball/bf74d75a1fde6beaa34a0ddae2ec5fce0f72a144",
                "reference": "bf74d75a1fde6beaa34a0ddae2ec5fce0f72a144",
                "shasum": ""
            },
            "require": {
                "ext-ctype": "*",
                "ext-filter": "*",
                "ext-hash": "*",
                "php": ">=5.5.0"
            },
            "require-dev": {
                "dealerdirect/phpcodesniffer-composer-installer": "^1.0",
                "doctrine/annotations": "^1.2.6 || ^1.13.3",
                "php-parallel-lint/php-console-highlighter": "^1.0.0",
                "php-parallel-lint/php-parallel-lint": "^1.3.2",
                "phpcompatibility/php-compatibility": "^9.3.5",
                "roave/security-advisories": "dev-latest",
                "squizlabs/php_codesniffer": "^3.7.2",
                "yoast/phpunit-polyfills": "^1.0.4"
            },
            "suggest": {
                "decomplexity/SendOauth2": "Adapter for using XOAUTH2 authentication",
                "ext-mbstring": "Needed to send email in multibyte encoding charset or decode encoded addresses",
                "ext-openssl": "Needed for secure SMTP sending and DKIM signing",
                "greew/oauth2-azure-provider": "Needed for Microsoft Azure XOAUTH2 authentication",
                "hayageek/oauth2-yahoo": "Needed for Yahoo XOAUTH2 authentication",
                "league/oauth2-google": "Needed for Google XOAUTH2 authentication",
                "psr/log": "For optional PSR-3 debug logging",
                "symfony/polyfill-mbstring": "To support UTF-8 if the Mbstring PHP extension is not enabled (^1.2)",
                "thenetworg/oauth2-azure": "Needed for Microsoft XOAUTH2 authentication"
            },
            "type": "library",
            "autoload": {
                "psr-4": {
                    "PHPMailer\\PHPMailer\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "LGPL-2.1-only"
            ],
            "authors": [
                {
                    "name": "Marcus Bointon",
                    "email": "phpmailer@synchromedia.co.uk"
                },
                {
                    "name": "Jim Jagielski",
                    "email": "jimjag@gmail.com"
                },
                {
                    "name": "Andy Prevost",
                    "email": "codeworxtech@users.sourceforge.net"
                },
                {
                    "name": "Brent R. Matzelle"
                }
            ],
            "description": "PHPMailer is a full-featured email creation and transfer class for PHP",
            "support": {
                "issues": "https://github.com/PHPMailer/PHPMailer/issues",
                "source": "https://github.com/PHPMailer/PHPMailer/tree/v6.10.0"
            },
            "funding": [
                {
                    "url": "https://github.com/Synchro",
                    "type": "github"
                }
            ],
            "time": "2025-04-24T15:19:31+00:00"
        }
    ],
    "packages-dev": [],
    "aliases": [],
    "minimum-stability": "stable",
    "stability-flags": {},
    "prefer-stable": false,
    "prefer-lowest": false,
    "platform": {},
    "platform-dev": {},
    "plugin-api-version": "2.6.0"
}


================================================================================
// FILE: php-backend\api\change_password.php
================================================================================

<?php
// FILE: C:\xampp\htdocs\hassan-pos\Dubai-POS\php-backend\api\change_password.php

// Set headers for JSON response and CORS
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

// Handle preflight OPTIONS request
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

// --- Dependencies ---
require_once '../src/Middleware/authChecker.php';
require_once '../config/database.php';
require_once '../src/Models/User.php';

// --- Logic ---

// 1. Protect the route. This ensures only a logged-in user can access this.
$user_data = verify_jwt_and_get_user();
$user_id = $user_data['id'];

// 2. Get the posted data
$data = json_decode(file_get_contents("php://input"));

// 3. Validate the input, matching the original controller's logic 
if (!isset($data->password) || empty($data->password)) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Please enter a new password']);
    exit();
}

if (strlen($data->password) < 6) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Password must be at least 6 characters long']);
    exit();
}

// 4. Update the password in the database
try {
    $conn = connectDB();
    $user_model = new User($conn);

    if ($user_model->updatePassword($user_id, $data->password)) {
        // 5. Send success response
        http_response_code(200);
        echo json_encode([
            'success' => true,
            'message' => 'Password changed successfully'
        ]);
    } else {
        throw new Exception('Failed to update password in the database.');
    }

} catch (Exception $e) {
    // Generic error handler
    http_response_code(500);
    echo json_encode([
        'success' => false,
        'message' => 'Failed to change password: ' . $e->getMessage()
    ]);
}
?>

================================================================================
// FILE: php-backend\api\login.php
================================================================================

<?php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

require_once '../config/database.php';
require_once '../src/Models/User.php';
require_once '../vendor/autoload.php'; 
use Firebase\JWT\JWT;


define('ACCESS_TOKEN_SECRET', 'your_super_secret_access_key_123'); // Change this to a long random string
define('REFRESH_TOKEN_SECRET', 'your_super_secret_refresh_key_456'); // Change this to a long random string

$conn = connectDB();
$user_model = new User($conn);

// --- Input ---
$data = json_decode(file_get_contents("php://input"));

if (!isset($data->email) || !isset($data->password)) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Email and password are required.']);
    exit();
}

$email = $data->email;
$password = $data->password;

try {
    $user = $user_model->findUserByEmailOrUsername('', $email); 

    if (!$user) {
        http_response_code(404);
        echo json_encode(['success' => false, 'message' => 'User not found']);
        exit();
    }

    
    if (!password_verify($password, $user['password'])) {
        http_response_code(404);
        echo json_encode(['success' => false, 'message' => 'Invalid password']);
        exit();
    }

    $user_id = $user['id'];
    $issued_at = time();
    $access_token_expiry = $issued_at + (60 * 60 * 24); 
    $refresh_token_expiry = $issued_at + (60 * 60 * 24 * 10); 

    $access_payload = [
        'iss' => 'dubai-pos-backend', 
        'aud' => 'dubai-pos-frontend',
        'iat' => $issued_at, 
        'exp' => $access_token_expiry, 
        '_id' => $user_id 
    ];

    $refresh_payload = [
        'iss' => 'dubai-pos-backend',
        'aud' => 'dubai-pos-frontend',
        'iat' => $issued_at,
        'exp' => $refresh_token_expiry,
        '_id' => $user_id 
    ];

    $accessToken = JWT::encode($access_payload, ACCESS_TOKEN_SECRET, 'HS256');
    $refreshToken = JWT::encode($refresh_payload, REFRESH_TOKEN_SECRET, 'HS256');

    
    $user_model->updateRefreshToken($user_id, $refreshToken);

    $cookie_options = [
        'expires' => $refresh_token_expiry,
        'path' => '/',
        'domain' => '', // an empty value allows the cookie to be sent for the current host
        'secure' => false, // Set to true if you are using HTTPS
        'httponly' => true, // Important for security!
        'samesite' => 'Lax' // Or 'Strict'
    ];
    setcookie('refreshToken', $refreshToken, $cookie_options);
    setcookie('accessToken', $accessToken, $cookie_options);


    // 6. Send final response
    // Using 201 status code to match the original implementation 
    http_response_code(201);
    echo json_encode([
        'success' => true,
        'message' => 'Logged in successfully',
        'user' => [
            'id' => $user_id,
            'username' => $user['username'],
            'email' => $user['email'],
            'role' => $user['role'],
            'token' => $accessToken // The original also included the token in the body 
        ]
    ]);

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\logout.php
================================================================================

<?php
// FILE: C:\xampp\htdocs\hassan-pos\Dubai-POS\php-backend\api\logout.php

// Set headers for JSON response and CORS
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

// Handle preflight OPTIONS request
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

// --- Dependencies ---
require_once '../src/Middleware/authChecker.php';
require_once '../config/database.php';
require_once '../src/Models/User.php';

// --- Logic ---

// 1. Protect the route. This is the equivalent of app.use(jwtVerify).
// The verify_jwt_and_get_user() function will handle failures and exit if the user is not authenticated.
$user_data = verify_jwt_and_get_user();

try {
    // 2. Invalidate the Refresh Token in the database.
    // This corresponds to `User.findByIdAndUpdate(user._id, { $unset: { refreshToken: 1 } })` 
    // We achieve this by setting the refreshToken to NULL.
    $conn = connectDB();
    $user_model = new User($conn);
    $user_model->updateRefreshToken($user_data['id'], null);

    // 3. Clear the authentication cookies.
    // This is the PHP equivalent of `res.clearCookie()`. 
    // We set the cookie's expiration date to a time in the past.
    $cookie_options = [
        'expires' => time() - 3600, // 1 hour in the past
        'path' => '/',
        'domain' => '',
        'secure' => false, // Set to true if using HTTPS
        'httponly' => true,
        'samesite' => 'Lax'
    ];
    setcookie('accessToken', '', $cookie_options);
    setcookie('refreshToken', '', $cookie_options);

    // 4. Send the final success response, matching the original.
    http_response_code(200);
    echo json_encode([
        'success' => true,
        'message' => 'Logged out successfully'
    ]); // 

} catch (Exception $e) {
    // Generic error handler
    http_response_code(500);
    echo json_encode([
        'success' => false,
        'message' => 'Something went wrong during logout: ' . $e->getMessage()
    ]);
}
?>

================================================================================
// FILE: php-backend\api\refresh_token.php
================================================================================

<?php
// FILE: C:\xampp\htdocs\hassan-pos\Dubai-POS\php-backend\api\refresh_token.php

// Set headers for JSON response and CORS
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

// Handle preflight OPTIONS request
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

// --- Dependencies ---
require_once '../config/database.php';
require_once '../config/jwt_config.php';
require_once '../src/Models/User.php';
require_once '../vendor/autoload.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

try {
    // 1. Get the refresh token from the httpOnly cookie. 
    $incomingRefreshToken = $_COOKIE['refreshToken'] ?? null;

    if (!$incomingRefreshToken) {
        http_response_code(401);
        echo json_encode(['success' => false, 'message' => 'Unauthorized request: No refresh token provided']);
        exit();
    }

    // 2. Verify the refresh token's signature and expiration.
    $decoded = JWT::decode($incomingRefreshToken, new Key(REFRESH_TOKEN_SECRET, 'HS256'));

    // 3. Find the user from the token's payload. 
    $conn = connectDB();
    $user_model = new User($conn);
    $user = $user_model->findUserById($decoded->_id);

    if (!$user) {
        http_response_code(401);
        echo json_encode(['success' => false, 'message' => 'Invalid refresh token: User not found']);
        exit();
    }

    // 4. CRITICAL: Compare incoming token with the one stored in the database. 
    // This prevents stolen/reused refresh tokens.
    if ($incomingRefreshToken !== $user['refreshToken']) {
        http_response_code(401);
        echo json_encode(['success' => false, 'message' => 'Refresh token has been invalidated. Please log in again.']);
        exit();
    }

    // 5. If all checks pass, generate a NEW access token. 
    $user_id = $user['id'];
    $issued_at = time();
    $access_token_expiry = $issued_at + (60 * 60 * 24); // 1 day 

    $access_payload = [
        'iss' => 'dubai-pos-backend',
        'iat' => $issued_at,
        'exp' => $access_token_expiry,
        '_id' => $user_id
    ];

    $newAccessToken = JWT::encode($access_payload, ACCESS_TOKEN_SECRET, 'HS256');

    // 6. Set the new access token as a cookie. 
    $cookie_options = [
        'expires' => $access_token_expiry, // Set cookie to expire with the new token
        'path' => '/',
        'domain' => '',
        'secure' => false, // Set to true if using HTTPS
        'httponly' => true,
        'samesite' => 'Lax'
    ];
    setcookie('accessToken', $newAccessToken, $cookie_options);

    // 7. Send the successful response, including the new token in the body. 
    http_response_code(200);
    echo json_encode([
        'success' => true,
        'message' => 'Access token refreshed',
        'accessToken' => $newAccessToken,
        'refreshToken' => $incomingRefreshToken // Send back the same refresh token
    ]);

} catch (Exception $e) {
    // This will catch JWT verification errors (expired, invalid signature, etc.) 
    http_response_code(401);
    echo json_encode([
        'success' => false,
        'message' => 'Invalid or expired refresh token: ' . $e->getMessage()
    ]);
}
?>

================================================================================
// FILE: php-backend\api\reset_password.php
================================================================================

<?php
// FILE: ...\php-backend\api\reset_password.php

// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

// --- Dependencies ---
require_once '../vendor/autoload.php';
require_once '../config/database.php';
require_once '../config/jwt_config.php';
require_once '../config/mail_config.php';
require_once '../src/Models/User.php';

use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\Exception;
use Firebase\JWT\JWT;

// --- Logic ---
$data = json_decode(file_get_contents("php://input"));
$email = $data->email ?? null;

if (!$email) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Email address is required.']);
    exit();
}

try {
    $conn = connectDB();
    $user_model = new User($conn);
    $user = $user_model->findUserByEmailOrUsername('', $email);

    if (!$user) {
        // IMPORTANT: For security, do not reveal that the user does not exist.
        // Send a success message as if the email was sent.
        http_response_code(200);
        echo json_encode(['success' => true, 'message' => 'If an account with that email exists, a password reset link has been sent.']);
        exit();
    }

    // Generate a short-lived reset token (e.g., 10 minutes)
    $reset_payload = [
        'iss' => 'dubai-pos-backend',
        'aud' => 'dubai-pos-frontend',
        'iat' => time(),
        'exp' => time() + (60 * 10), // Expires in 10 minutes
        '_id' => $user['id']
    ];
    $resetToken = JWT::encode($reset_payload, RESET_TOKEN_SECRET, 'HS256');

    // --- Email Sending Logic ---
    $mail = new PHPMailer(true);
    $mail->isSMTP();
    $mail->Host       = MAIL_HOST;
    $mail->SMTPAuth   = true;
    $mail->Username   = MAIL_USERNAME;
    $mail->Password   = MAIL_PASSWORD;
    $mail->SMTPSecure = MAIL_SMTP_SECURE;
    $mail->Port       = MAIL_PORT;

    $mail->setFrom(MAIL_FROM_ADDRESS, MAIL_FROM_NAME);
    $mail->addAddress($user['email'], $user['username']);
    
    $mail->isHTML(true);
    $mail->Subject = 'Password Reset Request';
    $resetLink = FRONTEND_URL . '/update-password/' . $resetToken;
    $mail->Body    = "Hello,<br><br>You requested a password reset. Please click the link below to reset your password. This link is valid for 10 minutes.<br><br><a href='{$resetLink}'>Reset Password</a><br><br>If you did not request this, please ignore this email.";
    $mail->AltBody = 'To reset your password, please visit the following URL: ' . $resetLink;

    $mail->send();
    
    http_response_code(200);
    echo json_encode(['success' => true, 'message' => 'If an account with that email exists, a password reset link has been sent.']);

} catch (Exception $e) {
    // Generic error to avoid leaking information
    http_response_code(500);
    // For debugging: error_log("Mailer Error: " . $e->getMessage());
    echo json_encode(['success' => false, 'message' => 'An error occurred while trying to send the reset email.']);
}
?>


================================================================================
// FILE: php-backend\api\signup.php
================================================================================

<?php
// FILE: C:\xampp\htdocs\dubai-pos-backend\api\signup.php

header('Access-Control-Allow-Origin: *'); 
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

require_once '../config/database.php';
require_once '../src/Models/User.php';

define('ADMIN_EMAIL', 'superadmin@example.com'); 

$conn = connectDB();
$user = new User($conn);

$data = json_decode(file_get_contents("php://input"));

if (
    !isset($data->username) || !isset($data->email) || !isset($data->password) ||
    empty(trim($data->username)) || empty(trim($data->email)) || empty($data->password)
) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Please enter all the fields']);
    exit();
}

if (strlen($data->password) < 6) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Please enter a password of at least 6 characters']);
    exit();
}

// --- Business Logic ---
$username = trim($data->username);
$email = trim($data->email);
$password = $data->password;

try {
    $existingUser = $user->findUserByEmailOrUsername($username, $email);
    if ($existingUser) {
        http_response_code(409); // 409 Conflict
        echo json_encode(['success' => false, 'message' => 'User or Email already exists']);
        exit();
    }

    $role = ($email === ADMIN_EMAIL) ? 'superAdmin' : 'admin';
    $new_user_id = $user->createUser($username, $email, $password, $role);
    if ($new_user_id) {
        http_response_code(201);
        echo json_encode([
            'id' => $new_user_id, 
            'user' => $username,
            'role' => $role,
            'success' => true,
            'message' => 'User registered successfully'
        ]);
    } else {
        throw new Exception('Error occurred during user creation.');
    }

} catch (Exception $e) {
    
    http_response_code(500);
    echo json_encode([
        'success' => false,
        'message' => 'Something went wrong: ' . $e->getMessage()
    ]);
}
?>

================================================================================
// FILE: php-backend\api\update_password_with_token.php
================================================================================

<?php
// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

// --- Dependencies ---
require_once '../vendor/autoload.php';
require_once '../config/database.php';
require_once '../config/jwt_config.php';
require_once '../src/Models/User.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Firebase\JWT\ExpiredException;

// --- Logic ---
$data = json_decode(file_get_contents("php://input"));
$resetToken = $data->resetToken ?? null;
$password = $data->password ?? null;

if (!$resetToken || !$password) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Reset token and new password are required.']);
    exit();
}

if (strlen($password) < 6) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Password must be at least 6 characters long.']);
    exit();
}

try {
    // 1. Verify the JWT reset token
    $decoded = JWT::decode($resetToken, new Key(RESET_TOKEN_SECRET, 'HS256'));
    $user_id = $decoded->_id;

    // 2. Update the user's password
    $conn = connectDB();
    $user_model = new User($conn);
    
    if ($user_model->updatePassword($user_id, $password)) {
        http_response_code(200);
        echo json_encode([
            'success' => true,
            'message' => 'Password has been updated successfully. Please log in.'
        ]);
    } else {
        throw new Exception("Failed to update password for user ID: $user_id");
    }

} catch (ExpiredException $e) {
    http_response_code(401);
    echo json_encode(['success' => false, 'message' => 'Your password reset link has expired. Please request a new one.']);
} catch (Exception $e) {
    // Catches other JWT errors (invalid signature, etc.) or DB errors
    http_response_code(401);
    echo json_encode(['success' => false, 'message' => 'Invalid reset link. Please request a new one.']);
}
?>


================================================================================
// FILE: php-backend\api\verify.php
================================================================================

<?php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

// Include and run the auth checker middleware
require_once '../src/Middleware/authChecker.php';
$user = verify_jwt_and_get_user();

// If the script reaches this point, the user is authenticated.
http_response_code(200);
echo json_encode([
    'success' => true,
    'message' => 'Token is valid',
    'user' => $user // Send back the user data
]);
?>

================================================================================
// FILE: php-backend\api\bank\create.php
================================================================================

<?php
// FILE: ...\php-backend\api\bank\create.php

// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

// --- Dependencies ---
require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/BankTransaction.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
// Corresponds to guardBasic in MERN routes 
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'employee' && $user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);

// Basic validation, mirroring MERN service validations 
if (!isset($data['type']) || !isset($data['method']) || !isset($data['amount']) || !isset($data['reference'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Missing required fields: type, method, reference, and amount.']);
    exit();
}
if ($data['amount'] <= 0) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Amount must be greater than zero']);
    exit();
}

try {
    $conn = connectDB();
    $bank_model = new BankTransaction($conn);

    // Prepare data for the model method
    $transaction_data = [
        'date' => $data['date'] ?? date('Y-m-d H:i:s'),
        'type' => $data['type'],
        'method' => $data['method'],
        'reference' => $data['reference'],
        'amount' => $data['amount']
    ];

    // The recordTransaction method handles balance calculation and insertion 
    $new_txn_id = $bank_model->recordTransaction($transaction_data);

    if ($new_txn_id) {
        // Fetch the newly created record to return in the response
        $new_txn_db = $bank_model->findTransactionById($new_txn_id);
        // Format the response to match the MERN API payload 
        $formatted_txn = format_bank_transaction_response($new_txn_db);

        http_response_code(201); // 201 Created
        echo json_encode([
            'success' => true,
            'transaction' => $formatted_txn
        ]);
    } else {
        throw new Exception('Failed to record bank transaction.');
    }

} catch (Exception $e) {
    if (strpos($e->getMessage(), 'opening balance entry already exists') !== false) {
        http_response_code(409); // Conflict
        echo json_encode([
            'success' => false,
            'message' => 'An opening balance entry already exists. Only one opening balance is allowed.'
        ]);
    } else {
        http_response_code(500);
        echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
    }
}
?>

================================================================================
// FILE: php-backend\api\bank\delete.php
================================================================================

<?php
// FILE: ...\php-backend\api\bank\delete.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/BankTransaction.php';

$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

$data = json_decode(file_get_contents("php://input"), true);
$txn_id = $data['id'] ?? null;

if (!$txn_id) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Transaction ID is required.']);
    exit();
}

try {
    $conn = connectDB();
    $bank_model = new BankTransaction($conn);

    if ($bank_model->deleteTransaction($txn_id)) {
        http_response_code(200);
        echo json_encode(['success' => true, 'message' => 'Bank transaction soft deleted successfully']);
    } else {
        throw new Exception('Failed to delete transaction or transaction not found.');
    }
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\bank\read.php
================================================================================

<?php
// FILE: ...\php-backend\api\bank\read.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/BankTransaction.php';
require_once '../../src/Utils/formatters.php';

$user_data = verify_jwt_and_get_user();

try {
    $conn = connectDB();
    $bank_model = new BankTransaction($conn);

    $page = isset($_GET['page']) ? (int)$_GET['page'] : 1;
    $limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;
    $offset = ($page - 1) * $limit;

    $result = $bank_model->getAllTransactions([
        'method' => $_GET['method'] ?? null,
        'from' => $_GET['from'] ?? null,
        'to' => $_GET['to'] ?? null,
        'limit' => $limit,
        'offset' => $offset
    ]);

    $formatted_txns = array_map('format_bank_transaction_response', $result['transactions']);

    $response = [
        'success' => true,
        'transactions' => $formatted_txns,
        'pagination' => [
            'total' => (int)$result['total'],
            'page' => $page,
            'limit' => $limit,
            'totalPages' => ceil($result['total'] / $limit),
            'hasNextPage' => $page < ceil($result['total'] / $limit),
            'hasPrevPage' => $page > 1
        ]
    ];

    http_response_code(200);
    echo json_encode($response);
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\bank\update.php
================================================================================

<?php
// FILE: ...\php-backend\api\bank\update.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/BankTransaction.php';
require_once '../../src/Utils/formatters.php';

$user_data = verify_jwt_and_get_user();

$data = json_decode(file_get_contents("php://input"), true);
$txn_id = $data['id'] ?? null;
$reference = $data['reference'] ?? null;

if (!$txn_id || $reference === null) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Transaction ID and reference are required.']);
    exit();
}

try {
    $conn = connectDB();
    $bank_model = new BankTransaction($conn);

    if ($bank_model->updateTransaction($txn_id, $reference)) {
        $updated_txn = $bank_model->findTransactionById($txn_id);
        $formatted_txn = format_bank_transaction_response($updated_txn);

        http_response_code(200);
        echo json_encode(['success' => true, 'transaction' => $formatted_txn]);
    } else {
        throw new Exception('Failed to update transaction or transaction not found.');
    }
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\cash\create.php
================================================================================

<?php
// FILE: ...\php-backend\api\cash\create.php

// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

// --- Dependencies ---
require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/CashRegister.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'employee' && $user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);

// Basic validation
if (!isset($data['type']) || !isset($data['amount']) || !isset($data['reference'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Missing required fields: type, amount, and reference.']);
    exit();
}

try {
    $conn = connectDB();
    $cash_model = new CashRegister($conn);

    $entry_data = [
        'date' => $data['date'] ?? date('Y-m-d H:i:s'),
        'type' => $data['type'],
        'reference' => $data['reference'],
        'amount' => $data['amount']
    ];

    $new_entry_id = $cash_model->recordCashEntry($entry_data);

    if ($new_entry_id) {
        $new_entry_db = $cash_model->findEntryById($new_entry_id);
        $formatted_entry = format_cash_entry_response($new_entry_db);

        http_response_code(201);
        echo json_encode([
            'success' => true,
            'entry' => $formatted_entry
        ]);
    } else {
        throw new Exception('Failed to record cash entry.');
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>


================================================================================
// FILE: php-backend\api\cash\delete.php
================================================================================

<?php
// FILE: ...\php-backend\api\cash\delete.php

// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

// --- Dependencies ---
require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/CashRegister.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);
$entry_id = $data['id'] ?? null;

if (!$entry_id) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Cash entry ID is required.']);
    exit();
}

try {
    $conn = connectDB();
    $cash_model = new CashRegister($conn);

    if ($cash_model->deleteEntry($entry_id)) {
        http_response_code(200);
        echo json_encode([
            'success' => true,
            'message' => 'Cash entry soft deleted successfully'
        ]);
    } else {
        throw new Exception('Failed to delete cash entry or entry not found.');
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\cash\read.php
================================================================================

<?php
// FILE: ...\php-backend\api\cash\read.php


header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

// --- Dependencies ---
require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/CashRegister.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
// All authenticated users can view cash entries

// --- Logic ---
try {
    $conn = connectDB();
    $cash_model = new CashRegister($conn);

    // Get query parameters for filtering and pagination
    $page = isset($_GET['page']) ? (int)$_GET['page'] : 1;
    $limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;
    $offset = ($page - 1) * $limit;

    $type = $_GET['type'] ?? null;
    $from = $_GET['from'] ?? null;
    $to = $_GET['to'] ?? null;

    $result = $cash_model->getAllEntries([
        'type' => $type,
        'from' => $from,
        'to' => $to,
        'limit' => $limit,
        'offset' => $offset
    ]);

    $total_entries = $result['total'];
    $entries_db = $result['entries'];

    // Format each entry record for the response
    $formatted_entries = [];
    foreach ($entries_db as $entry) {
        $formatted_entries[] = format_cash_entry_response($entry);
    }

    // Build the final response object to match the original API
    $response = [
        'success' => true,
        'entries' => $formatted_entries,
        'pagination' => [
            'total' => (int)$total_entries,
            'page' => $page,
            'limit' => $limit,
            'totalPages' => ceil($total_entries / $limit),
            'hasNextPage' => $page < ceil($total_entries / $limit),
            'hasPrevPage' => $page > 1
        ]
    ];

    http_response_code(200);
    echo json_encode($response);

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\cash\update.php
================================================================================

<?php
// FILE: ...\php-backend\api\cash\update.php

// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

// --- Dependencies ---
require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/CashRegister.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);
$entry_id = $data['id'] ?? null;
$reference = $data['reference'] ?? null;

if (!$entry_id || $reference === null) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Entry ID and reference are required.']);
    exit();
}

try {
    $conn = connectDB();
    $cash_model = new CashRegister($conn);

    if ($cash_model->updateEntry($entry_id, $reference)) {
        $updated_entry = $cash_model->findEntryById($entry_id);
        $formatted_entry = format_cash_entry_response($updated_entry);

        http_response_code(200);
        echo json_encode(['success' => true, 'entry' => $formatted_entry]);
    } else {
        throw new Exception('Failed to update cash entry or entry not found.');
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\dashboard\metrics.php
================================================================================

<?php
// FILE: ...\php-backend\api\dashboard\metrics.php

// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

// --- Dependencies ---
require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Dashboard.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
try {
    $conn = connectDB();
    $dashboard_model = new Dashboard($conn);

    $metrics = $dashboard_model->getDashboardMetrics();

    // Assemble the final response to match the original Node.js structure
    $response = [
        'success' => true,
        'financial' => [
            'totalSales' => (float)($metrics['financial']['totalSales'] ?? 0),
            'totalProfit' => (float)($metrics['financial']['totalProfit'] ?? 0),
            'totalVat' => (float)($metrics['financial']['totalVat'] ?? 0),
            'totalExpenses' => (float)($metrics['financial']['totalExpenses'] ?? 0),
            'netProfit' => (float)(($metrics['financial']['totalProfit'] ?? 0) - ($metrics['financial']['totalExpenses'] ?? 0)),
            // Assuming "credit" was cash and "debit" was bank
            'totalCredit' => (float)($metrics['payments']['Cash'] ?? 0),
            'totalDebit' => (float)(($metrics['payments']['Bank'] ?? 0) + ($metrics['payments']['Shabka'] ?? 0))
        ],
        'topPerformers' => [
            'salesmen' => $metrics['topSalesmen'],
            'vendors' => $metrics['topVendors']
        ]
    ];

    http_response_code(200);
    echo json_encode($response);

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred while fetching dashboard metrics: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\dashboard\metrics_range.php
================================================================================

<?php
// FILE: ...\php-backend\api\dashboard\metrics_range.php

// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

// --- Dependencies ---
require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Dashboard.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$startDate = $_GET['startDate'] ?? null;
$endDate = $_GET['endDate'] ?? null;

if (!$startDate || !$endDate) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Both startDate and endDate query parameters are required.']);
    exit();
}

// Basic validation for date format (Y-m-d)
if (!preg_match("/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$/", $startDate) || 
    !preg_match("/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$/", $endDate)) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Invalid date format. Please use YYYY-MM-DD.']);
    exit();
}

try {
    $conn = connectDB();
    $dashboard_model = new Dashboard($conn);

    $metrics = $dashboard_model->getDashboardMetricsForDateRange($startDate, $endDate);

    // Assemble the final response to match the original Node.js structure
    $response = [
        'success' => true,
        'financial' => [
            'totalSales' => (float)($metrics['financial']['totalSales'] ?? 0),
            'totalProfit' => (float)($metrics['financial']['totalProfit'] ?? 0),
            'totalVat' => (float)($metrics['financial']['totalVat'] ?? 0),
            'totalExpenses' => (float)($metrics['financial']['totalExpenses'] ?? 0),
            'netProfit' => (float)(($metrics['financial']['totalProfit'] ?? 0) - ($metrics['financial']['totalExpenses'] ?? 0)),
            'totalCredit' => (float)($metrics['payments']['Cash'] ?? 0),
            'totalDebit' => (float)(($metrics['payments']['Bank'] ?? 0) + ($metrics['payments']['Shabka'] ?? 0))
        ],
        'topPerformers' => [
            'salesmen' => $metrics['topSalesmen'],
            'vendors' => $metrics['topVendors']
        ],
        'dateRange' => [
            'startDate' => $startDate,
            'endDate' => $endDate
        ]
    ];

    http_response_code(200);
    echo json_encode($response);

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred while fetching dashboard metrics: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\employees\create.php
================================================================================

<?php
// FILE: ...\php-backend\api\employees\create.php (REVISED)

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
// Specify the allowed headers in requests from the frontend.
header('Access-Control-Allow-Headers: Content-Type, Authorization');

// Allow cookies to be sent with the request (essential for authentication).
header('Access-Control-Allow-Credentials: true');

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Employee.php';
require_once '../../src/Utils/formatters.php'; // Include our new formatter

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);

// Expect the payload to be nested under "employeeData", like the original API
$employee_payload = $data['employeeData'] ?? null;

if (!$employee_payload || !isset($employee_payload['name']) || !isset($employee_payload['contact']['email'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Missing required employee fields in employeeData.']);
    exit();
}

try {
    $conn = connectDB();
    $employee_model = new Employee($conn);

    // Map the nested payload to the flat structure our model's create method expects
    $employee_to_create = [
        'name' => $employee_payload['name'],
        'email' => $employee_payload['contact']['email'],
        'phone' => $employee_payload['contact']['phone'] ?? null,
        'address' => $employee_payload['contact']['address'] ?? null,
        'role' => $employee_payload['role'],
        'hire_date' => $employee_payload['hireDate'], // Note the case change
        'salary_gross' => $employee_payload['salary'], // Original API used a single salary field
        'salary_net' => $employee_payload['salary']   // Default net to gross
    ];

    $new_employee_id = $employee_model->createEmployee($employee_to_create);

    if ($new_employee_id) {
        $new_employee_db = $employee_model->findEmployeeById($new_employee_id);
        // Use the formatter to create the correct response structure
        $formatted_employee = format_employee_response($new_employee_db);

        http_response_code(201);
        echo json_encode([
            'success' => true,
            'employee' => $formatted_employee // Send back the correctly formatted object
        ]);
    } else {
        throw new Exception('Failed to create employee.');
    }

} catch (Exception $e) {
    // ... (error handling remains the same)
    http_response_code(500);
    if (strpos($e->getMessage(), 'Duplicate entry') !== false) {
         http_response_code(409);
         echo json_encode(['success' => false, 'message' => 'An employee with this email already exists.']);
    } else {
         echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
    }
}
?>

================================================================================
// FILE: php-backend\api\employees\delete.php
================================================================================

<?php
// FILE: ...\php-backend\api\employees\delete.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Employee.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);

$employee_id = $data['id'] ?? null;

if (!$employee_id) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Employee ID is required.']);
    exit();
}

try {
    $conn = connectDB();
    $employee_model = new Employee($conn);

    // Attempt to delete the employee
    if ($employee_model->deleteEmployee($employee_id)) {
        // Send success response, matching the original API
        http_response_code(200);
        echo json_encode([
            'success' => true,
            'message' => 'Employee deleted successfully'
        ]);
    } else {
        // If deleteEmployee returns false, it means no record was found with that ID
        http_response_code(404);
        echo json_encode(['success' => false, 'message' => 'Employee not found.']);
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\employees\read.php
================================================================================

<?php
// FILE: ...\php-backend\api\employees\read.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Employee.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
try {
    $conn = connectDB();
    $employee_model = new Employee($conn);

    // Get query parameters for filtering and pagination
    $page = isset($_GET['page']) ? (int)$_GET['page'] : 1;
    $limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;
    $role = $_GET['role'] ?? null;
    $search = $_GET['search'] ?? null;
    $offset = ($page - 1) * $limit;

    $result = $employee_model->getAllEmployees([
        'role' => $role,
        'search' => $search,
        'limit' => $limit,
        'offset' => $offset
    ]);

    $total_employees = $result['total'];
    $employees_db = $result['employees'];

    // Format each employee record for the response
    $formatted_employees = [];
    foreach ($employees_db as $employee) {
        $formatted_employees[] = format_employee_response($employee);
    }

    // Build the final response object to match the original API
    $response = [
        'success' => true,
        'employees' => $formatted_employees,
        'pagination' => [
            'total' => (int)$total_employees,
            'page' => $page,
            'limit' => $limit,
            'totalPages' => ceil($total_employees / $limit),
        ]
    ];

    http_response_code(200);
    echo json_encode($response);

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\employees\update.php
================================================================================

<?php
// FILE: ...\php-backend\api\employees\update.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Employee.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);

$employee_id = $data['id'] ?? null;
$update_payload = $data['updateData'] ?? null;

if (!$employee_id || !$update_payload) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Employee ID and updateData are required.']);
    exit();
}

try {
    $conn = connectDB();
    $employee_model = new Employee($conn);

    // Map the potentially nested/camelCase payload to our flat/snake_case database columns
    $db_update_data = [];
    foreach($update_payload as $key => $value) {
        switch ($key) {
            case 'name':
            case 'role':
            case 'status':
                $db_update_data[$key] = $value;
                break;
            case 'hireDate':
                $db_update_data['hire_date'] = $value;
                break;
            case 'contact':
                if (isset($value['phone'])) $db_update_data['phone'] = $value['phone'];
                if (isset($value['email'])) $db_update_data['email'] = $value['email'];
                if (isset($value['address'])) $db_update_data['address'] = $value['address'];
                break;
            case 'salary':
                if (isset($value['gross'])) $db_update_data['salary_gross'] = $value['gross'];
                if (isset($value['net'])) $db_update_data['salary_net'] = $value['net'];
                break;
        }
    }

    // Update the employee in the database
    $success = $employee_model->updateEmployee($employee_id, $db_update_data);

    if ($success) {
        // Fetch the complete, updated record
        $updated_employee_db = $employee_model->findEmployeeById($employee_id);
        // Format it for the response
        $formatted_employee = format_employee_response($updated_employee_db);

        http_response_code(200);
        echo json_encode([
            'success' => true,
            'employee' => $formatted_employee
        ]);
    } else {
        throw new Exception('Database update failed.');
    }

} catch (Exception $e) {
    http_response_code(500);
    if (strpos($e->getMessage(), 'Duplicate entry') !== false) {
         http_response_code(409);
         echo json_encode(['success' => false, 'message' => 'An employee with this email already exists.']);
    } else {
         echo json_encode(['success' => false, 'message' => 'An error occurred during update: ' . $e->getMessage()]);
    }
}
?>

================================================================================
// FILE: php-backend\api\expenses\create.php
================================================================================

<?php
// FILE: ...\php-backend\api\expenses\create.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/CashRegister.php'; // Dependency for Expense model
require_once '../../src/Models/BankTransaction.php'; // Dependency for Expense model
require_once '../../src/Models/Expense.php';
require_once '../../src/Utils/formatters.php';

$user_data = verify_jwt_and_get_user();

$data = json_decode(file_get_contents("php://input"), true);

if (!isset($data['category'], $data['description'], $data['amount'], $data['paymentType'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Missing required fields: category, description, amount, and paymentType.']);
    exit();
}

try {
    $conn = connectDB();
    $expense_model = new Expense($conn);

    $expense_data = [
        'date' => $data['date'] ?? date('Y-m-d H:i:s'),
        'category' => $data['category'],
        'description' => $data['description'],
        'amount' => $data['amount'],
        'payment_type' => $data['paymentType'],
        'paid_to_id' => $data['paidTo'] ?? null,
        'paid_to_model' => $data['paidToModel'] ?? null
    ];

    $new_expense_id = $expense_model->recordExpense($expense_data);

    if ($new_expense_id) {
        $new_expense_db = $expense_model->findExpenseById($new_expense_id);
        $formatted_expense = format_expense_response($new_expense_db);
        
        http_response_code(201);
        echo json_encode(['success' => true, 'expense' => $formatted_expense]);
    } else {
        throw new Exception('Failed to record expense.');
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\expenses\delete.php
================================================================================

<?php
// FILE: ...\php-backend\api\expenses\delete.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/CashRegister.php';
require_once '../../src/Models/BankTransaction.php';
require_once '../../src/Models/Expense.php';

$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

$data = json_decode(file_get_contents("php://input"), true);
$expense_id = $data['id'] ?? null;

if (!$expense_id) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Expense ID is required.']);
    exit();
}

try {
    $conn = connectDB();
    $expense_model = new Expense($conn);

    if ($expense_model->deleteExpense($expense_id)) {
        http_response_code(200);
        echo json_encode(['success' => true, 'message' => 'Expense deleted successfully']);
    } else {
        throw new Exception('Failed to delete expense or expense not found.');
    }
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\expenses\read.php
================================================================================

<?php
// FILE: ...\php-backend\api\expenses\read.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Expense.php';
require_once '../../src/Utils/formatters.php';

$user_data = verify_jwt_and_get_user();

try {
    $conn = connectDB();
    $expense_model = new Expense($conn);

    $page = isset($_GET['page']) ? (int)$_GET['page'] : 1;
    $limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;
    $offset = ($page - 1) * $limit;

    $result = $expense_model->getAllExpenses([
        'category' => $_GET['category'] ?? null,
        'payment_type' => $_GET['paymentType'] ?? null,
        'search' => $_GET['search'] ?? null,
        'limit' => $limit,
        'offset' => $offset
    ]);

    $formatted_expenses = array_map('format_expense_response', $result['expenses']);

    $response = [
        'success' => true,
        'expenses' => $formatted_expenses,
        'pagination' => [
            'total' => (int)$result['total'],
            'page' => $page,
            'limit' => $limit,
            'totalPages' => ceil($result['total'] / $limit),
        ]
    ];

    http_response_code(200);
    echo json_encode($response);
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\expenses\update.php
================================================================================

<?php
// FILE: ...\php-backend\api\expenses\update.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/CashRegister.php';
require_once '../../src/Models/BankTransaction.php';
require_once '../../src/Models/Expense.php';
require_once '../../src/Utils/formatters.php';

$user_data = verify_jwt_and_get_user();

$data = json_decode(file_get_contents("php://input"), true);
$expense_id = $data['id'] ?? null;
$update_payload = $data['updateData'] ?? null;

if (!$expense_id || !$update_payload) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Expense ID and updateData are required.']);
    exit();
}

try {
    $conn = connectDB();
    $expense_model = new Expense($conn);

    // Map frontend keys to database columns
    $db_update_data = [];
    if(isset($update_payload['date'])) $db_update_data['entry_date'] = $update_payload['date'];
    if(isset($update_payload['category'])) $db_update_data['category'] = $update_payload['category'];
    if(isset($update_payload['description'])) $db_update_data['description'] = $update_payload['description'];
    if(isset($update_payload['amount'])) $db_update_data['amount'] = $update_payload['amount'];
    if(isset($update_payload['paymentType'])) $db_update_data['payment_type'] = $update_payload['paymentType'];
    if(isset($update_payload['paidTo'])) $db_update_data['paid_to_id'] = $update_payload['paidTo'];
    if(isset($update_payload['paidToModel'])) $db_update_data['paid_to_model'] = $update_payload['paidToModel'];

    if ($expense_model->updateExpense($expense_id, $db_update_data)) {
        $updated_expense = $expense_model->findExpenseById($expense_id);
        $formatted_expense = format_expense_response($updated_expense);

        http_response_code(200);
        echo json_encode(['success' => true, 'expense' => $formatted_expense]);
    } else {
        throw new Exception('Failed to update expense or expense not found.');
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred during update: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\invoices\add_payment.php
================================================================================


<?php
// FILE: ...\php-backend\api\invoices\add_payment.php

// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

// --- Dependencies ---
require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/SalesInvoice.php'; // Will also include other models as needed
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
// Assuming any authenticated user can add a payment. Add role checks if needed.

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);
$invoice_id = $data['id'] ?? null;
$payment_data = $data['paymentData'] ?? null;

if (!$invoice_id || !$payment_data || !isset($payment_data['amount']) || !isset($payment_data['method'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Invoice ID and paymentData (amount, method) are required.']);
    exit();
}

try {
    $conn = connectDB();
    $invoice_model = new SalesInvoice($conn);

    $success = $invoice_model->addPayment($invoice_id, $payment_data);

    if ($success) {
        // Fetch the updated invoice to return in the response
        $updated_invoice_data = $invoice_model->findInvoiceById($invoice_id);
        $formatted_invoice = format_invoice_response($updated_invoice_data['invoice'], $updated_invoice_data['items'], $updated_invoice_data['payments']);

        http_response_code(200);
        echo json_encode([
            'success' => true,
            'message' => 'Payment added successfully.',
            'invoice' => $formatted_invoice
        ]);
    } else {
        throw new Exception("Failed to add payment.");
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred while adding payment: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\invoices\create.php
================================================================================

<?php
// FILE: ...\php-backend\api\invoices\create.php

header('Access-Control-Allow-Origin: *');

// Specify that the response will be in JSON format.
header('Content-Type: application/json');

// Specify the allowed HTTP methods. For creating, it's POST.
// OPTIONS is included to handle preflight requests from browsers.
header('Access-Control-Allow-Methods: POST, OPTIONS');

// Specify the allowed headers in requests from the frontend.
header('Access-Control-Allow-Headers: Content-Type, Authorization');

// Allow cookies to be sent with the request (essential for authentication).
header('Access-Control-Allow-Credentials: true');

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/SalesInvoice.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
// In the original, all authenticated users can create invoices.
// If you need to restrict, you can add role checks here.

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);

if (!isset($data['invoiceNumber']) || !isset($data['salesmanId']) || !isset($data['items']) || !is_array($data['items'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Missing required invoice data: invoiceNumber, salesmanId, and items are required.']);
    exit();
}

try {
    $items_with_totals = [];
    $sub_total = 0;
    $total_vat = 0;
    $total_cost = 0;

    foreach ($data['items'] as $item) {
        $line_total = ($item['unitPrice'] * $item['quantity']) + ($item['vatAmount'] ?? 0);
        $sub_total += $item['unitPrice'] * $item['quantity'];
        $total_vat += $item['vatAmount'] ?? 0;
        $total_cost += $item['costPrice'] * $item['quantity'];

        $items_with_totals[] = [
            'description' => $item['description'],
            'quantity' => $item['quantity'],
            'unit_price' => $item['unitPrice'],
            'cost_price' => $item['costPrice'],
            'vat_amount' => $item['vatAmount'] ?? 0,
            'line_total' => $line_total,
        ];
    }

    $grand_total = $sub_total + $total_vat;
    $total_profit = $sub_total - $total_cost;

    $invoice_data_to_save = [
        'invoice_number' => $data['invoiceNumber'],
        'customer_name' => $data['customerName'] ?? 'Walk-in Customer',
        'salesman_id' => $data['salesmanId'],
        'sub_total' => $sub_total,
        'total_vat' => $total_vat,
        'grand_total' => $grand_total,
        'total_cost' => $total_cost,
        'total_profit' => $total_profit,
        'invoice_date' => $data['date'] ?? date('Y-m-d H:i:s')
    ];

    // --- Database Interaction ---
    $conn = connectDB();
    $invoice_model = new SalesInvoice($conn);
    $new_invoice_id = $invoice_model->createInvoice($invoice_data_to_save, $items_with_totals);

    if ($new_invoice_id) {
        $new_invoice_data = $invoice_model->findInvoiceById($new_invoice_id);
        $formatted_invoice = format_invoice_response($new_invoice_data['invoice'], $new_invoice_data['items'], $new_invoice_data['payments']);

        http_response_code(201);
        echo json_encode([
            'success' => true,
            'invoice' => $formatted_invoice
        ]);
    } else {
        throw new Exception("Failed to create the invoice.");
    }

} catch (Exception $e) {
    http_response_code(500);
    if (strpos($e->getMessage(), 'Duplicate entry') !== false) {
         http_response_code(409);
         echo json_encode(['success' => false, 'message' => 'An invoice with this number already exists.']);
    } else {
         echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
    }
}
?>

================================================================================
// FILE: php-backend\api\invoices\delete.php
================================================================================

<?php
// FILE: ...\php-backend\api\invoices\delete.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/SalesInvoice.php';
require_once '../../src/Utils/formatters.php';


$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

$data = json_decode(file_get_contents("php://input"), true);
$invoice_id = $data['id'] ?? null;

if (!$invoice_id) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Invoice ID is required.']);
    exit();
}

try {
    $conn = connectDB();
    $invoice_model = new SalesInvoice($conn);

    
    $invoice_to_delete = $invoice_model->findInvoiceById($invoice_id);

    if (!$invoice_to_delete) {
        http_response_code(404);
        echo json_encode(['success' => false, 'message' => 'Invoice not found.']);
        exit();
    }

    // Attempt to delete the invoice
    if ($invoice_model->deleteInvoice($invoice_id)) {
        // The original API returns the object that was deleted.
        $formatted_invoice = format_invoice_response(
            $invoice_to_delete['invoice'], 
            $invoice_to_delete['items'],
            [] // Payments are now deleted, so pass an empty array
        );
        $formatted_invoice['status'] = 'deleted'; // Manually update status in the response

        http_response_code(200);
        echo json_encode([
            'success' => true,
            'invoice' => $formatted_invoice
        ]);
    } else {
        throw new Exception("Failed to delete invoice.");
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\invoices\pay_commission.php
================================================================================

<?php
// FILE: ...\php-backend\api\invoices\pay_commission.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/SalesInvoice.php'; // Includes other models as needed
require_once '../../src/Utils/formatters.php';

$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

$data = json_decode(file_get_contents("php://input"), true);
$invoice_id = $data['id'] ?? null;
$payment_data = $data['paymentData'] ?? null;

if (!$invoice_id || !$payment_data || !isset($payment_data['amount']) || !isset($payment_data['method'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Invoice ID and paymentData (amount, method) are required.']);
    exit();
}

try {
    $conn = connectDB();
    $invoice_model = new SalesInvoice($conn);
    $success = $invoice_model->payCommission($invoice_id, $payment_data);

    if ($success) {
        $updated_invoice_data = $invoice_model->findInvoiceById($invoice_id);
        $formatted_invoice = format_invoice_response($updated_invoice_data['invoice'], $updated_invoice_data['items'], $updated_invoice_data['payments']);

        http_response_code(200);
        echo json_encode([
            'success' => true,
            'message' => 'Commission paid successfully.',
            'invoice' => $formatted_invoice
        ]);
    } else {
        throw new Exception("Failed to pay commission.");
    }
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred while paying commission: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\invoices\read.php
================================================================================

<?php
// FILE: ...\php-backend\api\invoices\read.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/SalesInvoice.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
// All authenticated users can list invoices.

// --- Logic ---
try {
    $conn = connectDB();
    $invoice_model = new SalesInvoice($conn);

    // Get query parameters for filtering and pagination from the original API
    $page = isset($_GET['page']) ? (int)$_GET['page'] : 1;
    $limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;
    $offset = ($page - 1) * $limit;

    $filters = [
        'status' => $_GET['status'] ?? null,
        'salesmanId' => $_GET['salesmanId'] ?? null,
        'customerName' => $_GET['customerName'] ?? null
    ];

    $from = $_GET['from'] ?? null;
    $to = $_GET['to'] ?? null;
    // The original API's sort param is complex. We'll simplify to just asc/desc for now.
    $sort = isset($_GET['sort']) && strpos($_GET['sort'], 'createdAt') !== false && !strpos($_GET['sort'], '-') ? 'asc' : 'desc';

    $result = $invoice_model->getAllInvoices([
        'filters' => $filters,
        'from' => $from,
        'to' => $to,
        'sort' => $sort,
        'limit' => $limit,
        'offset' => $offset
    ]);

    $total_invoices = $result['total'];
    $invoices_data = $result['invoices'];

    // Format each invoice record for the response
    $formatted_invoices = [];
    foreach ($invoices_data as $invoice_data) {
        $formatted_invoices[] = format_invoice_response(
            $invoice_data['invoice'], 
            $invoice_data['items'], 
            $invoice_data['payments']
        );
    }

    // Build the final response object to match the original API
    $response = [
        'success' => true,
        'invoices' => $formatted_invoices,
        'pagination' => [
            'total' => (int)$total_invoices,
            'page' => $page,
            'limit' => $limit,
            'totalPages' => ceil($total_invoices / $limit),
            'hasNextPage' => $page < ceil($total_invoices / $limit),
            'hasPrevPage' => $page > 1
        ]
    ];

    http_response_code(200);
    echo json_encode($response);

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred while fetching invoices: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\invoices\read_single.php
================================================================================

<?php
// FILE: ...\php-backend\api\invoices\read_single.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/SalesInvoice.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
// All authenticated users can view an invoice, no specific role check needed.

// --- Logic ---
try {
    // 1. Get the invoice ID from the query string
    $invoice_id = $_GET['id'] ?? null;

    if (!$invoice_id) {
        http_response_code(400);
        echo json_encode(['success' => false, 'message' => 'Invoice ID is required.']);
        exit();
    }

    $conn = connectDB();
    $invoice_model = new SalesInvoice($conn);

    // 2. Reuse the findInvoiceById method from our model
    $invoice_data = $invoice_model->findInvoiceById($invoice_id);

    // 3. Check if an invoice was found
    if (!$invoice_data) {
        http_response_code(404);
        echo json_encode(['success' => false, 'message' => 'Invoice not found.']);
        exit();
    }

    // 4. Reuse our formatter to build the final, nested response object
    $formatted_invoice = format_invoice_response(
        $invoice_data['invoice'], 
        $invoice_data['items'], 
        $invoice_data['payments']
    );

    // 5. Send the successful response
    http_response_code(200);
    echo json_encode([
        'success' => true,
        'invoice' => $formatted_invoice
    ]);

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred while fetching the invoice: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\invoices\reverse_payment.php
================================================================================

<?php
// FILE: ...\php-backend\api\invoices\reverse_payment.php

// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

// --- Dependencies ---
require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/SalesInvoice.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);
$invoice_id = $data['invoiceId'] ?? null;
$payment_id = $data['paymentId'] ?? null;
$reason = $data['reason'] ?? null;

if (!$invoice_id || !$payment_id || !$reason) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Invoice ID, Payment ID, and a reason are required.']);
    exit();
}

try {
    $conn = connectDB();
    $invoice_model = new SalesInvoice($conn);

    $success = $invoice_model->reversePayment($invoice_id, $payment_id, $reason);

    if ($success) {
        // Fetch the fully updated invoice to return in the response
        $updated_invoice_data = $invoice_model->findInvoiceById($invoice_id);
        $formatted_invoice = format_invoice_response($updated_invoice_data['invoice'], $updated_invoice_data['items'], $updated_invoice_data['payments']);

        http_response_code(200);
        echo json_encode([
            'success' => true,
            'message' => 'Payment reversed successfully.',
            'invoice' => $formatted_invoice
        ]);
    } else {
        throw new Exception("Failed to reverse payment.");
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred while reversing the payment: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\invoices\update.php
================================================================================

<?php
// FILE: ...\php-backend\api\invoices\update.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/SalesInvoice.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);
$invoice_id = $data['id'] ?? null;
$update_payload = $data['updateData'] ?? null;

if (!$invoice_id || !$update_payload) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Invoice ID and updateData are required.']);
    exit();
}

try {
    $conn = connectDB();
    $invoice_model = new SalesInvoice($conn);

    // 1. Fetch the current state of the invoice
    $current_invoice_data = $invoice_model->findInvoiceById($invoice_id);

    if (!$current_invoice_data) {
        http_response_code(404);
        echo json_encode(['success' => false, 'message' => 'Invoice not found.']);
        exit();
    }

    // 2. ENFORCE BUSINESS RULE: Cannot update an invoice that has payments
    if (count($current_invoice_data['payments']) > 0) {
        http_response_code(403); // Forbidden
        echo json_encode(['success' => false, 'message' => 'This invoice cannot be updated because it has payments recorded. Please delete this invoice and create a new one instead.']);
        exit();
    }

    // --- Prepare data for update ---
    $invoice_update_data = [];
    $items_update_data = null;

    // If 'items' are part of the update, we must recalculate all totals
    if (isset($update_payload['items'])) {
        $items_with_totals = [];
        $sub_total = 0;
        $total_vat = 0;
        $total_cost = 0;

        foreach ($update_payload['items'] as $item) {
            $line_total = ($item['unitPrice'] * $item['quantity']) + ($item['vatAmount'] ?? 0);
            $sub_total += $item['unitPrice'] * $item['quantity'];
            $total_vat += $item['vatAmount'] ?? 0;
            $total_cost += $item['costPrice'] * $item['quantity'];
            $items_with_totals[] = ['description' => $item['description'], 'quantity' => $item['quantity'], 'unit_price' => $item['unitPrice'], 'cost_price' => $item['costPrice'], 'vat_amount' => $item['vatAmount'] ?? 0, 'line_total' => $line_total];
        }
        $items_update_data = $items_with_totals;

        $invoice_update_data['sub_total'] = $sub_total;
        $invoice_update_data['total_vat'] = $total_vat;
        $invoice_update_data['grand_total'] = $sub_total + $total_vat;
        $invoice_update_data['total_cost'] = $total_cost;
        $invoice_update_data['total_profit'] = $sub_total - $total_cost;
    }

    // Add other updatable fields
    if (isset($update_payload['customerName'])) {
        $invoice_update_data['customer_name'] = $update_payload['customerName'];
    }
    if (isset($update_payload['date'])) {
        $invoice_update_data['invoice_date'] = $update_payload['date'];
    }

    // --- Database Interaction ---
    $success = $invoice_model->updateInvoice($invoice_id, $invoice_update_data, $items_update_data);

    if ($success) {
        $updated_invoice_data = $invoice_model->findInvoiceById($invoice_id);
        $formatted_invoice = format_invoice_response($updated_invoice_data['invoice'], $updated_invoice_data['items'], $updated_invoice_data['payments']);

        http_response_code(200);
        echo json_encode(['success' => true, 'invoice' => $formatted_invoice]);
    } else {
        throw new Exception('Database update failed.');
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred during invoice update: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\reports\monthly.php
================================================================================

<?php
// FILE: ...\php-backend\api\reports\monthly.php

// --- Headers ---
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

// --- Dependencies ---
require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Report.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$startDate = $_GET['from'] ?? null;
$endDate = $_GET['to'] ?? null;

if (!$startDate || !$endDate) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => "Missing 'from' or 'to' query parameters."]);
    exit();
}

// Append time to ensure the whole day is included in the range
$startDate .= ' 00:00:00';
$endDate .= ' 23:59:59';

try {
    $conn = connectDB();
    $report_model = new Report($conn);

    $result = $report_model->getMonthlySummary($startDate, $endDate);

    // Format the summary rows to match the camelCase 'totalSAR' key
    $formatted_summary = [];
    foreach ($result['summary'] as $row) {
        $formatted_summary[] = [
            'description' => $row['description'],
            'type' => $row['type'],
            'totalSAR' => (float)$row['amount']
        ];
    }

    $response = [
        'success' => true,
        'summary' => [
            'summary' => $formatted_summary,
            'totals' => [
                'creditSAR' => (float)$result['totals']['creditSAR'],
                'debitSAR' => (float)$result['totals']['debitSAR']
            ]
        ]
    ];

    http_response_code(200);
    echo json_encode($response);

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred while generating the report: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\users\create.php
================================================================================



================================================================================
// FILE: php-backend\api\users\delete.php
================================================================================

<?php
// FILE: ...\php-backend\api\users\delete.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/User.php';

$user_data = verify_jwt_and_get_user();
// IMPORTANT: Only 'superAdmin' can delete users, as per the original route definition.
if ($user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden: Only a Super Admin can delete users.']);
    exit();
}

$data = json_decode(file_get_contents("php://input"), true);
$user_id_to_delete = $data['id'] ?? null;

if (!$user_id_to_delete) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'User ID is required.']);
    exit();
}

// Prevent a user from deleting themselves
if ($user_id_to_delete == $user_data['id']) {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'You cannot delete your own account.']);
    exit();
}

try {
    $conn = connectDB();
    $user_model = new User($conn);

    if ($user_model->deleteUser($user_id_to_delete)) {
        http_response_code(200);
        echo json_encode(['success' => true, 'message' => 'User deleted successfully']);
    } else {
        throw new Exception('Failed to delete user or user not found.');
    }
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\users\read.php
================================================================================

<?php
// FILE: ...\php-backend\api\users\read.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/User.php';

$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

try {
    $conn = connectDB();
    $user_model = new User($conn);

    $page = isset($_GET['page']) ? (int)$_GET['page'] : 1;
    $limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;
    $offset = ($page - 1) * $limit;

    $result = $user_model->getAllUsers([
        'role' => $_GET['role'] ?? null,
        'username' => $_GET['username'] ?? null,
        'limit' => $limit,
        'offset' => $offset
    ]);

    $response = [
        'success' => true,
        'users' => $result['users'],
        'total' => (int)$result['total'],
        'page' => $page,
        'limit' => $limit,
        'totalPages' => ceil($result['total'] / $limit),
    ];

    http_response_code(200);
    echo json_encode($response);
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\users\update.php
================================================================================

<?php
// FILE: ...\php-backend\api\users\update.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/User.php';

$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

$data = json_decode(file_get_contents("php://input"), true);
$user_id = $data['id'] ?? null;
$update_payload = $data['updateData'] ?? null;

if (!$user_id || !$update_payload) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'User ID and updateData are required.']);
    exit();
}

try {
    $conn = connectDB();
    $user_model = new User($conn);

    if ($user_model->updateUser($user_id, $update_payload)) {
        $updated_user = $user_model->findUserById($user_id);
        http_response_code(200);
        echo json_encode(['success' => true, 'user' => $updated_user]);
    } else {
        throw new Exception('Failed to update user or user not found.');
    }
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred during update: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\vendor-transactions\create.php
================================================================================

<?php
// FILE: ...\php-backend\api\vendor-transactions\create.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/CashRegister.php';
require_once '../../src/Models/BankTransaction.php';
require_once '../../src/Models/VendorTransaction.php';
require_once '../../src/Utils/formatters.php';

$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

$data = json_decode(file_get_contents("php://input"), true);

if (!isset($data['vendorId'], $data['type'], $data['description'], $data['amount'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Missing required fields.']);
    exit();
}
if ($data['type'] === 'Payment' && !isset($data['method'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Payment method is required for Payment type.']);
    exit();
}


try {
    $conn = connectDB();
    $txn_model = new VendorTransaction($conn);

    $txn_data = [
        'vendor_id' => $data['vendorId'],
        'type' => $data['type'],
        'description' => $data['description'],
        'amount' => $data['amount'],
        'method' => $data['method'] ?? null,
        'date' => $data['date'] ?? date('Y-m-d H:i:s'),
    ];

    $new_txn_id = $txn_model->addTransaction($txn_data);

    if ($new_txn_id) {
        $new_txn_db = $txn_model->findTransactionById($new_txn_id);
        $formatted_txn = format_vendor_transaction_response($new_txn_db);
        
        http_response_code(201);
        echo json_encode(['success' => true, 'transaction' => $formatted_txn]);
    } else {
        throw new Exception('Failed to record vendor transaction.');
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\vendor-transactions\delete.php
================================================================================

<?php
// FILE: ...\php-backend\api\vendor-transactions\delete.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/CashRegister.php';
require_once '../../src/Models/BankTransaction.php';
require_once '../../src/Models/VendorTransaction.php';
require_once '../../src/Utils/formatters.php';

$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

$data = json_decode(file_get_contents("php://input"), true);
$txn_id = $data['id'] ?? null;

if (!$txn_id) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Transaction ID is required.']);
    exit();
}

try {
    $conn = connectDB();
    $txn_model = new VendorTransaction($conn);
    $txn_to_delete = $txn_model->findTransactionById($txn_id);

    if ($txn_model->deleteTransaction($txn_id)) {
        $formatted_txn = format_vendor_transaction_response($txn_to_delete);
        $formatted_txn['status'] = 'deleted';

        http_response_code(200);
        echo json_encode([
            'success' => true,
            'transaction' => $formatted_txn
        ]);
    } else {
        throw new Exception('Failed to delete transaction or transaction not found.');
    }
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\vendor-transactions\read.php
================================================================================

<?php
// FILE: ...\php-backend\api\vendor-transactions\read.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/VendorTransaction.php';
require_once '../../src/Utils/formatters.php';

$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

try {
    $conn = connectDB();
    $txn_model = new VendorTransaction($conn);

    $page = isset($_GET['page']) ? (int)$_GET['page'] : 1;
    $limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;
    $offset = ($page - 1) * $limit;

    $result = $txn_model->getAllTransactions([
        'vendor_id' => $_GET['vendorId'] ?? null,
        'limit' => $limit,
        'offset' => $offset
    ]);

    $formatted_txns = array_map('format_vendor_transaction_response', $result['transactions']);

    $response = [
        'success' => true,
        'transactions' => $formatted_txns,
        'pagination' => [
            'total' => (int)$result['total'],
            'page' => $page,
            'limit' => $limit,
            'totalPages' => ceil($result['total'] / $limit),
        ]
    ];

    http_response_code(200);
    echo json_encode($response);
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\vendor-transactions\update.php
================================================================================

<?php
// FILE: ...\php-backend\api\vendor-transactions\update.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); }

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/VendorTransaction.php';
require_once '../../src/Utils/formatters.php';

$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

$data = json_decode(file_get_contents("php://input"), true);
$txn_id = $data['id'] ?? null;
$description = $data['description'] ?? null;

if (!$txn_id || $description === null) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Transaction ID and description are required.']);
    exit();
}

try {
    $conn = connectDB();
    $txn_model = new VendorTransaction($conn);

    if ($txn_model->updateTransaction($txn_id, $description)) {
        $updated_txn = $txn_model->findTransactionById($txn_id);
        $formatted_txn = format_vendor_transaction_response($updated_txn);

        http_response_code(200);
        echo json_encode(['success' => true, 'transaction' => $formatted_txn]);
    } else {
        throw new Exception('Failed to update transaction or transaction not found.');
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\vendors\create.php
================================================================================

<?php
// FILE: ...\php-backend\api\vendors\create.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');


if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Vendor.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);

if (!isset($data['name']) || !isset($data['contact'])) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Missing required vendor fields.']);
    exit();
}

try {
    $conn = connectDB();
    $vendor_model = new Vendor($conn);

    // Prepare data for the model, matching the original payload structure
    $vendor_data = [
        'name' => $data['name'],
        'email' => $data['contact']['email'] ?? null,
        'phone' => $data['contact']['phone'] ?? null,
        'address' => $data['contact']['address'] ?? null,
        'opening_balance' => $data['openingBalance'] ?? 0
    ];

    $new_vendor_id = $vendor_model->createVendor($vendor_data);

    if ($new_vendor_id) {
        $new_vendor_db = $vendor_model->findVendorById($new_vendor_id);
        $formatted_vendor = format_vendor_response($new_vendor_db);

        http_response_code(201); // 201 Created
        echo json_encode([
            'success' => true,
            'vendor' => $formatted_vendor
        ]);
    } else {
        throw new Exception('Failed to create vendor.');
    }

} catch (Exception $e) {
    http_response_code(500);
    if (strpos($e->getMessage(), 'Duplicate entry') !== false) {
         http_response_code(409); // Conflict
         echo json_encode(['success' => false, 'message' => 'A vendor with this email already exists.']);
    } else {
         echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
    }
}
?>

================================================================================
// FILE: php-backend\api\vendors\delete.php
================================================================================

<?php
// FILE: ...\php-backend\api\vendors\delete.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Vendor.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);
$vendor_id = $data['id'] ?? null;

if (!$vendor_id) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Vendor ID is required.']);
    exit();
}

try {
    $conn = connectDB();
    $vendor_model = new Vendor($conn);

    // To match the original API's response, we fetch the vendor's data before deleting
    $vendor_to_delete = $vendor_model->findVendorById($vendor_id);

    if (!$vendor_to_delete) {
        http_response_code(404);
        echo json_encode(['success' => false, 'message' => 'Vendor not found.']);
        exit();
    }

    // Attempt to soft-delete the vendor
    if ($vendor_model->softDeleteVendor($vendor_id)) {
        // The original API returns the object that was deleted.
        // We'll format the object we fetched earlier.
        $formatted_vendor = format_vendor_response($vendor_to_delete);
        $formatted_vendor['status'] = 'deleted'; // Manually update status in the response object

        http_response_code(200);
        echo json_encode([
            'success' => true,
            'vendor' => $formatted_vendor
        ]);
    } else {
        // This case might happen if the vendor was deleted between the find and delete operations
        http_response_code(404);
        echo json_encode(['success' => false, 'message' => 'Vendor not found or already deleted.']);
    }

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\vendors\read.php
================================================================================

<?php
// FILE: ...\php-backend\api\vendors\read.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');


if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Vendor.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
try {
    $conn = connectDB();
    $vendor_model = new Vendor($conn);

    // Get query parameters for filtering and pagination
    $page = isset($_GET['page']) ? (int)$_GET['page'] : 1;
    $limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;
    $search = $_GET['search'] ?? null;
    $offset = ($page - 1) * $limit;

    $result = $vendor_model->getAllVendors([
        'search' => $search,
        'limit' => $limit,
        'offset' => $offset
    ]);

    $total_vendors = $result['total'];
    $vendors_db = $result['vendors'];

    // Format each vendor record for the response
    $formatted_vendors = [];
    foreach ($vendors_db as $vendor) {
        $formatted_vendors[] = format_vendor_response($vendor);
    }

    // Build the final response object to match the original API
    $response = [
        'success' => true,
        'vendors' => $formatted_vendors,
        'pagination' => [
            'total' => (int)$total_vendors,
            'page' => $page,
            'limit' => $limit,
            'totalPages' => ceil($total_vendors / $limit),
            'hasNextPage' => $page < ceil($total_vendors / $limit),
            'hasPrevPage' => $page > 1
        ]
    ];

    http_response_code(200);
    echo json_encode($response);

} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['success' => false, 'message' => 'An error occurred: ' . $e->getMessage()]);
}
?>

================================================================================
// FILE: php-backend\api\vendors\update.php
================================================================================

<?php
// FILE: ...\php-backend\api\vendors\update.php

header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: POST, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');
header('Access-Control-Allow-Credentials: true');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(204);
    exit();
}

require_once '../../src/Middleware/authChecker.php';
require_once '../../config/database.php';
require_once '../../src/Models/Vendor.php';
require_once '../../src/Utils/formatters.php';

// --- Authorization ---
$user_data = verify_jwt_and_get_user();
if ($user_data['role'] !== 'admin' && $user_data['role'] !== 'superAdmin') {
    http_response_code(403);
    echo json_encode(['success' => false, 'message' => 'Forbidden']);
    exit();
}

// --- Logic ---
$data = json_decode(file_get_contents("php://input"), true);

$vendor_id = $data['id'] ?? null;
$update_payload = $data['updateData'] ?? null;

if (!$vendor_id || !$update_payload) {
    http_response_code(400);
    echo json_encode(['success' => false, 'message' => 'Vendor ID and updateData are required.']);
    exit();
}

try {
    $conn = connectDB();
    $vendor_model = new Vendor($conn);

    // Map the potentially nested/camelCase payload to our flat/snake_case database columns
    $db_update_data = [];
    if (isset($update_payload['name'])) $db_update_data['name'] = $update_payload['name'];
    if (isset($update_payload['openingBalance'])) $db_update_data['opening_balance'] = $update_payload['openingBalance'];
    if (isset($update_payload['status'])) $db_update_data['status'] = $update_payload['status'];

    if (isset($update_payload['contact'])) {
        if (isset($update_payload['contact']['phone'])) $db_update_data['phone'] = $update_payload['contact']['phone'];
        if (isset($update_payload['contact']['email'])) $db_update_data['email'] = $update_payload['contact']['email'];
        if (isset($update_payload['contact']['address'])) $db_update_data['address'] = $update_payload['contact']['address'];
    }

    // Update the vendor in the database
    $success = $vendor_model->updateVendor($vendor_id, $db_update_data);

    if ($success) {
        // Fetch the complete, updated record
        $updated_vendor_db = $vendor_model->findVendorById($vendor_id);
        // Format it for the response to ensure consistency
        $formatted_vendor = format_vendor_response($updated_vendor_db);

        http_response_code(200);
        echo json_encode([
            'success' => true,
            'vendor' => $formatted_vendor
        ]);
    } else {
        throw new Exception('Database update failed.');
    }

} catch (Exception $e) {
    http_response_code(500);
    if (strpos($e->getMessage(), 'Duplicate entry') !== false) {
         http_response_code(409);
         echo json_encode(['success' => false, 'message' => 'A vendor with this email already exists.']);
    } else {
         echo json_encode(['success' => false, 'message' => 'An error occurred during update: ' . $e->getMessage()]);
    }
}
?>

================================================================================
// FILE: php-backend\config\business_rules.php
================================================================================

<?php
// FILE: ...\php-backend\config\business_rules.php

define('COMMISSION_THRESHOLD_PCT', 33.0); // Profit margin must be >= this % to be eligible
define('COMMISSION_RATE_PCT', 10.0);      // The commission rate to apply to the profit

================================================================================
// FILE: php-backend\config\database.php
================================================================================

<?php


define('DB_HOST', 'localhost');
define('DB_USER', 'root'); 
define('DB_PASS', '');     
define('DB_NAME', 'pos_dubai');


function connectDB() {
    $conn = new mysqli(DB_HOST, DB_USER, DB_PASS, DB_NAME);

    if ($conn->connect_error) {
        header('Content-Type: application/json');
        http_response_code(500);
        echo json_encode([
            'success' => false,
            'message' => 'Database Connection Error: ' . $conn->connect_error
        ]);
        die();
    }

    return $conn;
}
?>

================================================================================
// FILE: php-backend\config\mail_config.php
================================================================================

<?php
// FILE: ...\php-backend\config\mail_config.php

/**
 * PHPMailer Configuration
 * * Replace these values with your actual SMTP credentials.
 * This mirrors the EMAIL_USER and EMAIL_PASS from your original .env file.
 * * For Gmail, you may need to generate an "App Password" if you have 2-Factor Authentication enabled.
 * Go to your Google Account -> Security -> App Passwords.
 */

define('MAIL_HOST', 'smtp.gmail.com');
define('MAIL_USERNAME', 'rihankhan441@gmail.com'); 
define('MAIL_PASSWORD', 'hckg jgqi wjcx phgp');   
define('MAIL_SMTP_SECURE', 'tls');             
define('MAIL_PORT', 587);                      


define('MAIL_FROM_ADDRESS', 'rihankhan441@gmail.com');
define('MAIL_FROM_NAME', 'Dubai POS');

// The base URL of your frontend application for generating reset links
define('FRONTEND_URL', 'http://localhost:5173'); 

?>


================================================================================
// FILE: php-backend\src\Middleware\authChecker.php
================================================================================

<?php
// FILE: ...php-backend\src\Middleware\authChecker.php

// This script replaces the jwtVerify middleware from authChecker.js

require_once __DIR__ . '/../../config/database.php';
require_once __DIR__ . '/../../config/jwt_config.php'; 
require_once __DIR__ . '/../../src/Models/User.php';
require_once __DIR__ . '/../../vendor/autoload.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

/**
 * Verifies the user's JWT. On failure, it sends a 401 response and terminates the script.
 * On success, it returns the authenticated user's data.
 * @return array The user's data (id, username, email, role).
 */
function verify_jwt_and_get_user() {
    // 1. Get token from cookie or Authorization header 
    $token = $_COOKIE['accessToken'] ?? null;
    $headers = getallheaders();
    $authHeader = $headers['Authorization'] ?? $headers['authorization'] ?? null;

    if (!$token && $authHeader && preg_match('/Bearer\s(\S+)/', $authHeader, $matches)) {
        $token = $matches[1];
    }

    if (!$token) {
        http_response_code(401);
        echo json_encode(['success' => false, 'message' => 'Unauthorized Request: No token provided']);
        exit();
    }

    // 2. Try to decode the token
    try {
        $decoded = JWT::decode($token, new Key(ACCESS_TOKEN_SECRET, 'HS256'));

        if (!isset($decoded->_id)) {
            throw new Exception('Invalid token structure');
        }

        // 3. Find the user in the database
        $conn = connectDB();
        $user_model = new User($conn);
        $user = $user_model->findUserById($decoded->_id);

        if (!$user) {
            http_response_code(401);
            echo json_encode(['success' => false, 'message' => 'Invalid Access Token: User not found']);
            exit();
        }

        // 4. Return the user data on success
        return $user;

    } catch (Exception $e) {
        // Catches expired tokens, invalid signatures, etc.
        http_response_code(401);
        echo json_encode(['success' => false, 'message' => 'Invalid or Expired Access Token: ' . $e->getMessage()]);
        exit();
    }
}
?>

================================================================================
// FILE: php-backend\src\Models\BankTransaction.php
================================================================================

<?php
// FILE: ...\php-backend\src\Models\BankTransaction.php

class BankTransaction {
    private $conn;
    private $table_name = "bank_transactions";

    public function __construct($db) {
        $this->conn = $db;
    }

    public function recordTransaction($data) {
        $this->conn->begin_transaction();
        try {
            $last_entry_query = "SELECT balance FROM " . $this->table_name . " WHERE status = 'active' ORDER BY entry_date DESC, id DESC LIMIT 1";
            $last_entry_stmt = $this->conn->prepare($last_entry_query);
            $last_entry_stmt->execute();
            $result = $last_entry_stmt->get_result();
            $last_balance = ($result->num_rows > 0) ? $result->fetch_assoc()['balance'] : 0;
            $last_entry_stmt->close();

            $new_balance = $last_balance;
            if ($data['type'] === 'Inflow') {
                $new_balance += $data['amount'];
            } elseif ($data['type'] === 'Outflow') {
                $new_balance -= $data['amount'];
            } else { // 'Opening'
                $new_balance = $data['amount'];
            }

            $insert_query = "INSERT INTO " . $this->table_name . " (entry_date, type, method, reference, amount, balance) VALUES (?, ?, ?, ?, ?, ?)";
            $stmt = $this->conn->prepare($insert_query);
            $entry_date = $data['date'] ?? date('Y-m-d H:i:s');
            $stmt->bind_param("ssssdd", $entry_date, $data['type'], $data['method'], $data['reference'], $data['amount'], $new_balance);

            $stmt->execute();
            $new_id = $stmt->insert_id;
            $stmt->close();

            if (!$new_id) throw new Exception("Failed to create bank transaction.");

            $this->conn->commit();
            return $new_id;
        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e;
        }
    }

    public function findTransactionById($id) {
        $query = "SELECT * FROM " . $this->table_name . " WHERE id = ? LIMIT 1";
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("i", $id);
        $stmt->execute();
        $result = $stmt->get_result();
        $stmt->close();
        return ($result->num_rows > 0) ? $result->fetch_assoc() : null;
    }

    public function getAllTransactions($options) {
        $base_query = " FROM " . $this->table_name . " WHERE status = 'active'";
        $params = [];
        $types = "";

        if (!empty($options['method'])) {
            $base_query .= " AND method = ?";
            $params[] = $options['method'];
            $types .= "s";
        }
        if (!empty($options['from'])) {
            $base_query .= " AND entry_date >= ?";
            $params[] = $options['from'];
            $types .= "s";
        }
        if (!empty($options['to'])) {
            $base_query .= " AND entry_date <= ?";
            $params[] = $options['to'];
            $types .= "s";
        }

        $count_query = "SELECT count(*) as total" . $base_query;
        $stmt_count = $this->conn->prepare($count_query);
        if (!empty($params)) $stmt_count->bind_param($types, ...$params);
        $stmt_count->execute();
        $total = $stmt_count->get_result()->fetch_assoc()['total'];
        $stmt_count->close();

        $data_query = "SELECT *" . $base_query . " ORDER BY entry_date DESC, id DESC LIMIT ? OFFSET ?";
        $params[] = $options['limit'];
        $params[] = $options['offset'];
        $types .= "ii";
        $stmt_data = $this->conn->prepare($data_query);
        $stmt_data->bind_param($types, ...$params);
        $stmt_data->execute();
        $transactions = $stmt_data->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt_data->close();

        return ['total' => $total, 'transactions' => $transactions];
    }

    public function updateTransaction($id, $reference) {
        $query = "UPDATE " . $this->table_name . " SET reference = ? WHERE id = ? AND status = 'active'";
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("si", $reference, $id);
        if ($stmt->execute()) {
            return $stmt->affected_rows > 0;
        }
        return false;
    }

    public function deleteTransaction($id) {
        $this->conn->begin_transaction();
        try {
            $txn_to_delete = $this->findTransactionById($id);
            if (!$txn_to_delete || $txn_to_delete['status'] === 'deleted') {
                $this->conn->rollback();
                return false;
            }

            $delete_query = "UPDATE " . $this->table_name . " SET status = 'deleted' WHERE id = ?";
            $stmt_del = $this->conn->prepare($delete_query);
            $stmt_del->bind_param("i", $id);
            $stmt_del->execute();
            $stmt_del->close();

            $prev_query = "SELECT balance FROM " . $this->table_name . " WHERE (entry_date < ? OR (entry_date = ? AND id < ?)) AND status = 'active' ORDER BY entry_date DESC, id DESC LIMIT 1";
            $stmt_prev = $this->conn->prepare($prev_query);
            $stmt_prev->bind_param("ssi", $txn_to_delete['entry_date'], $txn_to_delete['entry_date'], $id);
            $stmt_prev->execute();
            $result_prev = $stmt_prev->get_result();
            $running_balance = ($result_prev->num_rows > 0) ? $result_prev->fetch_assoc()['balance'] : 0;
            $stmt_prev->close();

            $subsequent_query = "SELECT id, type, amount FROM " . $this->table_name . " WHERE (entry_date > ? OR (entry_date = ? AND id > ?)) AND status = 'active' ORDER BY entry_date ASC, id ASC";
            $stmt_sub = $this->conn->prepare($subsequent_query);
            $stmt_sub->bind_param("ssi", $txn_to_delete['entry_date'], $txn_to_delete['entry_date'], $id);
            $stmt_sub->execute();
            $subsequent_entries = $stmt_sub->get_result()->fetch_all(MYSQLI_ASSOC);
            $stmt_sub->close();

            $update_balance_query = "UPDATE " . $this->table_name . " SET balance = ? WHERE id = ?";
            $stmt_update = $this->conn->prepare($update_balance_query);
            foreach ($subsequent_entries as $entry) {
                if ($entry['type'] === 'Inflow') {
                    $running_balance += $entry['amount'];
                } elseif ($entry['type'] === 'Outflow') {
                    $running_balance -= $entry['amount'];
                }
                $stmt_update->bind_param("di", $running_balance, $entry['id']);
                $stmt_update->execute();
            }
            $stmt_update->close();

            $this->conn->commit();
            return true;
        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e;
        }
    }
}
?>

================================================================================
// FILE: php-backend\src\Models\CashRegister.php
================================================================================

<?php
// FILE: ...\php-backend\src\Models\CashRegister.php

class CashRegister {
    private $conn;
    private $table_name = "cash_register";

    public function __construct($db) {
        $this->conn = $db;
    }

    /**
     * Records a new cash entry and calculates the running balance.
     * @param array $data Associative array of cash entry data.
     * @return int|false The ID of the new entry, or false on failure.
     */
    public function recordCashEntry($data) {
        $this->conn->begin_transaction();

        try {
            // 1. Get the last active entry to determine the previous balance.
            $last_entry_query = "SELECT balance FROM " . $this->table_name . " WHERE status = 'active' ORDER BY entry_date DESC, id DESC LIMIT 1";
            $last_entry_stmt = $this->conn->prepare($last_entry_query);
            $last_entry_stmt->execute();
            $result = $last_entry_stmt->get_result();
            $last_balance = ($result->num_rows > 0) ? $result->fetch_assoc()['balance'] : 0;
            $last_entry_stmt->close();

            // 2. Calculate the new balance.
            $new_balance = $last_balance;
            if ($data['type'] === 'Inflow') {
                $new_balance += $data['amount'];
            } elseif ($data['type'] === 'Outflow') {
                $new_balance -= $data['amount'];
            } else { // 'Opening'
                $new_balance = $data['amount'];
            }

            // 3. Insert the new cash entry.
            $insert_query = "INSERT INTO " . $this->table_name . " (entry_date, type, reference, amount, balance) VALUES (?, ?, ?, ?, ?)";
            $stmt = $this->conn->prepare($insert_query);
            $entry_date = $data['date'] ?? date('Y-m-d H:i:s');
            $stmt->bind_param("sssdd", $entry_date, $data['type'], $data['reference'], $data['amount'], $new_balance);

            $stmt->execute();
            $new_id = $stmt->insert_id;
            $stmt->close();

            if (!$new_id) {
                throw new Exception("Failed to create cash entry.");
            }

            $this->conn->commit();
            return $new_id;

        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e;
        }
    }

    /**
     * Finds a cash entry by its unique ID.
     * @param int $id The entry's ID.
     * @return array|null The entry data if found, otherwise null.
     */
    public function findEntryById($id) {
        $query = "SELECT * FROM " . $this->table_name . " WHERE id = ? LIMIT 1";
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("i", $id);
        $stmt->execute();
        $result = $stmt->get_result();
        $stmt->close();
        return ($result->num_rows > 0) ? $result->fetch_assoc() : null;
    }
    /**
 * Fetches a paginated and filtered list of cash entries.
 * @param array $options Contains filters (type, from, to) and pagination (limit, offset).
 * @return array An array containing the list of entries and the total count.
 */
public function getAllEntries($options) {
    $base_query = " FROM " . $this->table_name . " WHERE status = 'active'";
    $params = [];
    $types = "";

    // Build WHERE clause dynamically
    if (!empty($options['type'])) {
        $base_query .= " AND type = ?";
        $params[] = $options['type'];
        $types .= "s";
    }
    if (!empty($options['from'])) {
        $base_query .= " AND entry_date >= ?";
        $params[] = $options['from'];
        $types .= "s";
    }
    if (!empty($options['to'])) {
        $base_query .= " AND entry_date <= ?";
        $params[] = $options['to'];
        $types .= "s";
    }

    // First Query: Get the total count for pagination
    $count_query = "SELECT count(*) as total" . $base_query;
    $stmt_count = $this->conn->prepare($count_query);
    if (!empty($params)) {
        $stmt_count->bind_param($types, ...$params);
    }
    $stmt_count->execute();
    $total = $stmt_count->get_result()->fetch_assoc()['total'];
    $stmt_count->close();

    // Second Query: Get the paginated data, sorted with newest first
    $data_query = "SELECT *" . $base_query . " ORDER BY entry_date DESC, id DESC LIMIT ? OFFSET ?";
    $params[] = $options['limit'];
    $params[] = $options['offset'];
    $types .= "ii";

    $stmt_data = $this->conn->prepare($data_query);
    $stmt_data->bind_param($types, ...$params);
    $stmt_data->execute();
    $entries = $stmt_data->get_result()->fetch_all(MYSQLI_ASSOC);
    $stmt_data->close();

    return ['total' => $total, 'entries' => $entries];
}
/**
 * Updates the reference field of a specific cash entry.
 * @param int $id The ID of the entry to update.
 * @param string $reference The new reference text.
 * @return bool True on success, false otherwise.
 */
public function updateEntry($id, $reference) {
    $query = "UPDATE " . $this->table_name . " SET reference = ? WHERE id = ? AND status = 'active'";

    $stmt = $this->conn->prepare($query);
    $stmt->bind_param("si", $reference, $id);

    if ($stmt->execute()) {
        return $stmt->affected_rows > 0;
    }
    return false;
}
/**
 * Soft deletes a cash entry and recalculates all subsequent balances.
 * @param int $id The ID of the entry to delete.
 * @return bool True on success, false on failure.
 */
public function deleteEntry($id) {
    $this->conn->begin_transaction();
    try {
        // 1. Get the entry to be deleted to know its date and amount.
        $entry_to_delete = $this->findEntryById($id);
        if (!$entry_to_delete || $entry_to_delete['status'] === 'deleted') {
            $this->conn->rollback();
            return false; // Entry not found or already deleted
        }

        // 2. Soft-delete the entry.
        $delete_query = "UPDATE " . $this->table_name . " SET status = 'deleted' WHERE id = ?";
        $stmt_del = $this->conn->prepare($delete_query);
        $stmt_del->bind_param("i", $id);
        $stmt_del->execute();
        $stmt_del->close();

        // 3. Find the last entry before the one we deleted to get a starting balance.
        $prev_query = "SELECT balance FROM " . $this->table_name . " WHERE (entry_date < ? OR (entry_date = ? AND id < ?)) AND status = 'active' ORDER BY entry_date DESC, id DESC LIMIT 1";
        $stmt_prev = $this->conn->prepare($prev_query);
        $stmt_prev->bind_param("ssi", $entry_to_delete['entry_date'], $entry_to_delete['entry_date'], $id);
        $stmt_prev->execute();
        $result_prev = $stmt_prev->get_result();
        $running_balance = ($result_prev->num_rows > 0) ? $result_prev->fetch_assoc()['balance'] : 0;
        $stmt_prev->close();

        // 4. Get all subsequent active entries that need recalculating.
        $subsequent_query = "SELECT id, type, amount FROM " . $this->table_name . " WHERE (entry_date > ? OR (entry_date = ? AND id > ?)) AND status = 'active' ORDER BY entry_date ASC, id ASC";
        $stmt_sub = $this->conn->prepare($subsequent_query);
        $stmt_sub->bind_param("ssi", $entry_to_delete['entry_date'], $entry_to_delete['entry_date'], $id);
        $stmt_sub->execute();
        $subsequent_entries = $stmt_sub->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt_sub->close();

        // 5. Loop through and update balances.
        $update_balance_query = "UPDATE " . $this->table_name . " SET balance = ? WHERE id = ?";
        $stmt_update = $this->conn->prepare($update_balance_query);
        foreach ($subsequent_entries as $entry) {
            if ($entry['type'] === 'Inflow') {
                $running_balance += $entry['amount'];
            } elseif ($entry['type'] === 'Outflow') {
                $running_balance -= $entry['amount'];
            }
            $stmt_update->bind_param("di", $running_balance, $entry['id']);
            $stmt_update->execute();
        }
        $stmt_update->close();

        $this->conn->commit();
        return true;
    } catch (Exception $e) {
        $this->conn->rollback();
        throw $e;
    }
}
}
?>

================================================================================
// FILE: php-backend\src\Models\Dashboard.php
================================================================================

<?php
// FILE: ...\php-backend\src\Models\Dashboard.php

class Dashboard {
    private $conn;

    public function __construct($db) {
        $this->conn = $db;
    }

    /**
     * Fetches all-time key performance indicators for the dashboard.
     * @return array An associative array of all calculated metrics.
     */
    public function getDashboardMetrics() {
        $metrics = [];

        // 1. Financial Summary from Sales Invoices
        $query_sales = "SELECT 
                            SUM(grand_total) as totalSales,
                            SUM(total_profit) as totalProfit,
                            SUM(total_vat) as totalVat
                        FROM sales_invoices WHERE status != 'deleted'";
        $metrics['financial'] = $this->conn->query($query_sales)->fetch_assoc();

        // 2. Total Payments by Method
        $query_payments = "SELECT method, SUM(amount) as total FROM invoice_payments GROUP BY method";
        $payments_result = $this->conn->query($query_payments)->fetch_all(MYSQLI_ASSOC);
        $metrics['payments'] = [];
        foreach ($payments_result as $row) {
            $metrics['payments'][$row['method']] = (float)$row['total'];
        }

        // 3. Total Expenses
        $query_expenses = "SELECT SUM(amount) as totalExpenses FROM expenses WHERE status = 'active'";
        $metrics['financial']['totalExpenses'] = (float)$this->conn->query($query_expenses)->fetch_assoc()['totalExpenses'];

        // 4. Top 5 Salesmen
        $query_salesmen = "SELECT 
                            e.name, 
                            SUM(si.grand_total) as totalSales,
                            COUNT(si.id) as totalTransactions
                           FROM sales_invoices si
                           JOIN employees e ON si.salesman_id = e.id
                           WHERE si.status != 'deleted'
                           GROUP BY e.id, e.name
                           ORDER BY totalSales DESC
                           LIMIT 5";
        $metrics['topSalesmen'] = $this->conn->query($query_salesmen)->fetch_all(MYSQLI_ASSOC);

        // 5. Top 5 Vendors (by expense)
        $query_vendors = "SELECT
                            v.name,
                            SUM(ex.amount) as totalPurchases,
                            COUNT(ex.id) as totalTransactions
                          FROM expenses ex
                          JOIN vendors v ON ex.paid_to_id = v.id
                          WHERE ex.status = 'active' AND ex.paid_to_model = 'Vendor'
                          GROUP BY v.id, v.name
                          ORDER BY totalPurchases DESC
                          LIMIT 5";
        $metrics['topVendors'] = $this->conn->query($query_vendors)->fetch_all(MYSQLI_ASSOC);

        return $metrics;
    }
    /**
 * Fetches key performance indicators for a specific date range.
 * @param string $startDate The start date in 'Y-m-d' format.
 * @param string $endDate The end date in 'Y-m-d' format.
 * @return array An associative array of all calculated metrics for the range.
 */
public function getDashboardMetricsForDateRange($startDate, $endDate) {
    $metrics = [];
    $startDate .= ' 00:00:00'; // Include the whole start day
    $endDate .= ' 23:59:59';   // Include the whole end day

    // 1. Financial Summary from Sales Invoices within date range
    $query_sales = "SELECT 
                        SUM(grand_total) as totalSales,
                        SUM(total_profit) as totalProfit,
                        SUM(total_vat) as totalVat
                    FROM sales_invoices 
                    WHERE status != 'deleted' AND invoice_date BETWEEN ? AND ?";
    $stmt_sales = $this->conn->prepare($query_sales);
    $stmt_sales->bind_param("ss", $startDate, $endDate);
    $stmt_sales->execute();
    $metrics['financial'] = $stmt_sales->get_result()->fetch_assoc();
    $stmt_sales->close();

    // 2. Total Payments by Method within date range
    $query_payments = "SELECT p.method, SUM(p.amount) as total 
                       FROM invoice_payments p
                       JOIN sales_invoices si ON p.invoice_id = si.id
                       WHERE si.status != 'deleted' AND p.payment_date BETWEEN ? AND ?
                       GROUP BY p.method";
    $stmt_payments = $this->conn->prepare($query_payments);
    $stmt_payments->bind_param("ss", $startDate, $endDate);
    $stmt_payments->execute();
    $payments_result = $stmt_payments->get_result()->fetch_all(MYSQLI_ASSOC);
    $metrics['payments'] = [];
    foreach ($payments_result as $row) {
        $metrics['payments'][$row['method']] = (float)$row['total'];
    }
    $stmt_payments->close();

    // 3. Total Expenses within date range
    $query_expenses = "SELECT SUM(amount) as totalExpenses FROM expenses WHERE status = 'active' AND entry_date BETWEEN ? AND ?";
    $stmt_expenses = $this->conn->prepare($query_expenses);
    $stmt_expenses->bind_param("ss", $startDate, $endDate);
    $stmt_expenses->execute();
    $metrics['financial']['totalExpenses'] = (float)$stmt_expenses->get_result()->fetch_assoc()['totalExpenses'];
    $stmt_expenses->close();

    // 4. Top 5 Salesmen within date range
    $query_salesmen = "SELECT e.name, SUM(si.grand_total) as totalSales, COUNT(si.id) as totalTransactions
                       FROM sales_invoices si JOIN employees e ON si.salesman_id = e.id
                       WHERE si.status != 'deleted' AND si.invoice_date BETWEEN ? AND ?
                       GROUP BY e.id, e.name ORDER BY totalSales DESC LIMIT 5";
    $stmt_salesmen = $this->conn->prepare($query_salesmen);
    $stmt_salesmen->bind_param("ss", $startDate, $endDate);
    $stmt_salesmen->execute();
    $metrics['topSalesmen'] = $stmt_salesmen->get_result()->fetch_all(MYSQLI_ASSOC);
    $stmt_salesmen->close();

    // 5. Top 5 Vendors within date range
    $query_vendors = "SELECT v.name, SUM(ex.amount) as totalPurchases, COUNT(ex.id) as totalTransactions
                      FROM expenses ex JOIN vendors v ON ex.paid_to_id = v.id
                      WHERE ex.status = 'active' AND ex.paid_to_model = 'Vendor' AND ex.entry_date BETWEEN ? AND ?
                      GROUP BY v.id, v.name ORDER BY totalPurchases DESC LIMIT 5";
    $stmt_vendors = $this->conn->prepare($query_vendors);
    $stmt_vendors->bind_param("ss", $startDate, $endDate);
    $stmt_vendors->execute();
    $metrics['topVendors'] = $stmt_vendors->get_result()->fetch_all(MYSQLI_ASSOC);
    $stmt_vendors->close();

    return $metrics;
}
}
?>

================================================================================
// FILE: php-backend\src\Models\Employee.php
================================================================================

<?php
// FILE: ...\php-backend\src\Models\Employee.php

class Employee {
    private $conn;
    private $table_name = "employees";

    public function __construct($db) {
        $this->conn = $db;
    }
    /**
 * Fetches a paginated list of employees with optional filters.
 * Corresponds to `getAllEmployees` service function.
 * @param array $options Contains filters (role, search) and pagination (limit, offset).
 * @return array An array containing the list of employees and the total count.
 */
public function getAllEmployees($options) {
    $base_query = " FROM " . $this->table_name . " WHERE status = 'active'";
    $params = [];
    $types = "";

    // Build WHERE clause dynamically
    $where_clause = "";
    if (!empty($options['role'])) {
        $where_clause .= " AND role = ?";
        $params[] = $options['role'];
        $types .= "s";
    }
    if (!empty($options['search'])) {
        $where_clause .= " AND (name LIKE ? OR email LIKE ?)";
        $search_term = "%" . $options['search'] . "%";
        $params[] = $search_term;
        $params[] = $search_term;
        $types .= "ss";
    }

    $count_query = "SELECT count(*) as total" . $base_query . $where_clause;
    $stmt_count = $this->conn->prepare($count_query);
    if ($types) {
        $stmt_count->bind_param($types, ...$params);
    }
    $stmt_count->execute();
    $total = $stmt_count->get_result()->fetch_assoc()['total'];

    // Get the paginated data
    $data_query = "SELECT *" . $base_query . $where_clause . " ORDER BY created_at DESC LIMIT ? OFFSET ?";
    $params[] = $options['limit'];
    $params[] = $options['offset'];
    $types .= "ii";

    $stmt_data = $this->conn->prepare($data_query);
    $stmt_data->bind_param($types, ...$params);
    $stmt_data->execute();
    $result = $stmt_data->get_result();
    $employees = $result->fetch_all(MYSQLI_ASSOC);

    return ['total' => $total, 'employees' => $employees];
}
/**
 * Deletes an employee record from the database.
 * Corresponds to `Employee.findByIdAndDelete(id)`.
 * @param int $id The ID of the employee to delete.
 * @return bool True if a record was deleted, false otherwise.
 */
public function deleteEmployee($id) {
    $query = "DELETE FROM " . $this->table_name . " WHERE id = ?";

    $stmt = $this->conn->prepare($query);
    $stmt->bind_param("i", $id);

    if ($stmt->execute()) {
        // Check if any row was actually affected
        if ($stmt->affected_rows > 0) {
            return true;
        }
    }
    return false;
}
    /**
 * Updates an employee record with the given data.
 * Dynamically builds the query to only update provided fields.
 * @param int $id The ID of the employee to update.
 * @param array $data An associative array of fields to update.
 * @return bool True on success, false on failure.
 */
public function updateEmployee($id, $data) {
    if (empty($data)) {
        return true; // Nothing to update
    }

    $query_parts = [];
    $params = [];
    $types = "";

    // Dynamically build the SET part of the query
    foreach ($data as $key => $value) {
        $query_parts[] = "`$key` = ?";
        $params[] = &$data[$key]; // Pass by reference for bind_param

        // Determine the type for bind_param
        if (is_int($value)) {
            $types .= "i";
        } elseif (is_double($value) || is_float($value)) {
            $types .= "d";
        } else {
            $types .= "s";
        }
    }

    // Add the employee ID to the parameters for the WHERE clause
    $params[] = &$id;
    $types .= "i";

    $query = "UPDATE " . $this->table_name . " SET " . implode(", ", $query_parts) . " WHERE id = ?";

    $stmt = $this->conn->prepare($query);
    $stmt->bind_param($types, ...$params);

    return $stmt->execute();
    }

    /**
     * Creates a new employee record in the database.
     * Corresponds to the `addEmployee` function in `employeeService.js`.
     * @param array $data Associative array of employee data.
     * @return int|false The ID of the newly created employee, or false on failure.
     */
    public function createEmployee($data) {
        // This logic mimics the Mongoose pre-save hook 
        // If net salary isn't provided, it defaults to the gross salary.
        if (!isset($data['salary_net'])) {
            $data['salary_net'] = $data['salary_gross'];
        }

        $query = "INSERT INTO " . $this->table_name . " 
                    (name, phone, email, address, role, hire_date, salary_gross, salary_net) 
                  VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
        
        $stmt = $this->conn->prepare($query);

        // Bind parameters to the prepared statement
        $stmt->bind_param("ssssssdd", 
            $data['name'],
            $data['phone'],
            $data['email'],
            $data['address'],
            $data['role'],
            $data['hire_date'],
            $data['salary_gross'],
            $data['salary_net']
        );
        
        if ($stmt->execute()) {
            return $stmt->insert_id; // Return the new employee's ID
        }
        
        return false;
    }

     /**
     * Finds an employee by their unique ID.
     * @param int $id The employee's ID.
     * @return array|null The employee data if found, otherwise null.
     */
    public function findEmployeeById($id) {
        $query = "SELECT * FROM " . $this->table_name . " WHERE id = ? LIMIT 1";

        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("i", $id);
        $stmt->execute();
        $result = $stmt->get_result();

        if ($result->num_rows > 0) {
            return $result->fetch_assoc();
        }
        return null;
    }
}
?>

================================================================================
// FILE: php-backend\src\Models\Expense.php
================================================================================

<?php
// FILE: ...\php-backend\src\Models\Expense.php

class Expense {
    private $conn;
    private $table_name = "expenses";

    public function __construct($db) {
        $this->conn = $db;
    }

    public function recordExpense($data) {
        $this->conn->begin_transaction();
        try {
            // 1. Create the ledger entry first (cash or bank outflow)
            $ledger_entry_id = null;
            $ledger_entry_model = null;

            $reference = "Expense: " . ($data['description'] ?? 'N/A');

            if ($data['payment_type'] === 'Cash') {
                $cash_model = new CashRegister($this->conn);
                $ledger_entry_id = $cash_model->recordCashEntry([
                    'date' => $data['date'],
                    'type' => 'Outflow',
                    'reference' => $reference,
                    'amount' => $data['amount']
                ]);
                $ledger_entry_model = 'CashRegister';
            } else { // Bank or Shabka
                $bank_model = new BankTransaction($this->conn);
                $ledger_entry_id = $bank_model->recordTransaction([
                    'date' => $data['date'],
                    'type' => 'Outflow',
                    'method' => $data['payment_type'],
                    'reference' => $reference,
                    'amount' => $data['amount']
                ]);
                $ledger_entry_model = 'BankTransaction';
            }

            if (!$ledger_entry_id) {
                throw new Exception("Failed to create ledger transaction for expense.");
            }

            // 2. Now, create the expense record and link it to the ledger entry
            $query = "INSERT INTO " . $this->table_name . " 
                        (entry_date, category, description, amount, payment_type, paid_to_id, paid_to_model, ledger_entry_id, ledger_entry_model) 
                      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";

            $stmt = $this->conn->prepare($query);
            $entry_date = $data['date'] ?? date('Y-m-d H:i:s');
            $stmt->bind_param("ssdsisiis", 
                $entry_date, $data['category'], $data['description'], $data['amount'],
                $data['payment_type'], $data['paid_to_id'], $data['paid_to_model'],
                $ledger_entry_id, $ledger_entry_model
            );

            $stmt->execute();
            $new_id = $stmt->insert_id;
            $stmt->close();

            if (!$new_id) {
                throw new Exception("Failed to create expense record after ledger entry.");
            }

            $this->conn->commit();
            return $new_id;
        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e;
        }
    }

    public function findExpenseById($id) {
        $query = "SELECT * FROM " . $this->table_name . " WHERE id = ? LIMIT 1";
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("i", $id);
        $stmt->execute();
        $result = $stmt->get_result();
        $stmt->close();
        return ($result->num_rows > 0) ? $result->fetch_assoc() : null;
    }
    

    public function getAllExpenses($options) {
        $base_query = " FROM " . $this->table_name . " WHERE status = 'active'";
        $params = [];
        $types = "";

        if (!empty($options['category'])) {
            $base_query .= " AND category = ?";
            $params[] = $options['category'];
            $types .= "s";
        }
        if (!empty($options['payment_type'])) {
            $base_query .= " AND payment_type = ?";
            $params[] = $options['payment_type'];
            $types .= "s";
        }
        if (!empty($options['search'])) {
            $base_query .= " AND description LIKE ?";
            $search_term = "%" . $options['search'] . "%";
            $params[] = $search_term;
            $types .= "s";
        }

        // Get total count
        $count_query = "SELECT count(*) as total" . $base_query;
        $stmt_count = $this->conn->prepare($count_query);
        if (!empty($params)) $stmt_count->bind_param($types, ...$params);
        $stmt_count->execute();
        $total = $stmt_count->get_result()->fetch_assoc()['total'];
        $stmt_count->close();

        // Get paginated data
        $data_query = "SELECT * " . $base_query . " ORDER BY entry_date DESC, id DESC LIMIT ? OFFSET ?";
        $params[] = $options['limit'];
        $params[] = $options['offset'];
        $types .= "ii";
        $stmt_data = $this->conn->prepare($data_query);
        $stmt_data->bind_param($types, ...$params);
        $stmt_data->execute();
        $expenses = $stmt_data->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt_data->close();

        return ['total' => $total, 'expenses' => $expenses];
    }
    /**
 * Updates an expense record. If amount or payment type changes, it reverses the old
 * ledger entry and creates a new one to maintain financial integrity.
 * @param int $id The ID of the expense to update.
 * @param array $data The new data for the expense.
 * @return bool True on success, false on failure.
 */
public function updateExpense($id, $data) {
    $this->conn->begin_transaction();
    try {
        // 1. Get the current state of the expense
        $current_expense = $this->findExpenseById($id);
        if (!$current_expense) {
            $this->conn->rollback();
            return false;
        }

        // 2. Determine if a financial transaction reversal/re-creation is needed
        $needs_ledger_update = isset($data['amount']) && $data['amount'] != $current_expense['amount'] ||
                               isset($data['payment_type']) && $data['payment_type'] != $current_expense['payment_type'];

        if ($needs_ledger_update) {
            // Reverse the original ledger entry
            if ($current_expense['ledger_entry_model'] === 'CashRegister') {
                $cash_model = new CashRegister($this->conn);
                $cash_model->deleteEntry($current_expense['ledger_entry_id']);
            } else {
                $bank_model = new BankTransaction($this->conn);
                $bank_model->deleteTransaction($current_expense['ledger_entry_id']);
            }

            // Create a new ledger entry with the updated details
            $new_payment_type = $data['payment_type'] ?? $current_expense['payment_type'];
            $new_amount = $data['amount'] ?? $current_expense['amount'];
            $new_description = $data['description'] ?? $current_expense['description'];
            $new_reference = "Expense: " . $new_description;
            $new_ledger_id = null;
            $new_ledger_model = null;

            if ($new_payment_type === 'Cash') {
                $cash_model = new CashRegister($this->conn);
                $new_ledger_id = $cash_model->recordCashEntry(['date' => date('Y-m-d H:i:s'), 'type' => 'Outflow', 'reference' => $new_reference, 'amount' => $new_amount]);
                $new_ledger_model = 'CashRegister';
            } else {
                $bank_model = new BankTransaction($this->conn);
                $new_ledger_id = $bank_model->recordTransaction(['date' => date('Y-m-d H:i:s'), 'type' => 'Outflow', 'method' => $new_payment_type, 'reference' => $new_reference, 'amount' => $new_amount]);
                $new_ledger_model = 'BankTransaction';
            }

            $data['ledger_entry_id'] = $new_ledger_id;
            $data['ledger_entry_model'] = $new_ledger_model;
        }

        // 3. Update the expense record itself
        $query_parts = [];
        $params = [];
        $types = "";
        foreach ($data as $key => $value) {
            $query_parts[] = "`$key` = ?";
            $params[] = $value;
            $types .= is_int($value) ? "i" : (is_float($value) ? "d" : "s");
        }
        $params[] = $id;
        $types .= "i";

        $update_query = "UPDATE " . $this->table_name . " SET " . implode(", ", $query_parts) . " WHERE id = ?";
        $stmt_update = $this->conn->prepare($update_query);
        $stmt_update->bind_param($types, ...$params);
        $stmt_update->execute();
        $stmt_update->close();

        $this->conn->commit();
        return true;

    } catch (Exception $e) {
        $this->conn->rollback();
        throw $e;
    }
}
public function deleteExpense($id) {
    $this->conn->begin_transaction();
    try {
        $expense = $this->findExpenseById($id);
        if (!$expense || $expense['status'] === 'deleted') {
            $this->conn->rollback();
            return false;
        }

        // Reverse the associated ledger entry
        if ($expense['ledger_entry_id']) {
            if ($expense['ledger_entry_model'] === 'CashRegister') {
                $cash_model = new CashRegister($this->conn);
                $cash_model->deleteEntry($expense['ledger_entry_id']);
            } else {
                $bank_model = new BankTransaction($this->conn);
                $bank_model->deleteTransaction($expense['ledger_entry_id']);
            }
        }

        // Soft delete the expense itself
        $query = "UPDATE " . $this->table_name . " SET status = 'deleted' WHERE id = ?";
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("i", $id);
        $stmt->execute();
        $affected_rows = $stmt->affected_rows;
        $stmt->close();

        $this->conn->commit();
        return $affected_rows > 0;
    } catch (Exception $e) {
        $this->conn->rollback();
        throw $e;
    }
}
}
?>

================================================================================
// FILE: php-backend\src\Models\Reports.php
================================================================================

<?php
// FILE: ...\php-backend\src\Models\Report.php

class Report {
    private $conn;

    public function __construct($db) {
        $this->conn = $db;
    }

    /**
     * Produces a financial summary between two dates.
     * This query combines multiple tables to create a list of all credits and debits.
     * @param string $startDate The start date in 'Y-m-d H:i:s' format.
     * @param string $endDate The end date in 'Y-m-d H:i:s' format.
     * @return array An associative array containing the summary list and totals.
     */
    public function getMonthlySummary($startDate, $endDate) {
        // Note: This is a complex query that uses UNION ALL to combine results
        // from different sources into a single financial summary report.
        $sql = "
            (SELECT 
                'Opening Balance - Cash' as description, 
                'credit' as type, 
                amount,
                entry_date as date
             FROM cash_register WHERE type = 'Opening' AND status = 'active'
            )
            UNION ALL
            (SELECT 
                CONCAT('Opening Balance - ', method) as description, 
                'credit' as type, 
                amount,
                entry_date as date
             FROM bank_transactions WHERE type = 'Opening' AND status = 'active'
            )
            UNION ALL
            (SELECT 
                CONCAT('Sale Payment - Invoice #', si.invoice_number, ' (', p.method, ')') as description,
                'credit' as type,
                p.amount,
                p.payment_date as date
             FROM invoice_payments p
             JOIN sales_invoices si ON p.invoice_id = si.id
             WHERE p.payment_date BETWEEN ? AND ?
            )
            UNION ALL
            (SELECT 
                description,
                'debit' as type,
                amount,
                entry_date as date
             FROM expenses
             WHERE status = 'active' AND entry_date BETWEEN ? AND ?
            )
            ORDER BY date
        ";

        $stmt = $this->conn->prepare($sql);
        // We bind the date range parameters for the two subqueries that use them.
        $stmt->bind_param("ssss", $startDate, $endDate, $startDate, $endDate);
        $stmt->execute();

        $summary_result = $stmt->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt->close();

        // Calculate totals manually from the combined result
        $totals = [
            'creditSAR' => 0,
            'debitSAR' => 0
        ];
        foreach($summary_result as $row) {
            if ($row['type'] === 'credit') {
                $totals['creditSAR'] += $row['amount'];
            } else {
                $totals['debitSAR'] += $row['amount'];
            }
        }

        return ['summary' => $summary_result, 'totals' => $totals];
    }
}
?>

================================================================================
// FILE: php-backend\src\Models\SalesInvoice.php
================================================================================

<?php
// FILE: ...\php-backend\src\Models\SalesInvoice.php

class SalesInvoice {
    private $conn;

    public function __construct($db) {
        $this->conn = $db;
    }

  
    public function createInvoice($invoiceData, $itemsData) {
        // We need the business rules for calculation
        require_once __DIR__ . '/../../config/business_rules.php';

        $this->conn->begin_transaction();
        try {
            // --- Commission Calculation ---
            $profit_margin_pct = ($invoiceData['sub_total'] > 0) ? ($invoiceData['total_profit'] / $invoiceData['sub_total']) * 100 : 0;
            $commission_eligible = ($profit_margin_pct >= COMMISSION_THRESHOLD_PCT);
            $commission_total = $commission_eligible ? ($invoiceData['total_profit'] * (COMMISSION_RATE_PCT / 100)) : 0;

            // 1. Insert into the main sales_invoices table with commission data
            $query1 = "INSERT INTO sales_invoices 
                        (invoice_number, customer_name, salesman_id, sub_total, total_vat, grand_total, total_cost, total_profit, 
                        commission_eligible, commission_rate_pct, commission_total, invoice_date) 
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
            $stmt1 = $this->conn->prepare($query1);
            $rate_pct = $commission_eligible ? COMMISSION_RATE_PCT : 0;
            $stmt1->bind_param("ssisddddsdds",
                $invoiceData['invoice_number'], $invoiceData['customer_name'], $invoiceData['salesman_id'],
                $invoiceData['sub_total'], $invoiceData['total_vat'], $invoiceData['grand_total'],
                $invoiceData['total_cost'], $invoiceData['total_profit'],
                $commission_eligible, $rate_pct, $commission_total,
                $invoiceData['invoice_date']
            );
            $stmt1->execute();
            $invoice_id = $stmt1->insert_id;
            $stmt1->close();

            $query2 = "INSERT INTO invoice_items (invoice_id, description, quantity, unit_price, cost_price, vat_amount, line_total) VALUES (?, ?, ?, ?, ?, ?, ?)";
            $stmt2 = $this->conn->prepare($query2);
            foreach ($itemsData as $item) {
                $stmt2->bind_param("isidddd", $invoice_id, $item['description'], $item['quantity'], $item['unit_price'], $item['cost_price'], $item['vat_amount'], $item['line_total']);
                $stmt2->execute();
            }
            $stmt2->close();

            $this->conn->commit();
            return $invoice_id;

        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e;
        }
    }

    public function findInvoiceById($id) {
        $invoice_query = "SELECT si.*, e.name as salesman_name FROM sales_invoices si 
                          LEFT JOIN employees e ON si.salesman_id = e.id
                          WHERE si.id = ? AND si.status != 'deleted'";
        $stmt = $this->conn->prepare($invoice_query);
        $stmt->bind_param("i", $id);
        $stmt->execute();
        $invoice_result = $stmt->get_result()->fetch_assoc();
        $stmt->close();

        if (!$invoice_result) return null;

        $items_query = "SELECT * FROM invoice_items WHERE invoice_id = ?";
        $stmt = $this->conn->prepare($items_query);
        $stmt->bind_param("i", $id);
        $stmt->execute();
        $items_result = $stmt->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt->close();

        $payments_query = "SELECT * FROM invoice_payments WHERE invoice_id = ?";
        $stmt = $this->conn->prepare($payments_query);
        $stmt->bind_param("i", $id);
        $stmt->execute();
        $payments_result = $stmt->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt->close();

        // Assemble the final object
        return [
            'invoice' => $invoice_result,
            'items' => $items_result,
            'payments' => $payments_result
        ];
    }
        /**
     * Records a commission payment against an invoice.
     * @param int $invoiceId The ID of the invoice.
     * @param array $paymentData Contains amount, method, and note.
     * @return bool True on success, false on failure.
     */
    public function payCommission($invoiceId, $paymentData) {
        $this->conn->begin_transaction();
        try {
            // 1. Get the current invoice and lock it
            $invQuery = "SELECT * FROM sales_invoices WHERE id = ? FOR UPDATE";
            $stmtInv = $this->conn->prepare($invQuery);
            $stmtInv->bind_param("i", $invoiceId);
            $stmtInv->execute();
            $invoice = $stmtInv->get_result()->fetch_assoc();
            $stmtInv->close();

            if (!$invoice) throw new Exception("Invoice not found.");
            if (!$invoice['commission_eligible']) throw new Exception("This invoice is not eligible for commission.");

            $balance_due = $invoice['commission_total'] - $invoice['commission_paid'];
            if ($paymentData['amount'] > round($balance_due, 2) + 0.001) {
                throw new Exception("Payment amount exceeds commission balance due.");
            }

            // 2. Record an expense for the commission payment
            $expense_model = new Expense($this->conn);
            $expense_model->recordExpense([
                'date' => date('Y-m-d H:i:s'),
                'category' => 'Commissions',
                'description' => $paymentData['note'] ?? "Commission for Invoice #" . $invoice['invoice_number'],
                'amount' => $paymentData['amount'],
                'payment_type' => $paymentData['method'],
                'paid_to_id' => $invoice['salesman_id'],
                'paid_to_model' => 'Employee',
            ]);

            // 3. Update the commission_paid field on the invoice
            $new_paid_total = $invoice['commission_paid'] + $paymentData['amount'];
            $updateQuery = "UPDATE sales_invoices SET commission_paid = ? WHERE id = ?";
            $stmtUpdate = $this->conn->prepare($updateQuery);
            $stmtUpdate->bind_param("di", $new_paid_total, $invoiceId);
            $stmtUpdate->execute();
            $stmtUpdate->close();

            $this->conn->commit();
            return true;

        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e;
        }
    }
    /**
 * Fetches a paginated and filtered list of sales invoices.
 * @param array $options Contains filters, sorting, and pagination data.
 * @return array An array containing the list of invoices and the total count.
 */
    public function getAllInvoices($options) {
        $base_query = " FROM sales_invoices si WHERE 1=1";
        $params = [];
        $types = "";

        // --- Build WHERE clause dynamically ---
        if (isset($options['filters']['status'])) {
            $base_query .= " AND si.status = ?";
            $params[] = $options['filters']['status'];
            $types .= "s";
        } else {
            $base_query .= " AND si.status != 'deleted'";
        }

        if (isset($options['filters']['salesmanId'])) {
            $base_query .= " AND si.salesman_id = ?";
            $params[] = $options['filters']['salesmanId'];
            $types .= "i";
        }

        if (isset($options['filters']['customerName'])) {
            $base_query .= " AND si.customer_name LIKE ?";
            $customerName = "%" . $options['filters']['customerName'] . "%";
            $params[] = $customerName;
            $types .= "s";
        }

        if (isset($options['from'])) {
            $base_query .= " AND si.invoice_date >= ?";
            $params[] = $options['from'];
            $types .= "s";
        }

        if (isset($options['to'])) {
            $base_query .= " AND si.invoice_date <= ?";
            $params[] = $options['to'];
            $types .= "s";
        }

        // --- First Query: Get total count for pagination ---
        $count_query = "SELECT count(si.id)" . $base_query;
        $stmt_count = $this->conn->prepare($count_query);
        if (!empty($params)) {
            $stmt_count->bind_param($types, ...$params);
        }
        $stmt_count->execute();
        $stmt_count->bind_result($total);
        $stmt_count->fetch();
        $stmt_count->close();

        // --- Second Query: Get the paginated list of main invoice data ---
        $sort_order = $options['sort'] === 'asc' ? 'ASC' : 'DESC';
        $sort_by = 'si.created_at'; // Default sort

        $data_query = "SELECT si.*, e.name as salesman_name" . $base_query . " LEFT JOIN employees e ON si.salesman_id = e.id ORDER BY " . $sort_by . " " . $sort_order . " LIMIT ? OFFSET ?";
        $params[] = $options['limit'];
        $params[] = $options['offset'];
        $types .= "ii";

        $stmt_data = $this->conn->prepare($data_query);
        $stmt_data->bind_param($types, ...$params);
        $stmt_data->execute();
        $invoices_result = $stmt_data->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt_data->close();

        if (empty($invoices_result)) {
            return ['total' => 0, 'invoices' => []];
        }

        // --- Efficiently fetch related items and payments ---
        $invoice_ids = array_column($invoices_result, 'id');
        $placeholders = implode(',', array_fill(0, count($invoice_ids), '?'));

        // Fetch all items for the retrieved invoices in one query
        $items_query = "SELECT * FROM invoice_items WHERE invoice_id IN ($placeholders)";
        $stmt_items = $this->conn->prepare($items_query);
        $stmt_items->bind_param(str_repeat('i', count($invoice_ids)), ...$invoice_ids);
        $stmt_items->execute();
        $items_result = $stmt_items->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt_items->close();

        // Fetch all payments for the retrieved invoices in one query
        $payments_query = "SELECT * FROM invoice_payments WHERE invoice_id IN ($placeholders)";
        $stmt_payments = $this->conn->prepare($payments_query);
        $stmt_payments->bind_param(str_repeat('i', count($invoice_ids)), ...$invoice_ids);
        $stmt_payments->execute();
        $payments_result = $stmt_payments->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt_payments->close();

        // --- Map items and payments back to their invoices ---
        $items_by_invoice = [];
        foreach ($items_result as $item) {
            $items_by_invoice[$item['invoice_id']][] = $item;
        }

        $payments_by_invoice = [];
        foreach ($payments_result as $payment) {
            $payments_by_invoice[$payment['invoice_id']][] = $payment;
        }

        // Assemble the final nested structure
        $assembled_invoices = [];
        foreach ($invoices_result as $invoice) {
            $invoice_id = $invoice['id'];
            $assembled_invoices[] = [
                'invoice' => $invoice,
                'items' => $items_by_invoice[$invoice_id] ?? [],
                'payments' => $payments_by_invoice[$invoice_id] ?? []
            ];
        }

        return ['total' => $total, 'invoices' => $assembled_invoices];
    }
    /**
     * Updates an invoice and its items within a transaction.
     * @param int $id The ID of the invoice to update.
     * @param array $invoiceUpdateData The main invoice data to update.
     * @param array|null $itemsUpdateData The new set of items (if they are being updated).
     * @return bool True on success, false on failure.
     */
    public function updateInvoice($id, $invoiceUpdateData, $itemsUpdateData = null) {
        $this->conn->begin_transaction();

        try {
            // --- Update main invoice record ---
            $query_parts = [];
            $params = [];
            $types = "";

            foreach ($invoiceUpdateData as $key => $value) {
                $query_parts[] = "`$key` = ?";
                $params[] = $value;
                $types .= is_int($value) ? "i" : (is_float($value) ? "d" : "s");
            }

            $params[] = $id;
            $types .= "i";

            $query1 = "UPDATE sales_invoices SET " . implode(", ", $query_parts) . " WHERE id = ?";
            $stmt1 = $this->conn->prepare($query1);
            $stmt1->bind_param($types, ...$params);
            $stmt1->execute();
            $stmt1->close();

            // --- If items are being updated, replace them ---
            if ($itemsUpdateData !== null) {
                // 1. Delete old items
                $query_del = "DELETE FROM invoice_items WHERE invoice_id = ?";
                $stmt_del = $this->conn->prepare($query_del);
                $stmt_del->bind_param("i", $id);
                $stmt_del->execute();
                $stmt_del->close();

                // 2. Insert new items
                $query_ins = "INSERT INTO invoice_items (invoice_id, description, quantity, unit_price, cost_price, vat_amount, line_total) 
                            VALUES (?, ?, ?, ?, ?, ?, ?)";
                $stmt_ins = $this->conn->prepare($query_ins);
                foreach ($itemsUpdateData as $item) {
                    $stmt_ins->bind_param("isidddd",
                        $id, $item['description'], $item['quantity'],
                        $item['unit_price'], $item['cost_price'], $item['vat_amount'], $item['line_total']
                    );
                    $stmt_ins->execute();
                }
                $stmt_ins->close();
            }

            // If all queries succeeded, commit the transaction
            $this->conn->commit();
            return true;

        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e;
        }
    }
    /**
     * Soft deletes an invoice, creates financial reversals for all its payments,
     * and recalculates subsequent balances.
     * @param int $id The ID of the invoice to delete.
     * @return bool True on success, false on failure.
     */
    public function deleteInvoice($id) {
        $this->conn->begin_transaction();

        try {
            // 1. Get the full invoice details, including payments, before deleting.
            $invoice_data = $this->findInvoiceById($id);
            if (!$invoice_data || $invoice_data['invoice']['status'] === 'deleted') {
                $this->conn->rollback();
                return false;
            }
            foreach ($invoice_data['payments'] as $payment) {
                $reversal_reference = "Reversal of payment for deleted Invoice #" . $invoice_data['invoice']['invoice_number'];
                
                if ($payment['method'] === 'Cash') {
                    $cash_model = new CashRegister($this->conn);
                    $cash_model->recordCashEntry([
                        'date' => date('Y-m-d H:i:s'),
                        'type' => 'Outflow',
                        'reference' => $reversal_reference,
                        'amount' => $payment['amount']
                    ]);
                } else { 
                    $bank_model = new BankTransaction($this->conn);
                    $bank_model->recordTransaction([
                        'date' => date('Y-m-d H:i:s'),
                        'type' => 'Outflow',
                        'method' => $payment['method'],
                        'reference' => $reversal_reference,
                        'amount' => $payment['amount']
                    ]);
                }
            }
            
            $query_del_payments = "DELETE FROM invoice_payments WHERE invoice_id = ?";
            $stmt_del = $this->conn->prepare($query_del_payments);
            $stmt_del->bind_param("i", $id);
            $stmt_del->execute();
            $stmt_del->close();
            
            $query_update_invoice = "UPDATE sales_invoices SET status = 'deleted', deleted_at = NOW() WHERE id = ?";
            $stmt_update = $this->conn->prepare($query_update_invoice);
            $stmt_update->bind_param("i", $id);
            $stmt_update->execute();
            
            $affected_rows = $stmt_update->affected_rows;
            $stmt_update->close();

            $this->conn->commit();

            return $affected_rows > 0;

        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e; 
        }
    }
    /**
 * Adds a new payment to an existing invoice and records the corresponding ledger entry.
 * @param int $invoiceId The ID of the invoice receiving the payment.
 * @param array $paymentData Contains amount, method, and date.
 * @return bool True on success, false on failure.
 */
    public function addPayment($invoiceId, $paymentData) {
        $this->conn->begin_transaction();
        try {
            // 1. Get the current invoice and lock it for the transaction
            $invoiceQuery = "SELECT * FROM sales_invoices WHERE id = ? FOR UPDATE";
            $stmt = $this->conn->prepare($invoiceQuery);
            $stmt->bind_param("i", $invoiceId);
            $stmt->execute();
            $invoice = $stmt->get_result()->fetch_assoc();
            $stmt->close();

            if (!$invoice) {
                throw new Exception("Invoice not found.");
            }
            if ($invoice['status'] === 'deleted') {
                throw new Exception("Cannot add payment to a deleted invoice.");
            }
            if ($invoice['status'] === 'Paid') {
                throw new Exception("Invoice is already fully paid.");
            }

            // 2. Calculate current paid amount and remaining balance
            $paymentsQuery = "SELECT SUM(amount) as totalPaid FROM invoice_payments WHERE invoice_id = ?";
            $stmt_paid = $this->conn->prepare($paymentsQuery);
            $stmt_paid->bind_param("i", $invoiceId);
            $stmt_paid->execute();
            $paidResult = $stmt_paid->get_result()->fetch_assoc();
            $stmt_paid->close();

            $currentPaidAmount = $paidResult['totalPaid'] ?? 0;
            $remainingBalance = $invoice['grand_total'] - $currentPaidAmount;

            if ($paymentData['amount'] > round($remainingBalance, 2) + 0.001) { 
                throw new Exception("Payment amount exceeds the remaining balance of " . round($remainingBalance, 2));
            }

            // 3. Insert the new payment record
            $payment_id = uniqid('pay_'); // Generate a unique ID for the payment
            $insertPaymentQuery = "INSERT INTO invoice_payments (id, invoice_id, payment_date, amount, method) VALUES (?, ?, ?, ?, ?)";
            $stmt_insert_pay = $this->conn->prepare($insertPaymentQuery);
            $paymentDate = $paymentData['date'] ?? date('Y-m-d H:i:s');
            $stmt_insert_pay->bind_param("sisds", $payment_id, $invoiceId, $paymentDate, $paymentData['amount'], $paymentData['method']);
            $stmt_insert_pay->execute();
            $stmt_insert_pay->close();

            // 4. Create the corresponding Cash or Bank ledger entry
            $reference = "Payment for Invoice #" . $invoice['invoice_number'];
            if ($paymentData['method'] === 'Cash') {
                $cash_model = new CashRegister($this->conn);
                $cash_model->recordCashEntry(['date' => $paymentDate, 'type' => 'Inflow', 'reference' => $reference, 'amount' => $paymentData['amount']]);
            } else {
                $bank_model = new BankTransaction($this->conn);
                $bank_model->recordTransaction(['date' => $paymentDate, 'type' => 'Inflow', 'method' => $paymentData['method'], 'reference' => $reference, 'amount' => $paymentData['amount']]);
            }

            // 5. Update the invoice status
            $newPaidAmount = $currentPaidAmount + $paymentData['amount'];
            $newStatus = 'Partially Paid';
            if ($newPaidAmount >= $invoice['grand_total']) {
                $newStatus = 'Paid';
            }

            $updateInvoiceQuery = "UPDATE sales_invoices SET status = ? WHERE id = ?";
            $stmt_update_inv = $this->conn->prepare($updateInvoiceQuery);
            $stmt_update_inv->bind_param("si", $newStatus, $invoiceId);
            $stmt_update_inv->execute();
            $stmt_update_inv->close();

            $this->conn->commit();
            return true;

        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e;
        }
    }
    /**
     * Reverses a single payment on an invoice, creates a financial reversal,
     * and updates the invoice status accordingly.
     * @param int $invoiceId The ID of the invoice.
     * @param string $paymentId The unique ID of the payment to reverse.
     * @param string $reason The reason for the reversal.
     * @return bool True on success, false on failure.
     */
    public function reversePayment($invoiceId, $paymentId, $reason) {
        $this->conn->begin_transaction();
        try {
            // 1. Find the specific payment to be reversed.
            $paymentQuery = "SELECT * FROM invoice_payments WHERE id = ? AND invoice_id = ?";
            $stmt_pay = $this->conn->prepare($paymentQuery);
            $stmt_pay->bind_param("si", $paymentId, $invoiceId);
            $stmt_pay->execute();
            $payment = $stmt_pay->get_result()->fetch_assoc();
            $stmt_pay->close();

            if (!$payment) {
                throw new Exception("Payment with ID $paymentId not found on invoice $invoiceId.");
            }

            // 2. Create the financial reversal in the correct ledger.
            $reversal_reference = "Reversal for Invoice #" . $invoiceId . ": " . $reason;
            if ($payment['method'] === 'Cash') {
                $cash_model = new CashRegister($this->conn);
                $cash_model->recordCashEntry(['date' => date('Y-m-d H:i:s'), 'type' => 'Outflow', 'reference' => $reversal_reference, 'amount' => $payment['amount']]);
            } else { // Bank or Shabka
                $bank_model = new BankTransaction($this->conn);
                $bank_model->recordTransaction(['date' => date('Y-m-d H:i:s'), 'type' => 'Outflow', 'method' => $payment['method'], 'reference' => $reversal_reference, 'amount' => $payment['amount']]);
            }

            // 3. Delete the payment record from the invoice.
            $deleteQuery = "DELETE FROM invoice_payments WHERE id = ?";
            $stmt_del = $this->conn->prepare($deleteQuery);
            $stmt_del->bind_param("s", $paymentId);
            $stmt_del->execute();
            $stmt_del->close();

            // 4. Recalculate the invoice's status.
            $invoiceQuery = "SELECT grand_total FROM sales_invoices WHERE id = ?";
            $stmt_inv = $this->conn->prepare($invoiceQuery);
            $stmt_inv->bind_param("i", $invoiceId);
            $stmt_inv->execute();
            $invoice = $stmt_inv->get_result()->fetch_assoc();
            $stmt_inv->close();

            $paymentsQuery = "SELECT SUM(amount) as totalPaid FROM invoice_payments WHERE invoice_id = ?";
            $stmt_paid = $this->conn->prepare($paymentsQuery);
            $stmt_paid->bind_param("i", $invoiceId);
            $stmt_paid->execute();
            $paidResult = $stmt_paid->get_result()->fetch_assoc();
            $stmt_paid->close();

            $currentPaidAmount = $paidResult['totalPaid'] ?? 0;

            $newStatus = 'Unpaid';
            if ($currentPaidAmount > 0) {
                $newStatus = ($currentPaidAmount >= $invoice['grand_total']) ? 'Paid' : 'Partially Paid';
            }

            $updateInvoiceQuery = "UPDATE sales_invoices SET status = ? WHERE id = ?";
            $stmt_update_inv = $this->conn->prepare($updateInvoiceQuery);
            $stmt_update_inv->bind_param("si", $newStatus, $invoiceId);
            $stmt_update_inv->execute();
            $stmt_update_inv->close();

            $this->conn->commit();
            return true;

        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e;
        }
    }
}
?>

================================================================================
// FILE: php-backend\src\Models\User.php
================================================================================

<?php
// FILE: C:\xampp\htdocs\dubai-pos-backend\src\Models\User.php

class User {
    private $conn;
    private $table_name = "users";

    public function __construct($db) {
        $this->conn = $db;
    }


    /**
     * Updates the password for a given user.
     * Corresponds to finding the user, hashing the new password, and saving.
     * @param int $id The user's ID.
     * @param string $new_password The new plain-text password.
     * @return bool True on success, false on failure.
     */
    public function updatePassword($id, $new_password) {
        // Hash the new password securely
        $hashed_password = password_hash($new_password, PASSWORD_DEFAULT);

        $query = "UPDATE " . $this->table_name . " SET password = ? WHERE id = ?";

        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("si", $hashed_password, $id);

        if ($stmt->execute()) {
            return true;
        }
        return false;
    }

    /**
 * Finds a user by their unique ID.
 * Corresponds to `User.findById(id)`
 * @param int $id The user's ID.
 * @return array|null The user data if found, otherwise null.
 */
    public function findUserById($id) {
        $query = "SELECT id, username, email, role FROM " . $this->table_name . " WHERE id = ? LIMIT 1";

        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("i", $id); // 'i' for integer
        $stmt->execute();
        $result = $stmt->get_result();

        if ($result->num_rows > 0) {
            return $result->fetch_assoc();
        }
        return null;
    }
        /**
     * Fetches a paginated and filtered list of users.
     * @param array $options Contains filters (role, username) and pagination.
     * @return array An array containing the list of users and the total count.
     */
    public function getAllUsers($options) {
        $base_query = " FROM " . $this->table_name;
        $where_clause = " WHERE 1=1";
        $params = [];
        $types = "";

        if (!empty($options['role'])) {
            $where_clause .= " AND role = ?";
            $params[] = $options['role'];
            $types .= "s";
        }
        if (!empty($options['username'])) {
            $where_clause .= " AND username LIKE ?";
            $username_search = "%" . $options['username'] . "%";
            $params[] = $username_search;
            $types .= "s";
        }

        // Get total count
        $count_query = "SELECT count(*) as total" . $base_query . $where_clause;
        $stmt_count = $this->conn->prepare($count_query);
        if (!empty($params)) $stmt_count->bind_param($types, ...$params);
        $stmt_count->execute();
        $total = $stmt_count->get_result()->fetch_assoc()['total'];
        $stmt_count->close();

        // Get paginated data
        $data_query = "SELECT id, username, email, role, created_at, updated_at" . $base_query . $where_clause . " ORDER BY created_at DESC LIMIT ? OFFSET ?";
        $params[] = $options['limit'];
        $params[] = $options['offset'];
        $types .= "ii";
        $stmt_data = $this->conn->prepare($data_query);
        $stmt_data->bind_param($types, ...$params);
        $stmt_data->execute();
        $users = $stmt_data->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt_data->close();

        return ['total' => $total, 'users' => $users];
    }

    /**
     * Updates a user's details (username, email, role).
     * @param int $id The ID of the user to update.
     * @param array $data The data to update.
     * @return bool True on success, false otherwise.
     */
    public function updateUser($id, $data) {
        if (empty($data)) return true;

        $query_parts = [];
        $params = [];
        $types = "";
        foreach ($data as $key => $value) {
            $query_parts[] = "`$key` = ?";
            $params[] = $value;
            $types .= "s";
        }
        $params[] = $id;
        $types .= "i";

        $query = "UPDATE " . $this->table_name . " SET " . implode(", ", $query_parts) . " WHERE id = ?";
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param($types, ...$params);
        return $stmt->execute();
    }

    /**
     * Deletes a user from the database.
     * @param int $id The ID of the user to delete.
     * @return bool True if a record was deleted, false otherwise.
     */
    public function deleteUser($id) {
        $query = "DELETE FROM " . $this->table_name . " WHERE id = ?";
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("i", $id);
        if ($stmt->execute()) {
            return $stmt->affected_rows > 0;
        }
        return false;
    }

    /**
     * Finds a user by their email or username.
     * Corresponds to `User.findOne({ $or: [{ username }, { email }] });` 
     * @param string $username
     * @param string $email
     * @return array|null The user data if found, otherwise null.
     */

    public function updateRefreshToken($id, $token) {
        $query = "UPDATE " . $this->table_name . " SET refreshToken = ? WHERE id = ?";
        
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("si", $token, $id);

        if ($stmt->execute()) {
            return true;
        }
        return false;
    }
    public function findUserByEmailOrUsername($username, $email) {
        $query = "SELECT * FROM " . $this->table_name . " WHERE username = ? OR email = ? LIMIT 1";
        
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("ss", $username, $email);
        $stmt->execute();
        $result = $stmt->get_result();

        if ($result->num_rows > 0) {
            return $result->fetch_assoc();
        }
        return null;
    }

    /**
     * Creates a new user in the database.
     * Corresponds to `const newUser = new User(...)` and `await newUser.save()` 
     * @param string $username
     * @param string $email
     * @param string $password The plain-text password to be hashed.
     * @param string $role
     * @return bool True on success, false on failure.
     */
     public function createUser($username, $email, $password, $role = 'admin') {
        // ... (hashing logic remains the same) ...

        $query = "INSERT INTO " . $this->table_name . " (username, email, password, role) VALUES (?, ?, ?, ?)";
        
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("ssss", $username, $email, $hashed_password, $role);
        
        if ($stmt->execute()) {
            // Change this line to return the new ID
            return $stmt->insert_id; 
        }
        // Change this line to return false
        return false;
    }
}
?>

================================================================================
// FILE: php-backend\src\Models\Vendor.php
================================================================================

<?php
// FILE: ...\php-backend\src\Models\Vendor.php

class Vendor {
    private $conn;
    private $table_name = "vendors";

    public function __construct($db) {
        $this->conn = $db;
    }

    /**
     * Creates a new vendor record in the database.
     * @param array $data Associative array of vendor data.
     * @return int|false The ID of the newly created vendor, or false on failure.
     */
    public function createVendor($data) {
        $query = "INSERT INTO " . $this->table_name . " 
                    (name, phone, email, address, opening_balance) 
                  VALUES (?, ?, ?, ?, ?)";

        $stmt = $this->conn->prepare($query);

        $stmt->bind_param("ssssd", 
            $data['name'],
            $data['phone'],
            $data['email'],
            $data['address'],
            $data['opening_balance']
        );

        if ($stmt->execute()) {
            return $stmt->insert_id;
        }

        return false;
    }

    /**
     * Finds a vendor by their unique ID.
     * @param int $id The vendor's ID.
     * @return array|null The vendor data if found, otherwise null.
     */
    public function findVendorById($id) {
        $query = "SELECT * FROM " . $this->table_name . " WHERE id = ? AND status = 'active' LIMIT 1";

        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("i", $id);
        $stmt->execute();
        $result = $stmt->get_result();

        if ($result->num_rows > 0) {
            return $result->fetch_assoc();
        }
        return null;
    }
    /**
 * Fetches a paginated list of vendors with an optional search filter.
 * @param array $options Contains filters (search) and pagination (limit, offset).
 * @return array An array containing the list of vendors and the total count.
 */
public function getAllVendors($options) {
    // Base query to select active vendors
    $base_query = " FROM " . $this->table_name . " WHERE status = 'active'";

    $where_clause = "";
    $params = [];
    $types = "";

    // Dynamically build the WHERE clause for search
    if (!empty($options['search'])) {
        $where_clause .= " AND (name LIKE ? OR email LIKE ?)";
        $search_term = "%" . $options['search'] . "%";
        array_push($params, $search_term, $search_term);
        $types .= "ss";
    }

    // --- First Query: Get the total count for pagination ---
    $count_query = "SELECT count(*) as total" . $base_query . $where_clause;
    $stmt_count = $this->conn->prepare($count_query);
    if ($types) {
        $stmt_count->bind_param($types, ...$params);
    }
    $stmt_count->execute();
    $total = $stmt_count->get_result()->fetch_assoc()['total'];
    $stmt_count->close();

    // --- Second Query: Get the paginated data ---
    $data_query = "SELECT *" . $base_query . $where_clause . " ORDER BY created_at DESC LIMIT ? OFFSET ?";

    // Add limit and offset to parameters
    array_push($params, $options['limit'], $options['offset']);
    $types .= "ii";

    $stmt_data = $this->conn->prepare($data_query);
    $stmt_data->bind_param($types, ...$params);
    $stmt_data->execute();
    $result = $stmt_data->get_result();
    $vendors = $result->fetch_all(MYSQLI_ASSOC);
    $stmt_data->close();

    return ['total' => $total, 'vendors' => $vendors];
}
/**
 * Updates a vendor record with the given data.
 * Dynamically builds the query to only update provided fields.
 * @param int $id The ID of the vendor to update.
 * @param array $data An associative array of flat, snake_case fields to update.
 * @return bool True on success, false on failure.
 */
public function updateVendor($id, $data) {
    if (empty($data)) {
        return true; // Nothing to update, return success.
    }

    $query_parts = [];
    $params = [];
    $types = "";

    // Dynamically build the SET part of the query
    foreach ($data as $key => $value) {
        $query_parts[] = "`$key` = ?";
        $params[] = $value;

        // Determine the type for bind_param
        if (is_int($value)) {
            $types .= "i";
        } elseif (is_double($value) || is_float($value)) {
            $types .= "d";
        } else {
            $types .= "s";
        }
    }

    // Add the vendor ID to the parameters for the WHERE clause
    $params[] = $id;
    $types .= "i";

    $query = "UPDATE " . $this->table_name . " SET " . implode(", ", $query_parts) . " WHERE id = ?";

    $stmt = $this->conn->prepare($query);
    // Use array splatting (...) to pass parameters to bind_param
    $stmt->bind_param($types, ...$params);

    return $stmt->execute();
}
/**
 * Soft deletes a vendor by setting their status to 'deleted'.
 * Corresponds to `Vendor.findByIdAndUpdate(id, { status: 'deleted' })`.
 * @param int $id The ID of the vendor to delete.
 * @return bool True if a record was updated, false otherwise.
 */
public function softDeleteVendor($id) {
    $query = "UPDATE " . $this->table_name . " SET status = 'deleted' WHERE id = ?";

    $stmt = $this->conn->prepare($query);
    $stmt->bind_param("i", $id);

    if ($stmt->execute()) {
        // Check if any row was actually affected/updated
        return $stmt->affected_rows > 0;
    }
    return false;
}
}
?>

================================================================================
// FILE: php-backend\src\Models\VendorTransaction.php
================================================================================

<?php
// FILE: ...\php-backend\src\Models\VendorTransaction.php

class VendorTransaction {
    private $conn;
    private $table_name = "vendor_transactions";

    public function __construct($db) {
        $this->conn = $db;
    }

    public function addTransaction($data) {
        $this->conn->begin_transaction();
        try {
            // 1. Get vendor's opening balance and the last transaction's balance
            $vendor_query = "SELECT opening_balance FROM vendors WHERE id = ?";
            $stmt_v = $this->conn->prepare($vendor_query);
            $stmt_v->bind_param("i", $data['vendor_id']);
            $stmt_v->execute();
            $vendor = $stmt_v->get_result()->fetch_assoc();
            $stmt_v->close();
            if (!$vendor) throw new Exception("Vendor not found.");

            $last_txn_query = "SELECT balance FROM " . $this->table_name . " WHERE vendor_id = ? AND status = 'active' ORDER BY entry_date DESC, id DESC LIMIT 1";
            $stmt_lt = $this->conn->prepare($last_txn_query);
            $stmt_lt->bind_param("i", $data['vendor_id']);
            $stmt_lt->execute();
            $last_txn = $stmt_lt->get_result()->fetch_assoc();
            $stmt_lt->close();

            $last_balance = $last_txn ? $last_txn['balance'] : $vendor['opening_balance'];

            // 2. Calculate new balance
            $new_balance = $data['type'] === 'Purchase' ? $last_balance + $data['amount'] : $last_balance - $data['amount'];

            // 3. If it's a payment, create the ledger entry
            $ledger_entry_id = null;
            $ledger_entry_model = null;
            if ($data['type'] === 'Payment') {
                $reference = "Payment to Vendor: " . ($data['description'] ?? 'N/A');
                if ($data['method'] === 'Cash') {
                    $cash_model = new CashRegister($this->conn);
                    $ledger_entry_id = $cash_model->recordCashEntry(['date' => $data['date'], 'type' => 'Outflow', 'reference' => $reference, 'amount' => $data['amount']]);
                    $ledger_entry_model = 'CashRegister';
                } else { // Bank or Shabka
                    $bank_model = new BankTransaction($this->conn);
                    $ledger_entry_id = $bank_model->recordTransaction(['date' => $data['date'], 'type' => 'Outflow', 'method' => $data['method'], 'reference' => $reference, 'amount' => $data['amount']]);
                    $ledger_entry_model = 'BankTransaction';
                }
                if (!$ledger_entry_id) throw new Exception("Failed to create ledger transaction for payment.");
            }

            // 4. Create the vendor transaction record
            $query = "INSERT INTO " . $this->table_name . " (vendor_id, type, description, amount, balance, entry_date, method, ledger_entry_id, ledger_entry_model) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
            $stmt = $this->conn->prepare($query);
            $entry_date = $data['date'] ?? date('Y-m-d H:i:s');
            $method = $data['type'] === 'Payment' ? $data['method'] : null;
            $stmt->bind_param("issdsssis", $data['vendor_id'], $data['type'], $data['description'], $data['amount'], $new_balance, $entry_date, $method, $ledger_entry_id, $ledger_entry_model);
            $stmt->execute();
            $new_id = $stmt->insert_id;
            $stmt->close();

            if (!$new_id) throw new Exception("Failed to create vendor transaction record.");

            $this->conn->commit();
            return $new_id;
        } catch (Exception $e) {
            $this->conn->rollback();
            throw $e;
        }
    }

    public function findTransactionById($id) {
        $query = "SELECT * FROM " . $this->table_name . " WHERE id = ? LIMIT 1";
        $stmt = $this->conn->prepare($query);
        $stmt->bind_param("i", $id);
        $stmt->execute();
        $result = $stmt->get_result();
        $stmt->close();
        return ($result->num_rows > 0) ? $result->fetch_assoc() : null;
    }

    public function getAllTransactions($options) {
        $base_query = " FROM " . $this->table_name . " WHERE status = 'active'";
        $params = [];
        $types = "";

        if (!empty($options['vendor_id'])) {
            $base_query .= " AND vendor_id = ?";
            $params[] = $options['vendor_id'];
            $types .= "i";
        }
        // Add other filters as needed...

        // Get total count
        $count_query = "SELECT count(*) as total" . $base_query;
        $stmt_count = $this->conn->prepare($count_query);
        if (!empty($params)) $stmt_count->bind_param($types, ...$params);
        $stmt_count->execute();
        $total = $stmt_count->get_result()->fetch_assoc()['total'];
        $stmt_count->close();

        // Get paginated data
        $data_query = "SELECT * " . $base_query . " ORDER BY entry_date DESC, id DESC LIMIT ? OFFSET ?";
        $params[] = $options['limit'];
        $params[] = $options['offset'];
        $types .= "ii";
        $stmt_data = $this->conn->prepare($data_query);
        $stmt_data->bind_param($types, ...$params);
        $stmt_data->execute();
        $transactions = $stmt_data->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt_data->close();

        return ['total' => $total, 'transactions' => $transactions];
    }
    /**
 * Updates the description of a specific vendor transaction.
 * @param int $id The ID of the transaction to update.
 * @param string $description The new description text.
 * @return bool True on success, false otherwise.
 */
public function updateTransaction($id, $description) {
    $query = "UPDATE " . $this->table_name . " SET description = ? WHERE id = ? AND status = 'active'";

    $stmt = $this->conn->prepare($query);
    $stmt->bind_param("si", $description, $id);

    if ($stmt->execute()) {
        return $stmt->affected_rows > 0;
    }
    return false;
}
/**
 * Soft deletes a vendor transaction. If it's a payment, it also creates
 * a reversal entry in the corresponding cash/bank ledger and recalculates
 * all subsequent balances for the vendor.
 * @param int $id The ID of the transaction to delete.
 * @return bool True on success, false on failure.
 */
public function deleteTransaction($id) {
    $this->conn->begin_transaction();
    try {
        $txn_to_delete = $this->findTransactionById($id);
        if (!$txn_to_delete || $txn_to_delete['status'] === 'deleted') {
            $this->conn->rollback(); return false;
        }

        // 1. If it was a Payment, reverse the ledger entry
        if ($txn_to_delete['type'] === 'Payment' && $txn_to_delete['ledger_entry_id']) {
            if ($txn_to_delete['ledger_entry_model'] === 'CashRegister') {
                $cash_model = new CashRegister($this->conn);
                $cash_model->deleteEntry($txn_to_delete['ledger_entry_id']);
            } else {
                $bank_model = new BankTransaction($this->conn);
                $bank_model->deleteTransaction($txn_to_delete['ledger_entry_id']);
            }
        }

        // 2. Soft-delete the vendor transaction
        $delete_query = "UPDATE " . $this->table_name . " SET status = 'deleted' WHERE id = ?";
        $stmt_del = $this->conn->prepare($delete_query);
        $stmt_del->bind_param("i", $id);
        $stmt_del->execute();
        $stmt_del->close();

        // 3. Recalculate subsequent balances for this vendor
        $vendor_id = $txn_to_delete['vendor_id'];
        $vendor_query = "SELECT opening_balance FROM vendors WHERE id = ?";
        $stmt_v = $this->conn->prepare($vendor_query);
        $stmt_v->bind_param("i", $vendor_id);
        $stmt_v->execute();
        $vendor = $stmt_v->get_result()->fetch_assoc();
        $stmt_v->close();

        $prev_query = "SELECT balance FROM " . $this->table_name . " WHERE vendor_id = ? AND (entry_date < ? OR (entry_date = ? AND id < ?)) AND status = 'active' ORDER BY entry_date DESC, id DESC LIMIT 1";
        $stmt_prev = $this->conn->prepare($prev_query);
        $stmt_prev->bind_param("issi", $vendor_id, $txn_to_delete['entry_date'], $txn_to_delete['entry_date'], $id);
        $stmt_prev->execute();
        $result_prev = $stmt_prev->get_result();
        $running_balance = ($result_prev->num_rows > 0) ? $result_prev->fetch_assoc()['balance'] : $vendor['opening_balance'];
        $stmt_prev->close();

        $subsequent_query = "SELECT id, type, amount FROM " . $this->table_name . " WHERE vendor_id = ? AND (entry_date > ? OR (entry_date = ? AND id > ?)) AND status = 'active' ORDER BY entry_date ASC, id ASC";
        $stmt_sub = $this->conn->prepare($subsequent_query);
        $stmt_sub->bind_param("issi", $vendor_id, $txn_to_delete['entry_date'], $txn_to_delete['entry_date'], $id);
        $stmt_sub->execute();
        $subsequent_entries = $stmt_sub->get_result()->fetch_all(MYSQLI_ASSOC);
        $stmt_sub->close();

        $update_balance_query = "UPDATE " . $this->table_name . " SET balance = ? WHERE id = ?";
        $stmt_update = $this->conn->prepare($update_balance_query);
        foreach ($subsequent_entries as $entry) {
            $running_balance = ($entry['type'] === 'Purchase') ? $running_balance + $entry['amount'] : $running_balance - $entry['amount'];
            $stmt_update->bind_param("di", $running_balance, $entry['id']);
            $stmt_update->execute();
        }
        $stmt_update->close();

        $this->conn->commit();
        return true;
    } catch (Exception $e) {
        $this->conn->rollback();
        throw $e;
    }
}
}
?>

================================================================================
// FILE: php-backend\src\Utils\formatters.php
================================================================================

<?php
// FILE: ...\php-backend\src\Utils\formatters.php

/**
 * Formats a flat employee array from the database into the nested structure expected by the frontend.
 * @param array $employee_from_db A flat associative array from a database row.
 * @return array The formatted employee data.
 */
function format_employee_response($employee_from_db) {
    if (!$employee_from_db) {
        return null;
    }

    return [
        'id' => $employee_from_db['id'],
        'name' => $employee_from_db['name'],
        'contact' => [
            'phone' => $employee_from_db['phone'],
            'email' => $employee_from_db['email'],
            'address' => $employee_from_db['address']
        ],
        'role' => $employee_from_db['role'],
        'hireDate' => $employee_from_db['hire_date'], 
        'status' => $employee_from_db['status'],
        'salary' => [
            'gross' => (float)$employee_from_db['salary_gross'],
            'net' => (float)$employee_from_db['salary_net']
        ],
        'salaryBalance' => (float)$employee_from_db['salary_balance'], 
        'createdAt' => $employee_from_db['created_at'], 
        'updatedAt' => $employee_from_db['updated_at']  
    ];
}
/**
 * Formats a flat vendor array from the database into the nested structure expected by the frontend.
 * @param array $vendor_from_db A flat associative array from a database row.
 * @return array The formatted vendor data.
 */
/**
 * Formats a flat vendor array from the database into the nested structure expected by the frontend.
 * @param array $vendor_from_db A flat associative array from a database row.
 * @return array The formatted vendor data.
 */
function format_vendor_response($vendor_from_db) {
    if (!$vendor_from_db) {
        return null;
    }

    return [
        'id' => (int)$vendor_from_db['id'],
        'name' => $vendor_from_db['name'],
        'contact' => [
            'phone' => $vendor_from_db['phone'],
            'email' => $vendor_from_db['email'],
            'address' => $vendor_from_db['address']
        ],
        'openingBalance' => (float)$vendor_from_db['opening_balance'],
        'status' => $vendor_from_db['status'],
        'createdAt' => $vendor_from_db['created_at'],
        'updatedAt' => $vendor_from_db['updated_at']
    ];
}
/**
 * Formats invoice data into the nested structure expected by the frontend.
 * @param array $invoice_db The main invoice data from the DB.
 * @param array $items_db The list of item rows from the DB.
 * @param array $payments_db The list of payment rows from the DB.
 * @return array The fully formatted invoice object.
 */
function format_invoice_response($invoice_db, $items_db = [], $payments_db = []) {
    if (!$invoice_db) {
        return null;
    }

    $items = [];
    foreach ($items_db as $item) {
        $items[] = [
            'description' => $item['description'],
            'quantity' => (int)$item['quantity'],
            'unitPrice' => (float)$item['unit_price'],
            'costPrice' => (float)$item['cost_price'],
            'vatAmount' => (float)$item['vat_amount'],
            'lineTotal' => (float)$item['line_total'],
        ];
    }

    $payments = [];
    foreach ($payments_db as $payment) {
        $payments[] = [
            'id' => $payment['id'],
            'date' => $payment['payment_date'],
            'amount' => (float)$payment['amount'],
            'method' => $payment['method'],
            'account' => $payment['account']
        ];
    }

    return [
        'id' => (int)$invoice_db['id'],
        'invoiceNumber' => $invoice_db['invoice_number'],
        'date' => $invoice_db['invoice_date'],
        'customerName' => $invoice_db['customer_name'],
        'salesmanId' => (int)$invoice_db['salesman_id'],
        'items' => $items,
        'totals' => [
            'subTotal' => (float)$invoice_db['sub_total'],
            'totalVat' => (float)$invoice_db['total_vat'],
            'grandTotal' => (float)$invoice_db['grand_total'],
            'totalCost' => (float)$invoice_db['total_cost'],
            'totalProfit' => (float)$invoice_db['total_profit']
        ],
        'payments' => $payments,
        'status' => $invoice_db['status'],
        'commission' => [
            'eligible' => (bool)$invoice_db['commission_eligible'],
            'rate' => (float)$invoice_db['commission_rate_pct'],
            'total' => (float)$invoice_db['commission_total'],
            'paid' => (float)$invoice_db['commission_paid'],
            'balanceDue' => (float)($invoice_db['commission_total'] - $invoice_db['commission_paid'])
        ],
        'deletedAt' => $invoice_db['deleted_at'],
        'createdAt' => $invoice_db['created_at'],
        'updatedAt' => $invoice_db['updated_at']
    ];
}
/**
 * Formats a cash register entry from the database.
 * @param array $entry_from_db A flat associative array from a database row.
 * @return array The formatted cash entry data.
 */
function format_cash_entry_response($entry_from_db) {
    if (!$entry_from_db) {
        return null;
    }

    return [
        'id' => (int)$entry_from_db['id'],
        'date' => $entry_from_db['entry_date'],
        'type' => $entry_from_db['type'],
        'reference' => $entry_from_db['reference'],
        'amount' => (float)$entry_from_db['amount'],
        'balance' => (float)$entry_from_db['balance'],
        'status' => $entry_from_db['status'],
        'createdAt' => $entry_from_db['created_at'],
        'updatedAt' => $entry_from_db['updated_at']
    ];
}
/**
 * Formats a bank transaction entry from the database.
 * @param array $entry_from_db A flat associative array from a database row.
 * @return array The formatted bank transaction data.
 */
function format_bank_transaction_response($entry_from_db) {
    if (!$entry_from_db) {
        return null;
    }

    return [
        'id' => (int)$entry_from_db['id'],
        'date' => $entry_from_db['entry_date'],
        'type' => $entry_from_db['type'],
        'method' => $entry_from_db['method'],
        'reference' => $entry_from_db['reference'],
        'amount' => (float)$entry_from_db['amount'],
        'balance' => (float)$entry_from_db['balance'],
        'status' => $entry_from_db['status'],
        'createdAt' => $entry_from_db['created_at'],
        'updatedAt' => $entry_from_db['updated_at']
    ];
}
/**
 * Formats an expense record from the database.
 * @param array $expense_from_db A flat associative array from a database row.
 * @return array The formatted expense data.
 */
function format_expense_response($expense_from_db) {
    if (!$expense_from_db) {
        return null;
    }

    return [
        'id' => (int)$expense_from_db['id'],
        'date' => $expense_from_db['entry_date'],
        'category' => $expense_from_db['category'],
        'description' => $expense_from_db['description'],
        'amount' => (float)$expense_from_db['amount'],
        'paymentType' => $expense_from_db['payment_type'],
        'paidTo' => $expense_from_db['paid_to_id'] ? (int)$expense_from_db['paid_to_id'] : null,
        'paidToModel' => $expense_from_db['paid_to_model'],
        'ledgerEntryId' => $expense_from_db['ledger_entry_id'] ? (int)$expense_from_db['ledger_entry_id'] : null,
        'ledgerEntryModel' => $expense_from_db['ledger_entry_model'],
        'status' => $expense_from_db['status'],
        'createdAt' => $expense_from_db['created_at'],
        'updatedAt' => $expense_from_db['updated_at']
    ];
}
/**
 * Formats a vendor transaction record from the database.
 * @param array $txn_from_db A flat associative array from a database row.
 * @return array The formatted vendor transaction data.
 */
function format_vendor_transaction_response($txn_from_db) {
    if (!$txn_from_db) {
        return null;
    }

    return [
        'id' => (int)$txn_from_db['id'],
        'vendorId' => (int)$txn_from_db['vendor_id'],
        'type' => $txn_from_db['type'],
        'description' => $txn_from_db['description'],
        'amount' => (float)$txn_from_db['amount'],
        'balance' => (float)$txn_from_db['balance'],
        'date' => $txn_from_db['entry_date'],
        'method' => $txn_from_db['method'],
        'ledgerEntryId' => $txn_from_db['ledger_entry_id'] ? (int)$txn_from_db['ledger_entry_id'] : null,
        'ledgerEntryModel' => $txn_from_db['ledger_entry_model'],
        'status' => $txn_from_db['status'],
        'createdAt' => $txn_from_db['created_at'],
        'updatedAt' => $txn_from_db['updated_at']
    ];
}
?>

================================================================================
// FILE: server\.env
================================================================================

# PUBLIC_DIR= build
PUBLIC_DIR= public
MONGODB_URI = mongodb+srv://demitirix:optiquest2002@cluster0.zzsp9.mongodb.net/POS?retryWrites=true&w=majority&appName=Cluster0
PORT = 8000

ACCESS_TOKEN_SECRET = secret1122
REFRESH_TOKEN_SECRET = secret0000
RESET_TOKEN_SECRET = passReset1100

ADMIN_EMAIL= riyankam82@gmail.com

# nodemailer config
EMAIL_USER = riyankam82@gmail.com
EMAIL_PASS = yabi djfw fard drvw

COMMISSION_THRESHOLD_PCT = 33
COMMISSION_RATE_PCT = 10

FRONTEND_URL = https://7fcebf7b-b148-4d4d-87ca-196284fae9d0.dev22.app-preview.com

================================================================================
// FILE: server\codeContext.py
================================================================================

import os
import logging


logging.basicConfig(level=logging.INFO, format='%(message)s')


project_dir = os.getcwd()

output_filename = "mern_context.txt"
output_file_path = os.path.join(project_dir, output_filename)



ignore_dirs = {
    "node_modules",      # Contains all npm packages, very large and not source code.
    "build",             # Standard build output directory for React frontends.
    "dist",              # Common distribution folder for compiled code.
    ".git",              # Git version control data.
    "coverage",          # Test coverage reports.
    "__pycache__",       # Python cache files (in case any utility scripts are used).
    "client",           # React frontend code, not needed for backend context.
    "vendor",           # Third-party libraries, often not relevant for context.
    "firebase",         # Firebase configuration and SDK files.
}

# File extensions to ignore.
# This filters out non-source code files.
ignore_file_extensions = {
    # Image and media files
    ".png", ".jpg", ".jpeg", ".gif", ".svg", ".ico", ".webp",
    ".mp4", ".mov", ".wmv", ".avi", ".pem",
    # Font files
    ".woff", ".woff2", ".ttf", ".eot",
    # Document files
    ".pdf", ".doc", ".docx",
    # Log and lock files
    ".log",
    "yarn.lock", "package-lock.json",
    ".zip", ".tar", ".gz",
}

# Specific filenames to ignore.
ignore_specific_filenames = {
    output_filename,      # Exclude the script's own output file.
    ".gitignore",         # Git ignore rules are not primary source code.
    ".gitattributes",
}

# --- Core Logic ---

def should_ignore(path, is_dir):
    """Checks if a given file or directory should be ignored."""
    base_name = os.path.basename(path)

    if is_dir:
        return base_name in ignore_dirs

    # Check by specific filename first, then by extension
    if base_name in ignore_specific_filenames:
        return True
    
    # Check if any part of the name ends with an ignored extension
    for ext in ignore_file_extensions:
        if base_name.endswith(ext):
            return True
            
    return False


def process_directory(root_path):
    """
    Recursively scans a directory, reads the content of relevant files,
    and appends it to the output file.
    """
    logging.info(f"Scanning directory: {root_path}")
    try:
        # Open the output file once and pass it down through the recursion
        with open(output_file_path, "a", encoding="utf-8") as out_file:
            # os.walk is efficient for traversing directory trees
            for dirpath, dirnames, filenames in os.walk(root_path, topdown=True):
                # Modify dirnames in-place to prevent os.walk from descending into ignored directories
                dirnames[:] = [d for d in dirnames if not should_ignore(os.path.join(dirpath, d), is_dir=True)]

                for filename in filenames:
                    file_path = os.path.join(dirpath, filename)
                    
                    if should_ignore(file_path, is_dir=False):
                        # This log is optional if you want cleaner output
                        # logging.info(f"  - Ignoring file: {os.path.relpath(file_path, project_dir)}")
                        continue

                    relative_path = os.path.relpath(file_path, project_dir)
                    logging.info(f"  + Processing file: {relative_path}")

                    try:
                        with open(file_path, "r", encoding="utf-8", errors="ignore") as in_file:
                            content = in_file.read()
                            
                        # Write a clear header for each file's content
                        out_file.write("=" * 80 + "\n")
                        out_file.write(f"// FILE: {relative_path}\n")
                        out_file.write("=" * 80 + "\n\n")
                        out_file.write(content)
                        out_file.write("\n\n")

                    except Exception as e:
                        logging.error(f"  ! Error reading file {relative_path}: {e}")

    except Exception as e:
        logging.error(f"Failed to process directory {root_path}: {e}")


def main():
    """Main function to orchestrate the script."""
    # Ensure any previous output file is removed before starting.
    if os.path.exists(output_file_path):
        os.remove(output_file_path)
        logging.info(f"Removed existing output file: {output_filename}")

    logging.info("-" * 50)
    logging.info(f"Starting to scan project in: {project_dir}")
    logging.info(f"Output will be written to: {output_filename}")
    logging.info("-" * 50)

    process_directory(project_dir)

    logging.info("-" * 50)
    logging.info("Finished processing project context.")
    logging.info("-" * 50)


if __name__ == "__main__":
    main()


================================================================================
// FILE: server\index.js
================================================================================

import connectDB from './src/db/index.js'
import dotenv from 'dotenv';
import { app } from './src/app.js';

dotenv.config({
  path: '.env'
});

const port = 5000;

connectDB().then(
  app.listen( port , () => {
    console.log(`Example app listening on port ${ port}`)
  })
).catch((error)=>{
  console.error("MONGO Connection ERROR", error);
});




================================================================================
// FILE: server\package.json
================================================================================

{
  "name": "server",
  "version": "1.0.0",
  "description": "POS",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon -r dotenv/config --experimental-json-modules index.js"
  },
  "keywords": [
    "node"
  ],
  "author": "M.HasanIrfan",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "bcryptjs": "^3.0.2",
    "celebrate": "^15.0.3",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.5.3",
    "node": "^23.5.0",
    "nodemailer": "^6.10.1"
  },
  "devDependencies": {
    "nodemon": "^3.1.4"
  }
}


================================================================================
// FILE: server\src\app.js
================================================================================

import express from 'express';
import cookieParser from 'cookie-parser';
import cors from 'cors';
import dotenv from 'dotenv';
import bodyParser from 'body-parser';
import { notFound } from './middlewares/notFound.js';
import { errorHandler } from './middlewares/errorHandler.js';
import { jwtVerify } from './middlewares/authChecker.js';
import { attachAuditContext } from './middlewares/attachAuditContext.js';


dotenv.config({
  path: '.env'
});

export const app = express();

const corsOptions = {
  origin: ["http://localhost:5173", process.env.FRONTEND_URL].filter(Boolean),
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
  credentials: true,
};

app.use(cors(corsOptions));

// Handling preflight requests
app.options("*", cors(corsOptions)); // Enable pre-flight across-the-board with specific options

// Your routes and server setup
app.get("/", (req, res) => {
  res.send("CORS is enabled for all origins!");
});

app.use(bodyParser.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.json({limit: '16kb'}));
app.use(express.static(process.env.PUBLIC_DIR));
app.use(cookieParser());

//routes imports
import authRouter from './routes/authRoutes.js';
import userRouter from './routes/userRoutes.js';
import employeeRouter from './routes/employeeRoutes.js';
import invoiceRouter from './routes/invoiceRoutes.js';
import vendorRouter from './routes/vendorRoutes.js';
import vendorTransactionRouter from './routes/vendorTransactionRoutes.js';
import cashRouter from './routes/cashRoutes.js';
import bankRouter from './routes/bankRoutes.js';
import expenseRouter from './routes/expenseRoutes.js';
import reportRouter from './routes/reportRoutes.js';
import auditRouter from './routes/auditRoutes.js';
import dashboardRoutes from './routes/dashboardRoutes.js';
import salaryRouter from './routes/salaryRoutes.js';

//routes declaration
app.use('/api/v1', authRouter);

// Authentication middleware - all routes below require authentication
app.use(jwtVerify);
app.use(attachAuditContext);

app.use('/api/v1/employees', employeeRouter);
app.use('/api/v1/invoices', invoiceRouter);
app.use('/api/v1/cash', cashRouter);     // Needed for invoice payment processing
app.use('/api/v1/bank', bankRouter);     // Needed for invoice payment processing
app.use('/api/v1/vendors', vendorRouter);
app.use('/api/v1/expenses', expenseRouter);
app.use('/api/v1/reports', reportRouter);
app.use('/api/v1/audit', auditRouter);
app.use('/api/v1/salary', salaryRouter);
app.use('/api/dashboard', dashboardRoutes);

app.use(notFound);
app.use(errorHandler);



================================================================================
// FILE: server\src\constants.js
================================================================================

export const DB_NAME = 'POS';

================================================================================
// FILE: server\src\controllers\advanceController.js
================================================================================

// src/controllers/advanceController.js
import { asyncHandler } from '../utils/asyncHandler.js';
import * as advanceService from '../services/advanceService.js';

/**
 * POST /api/v1/advances
 * Body: { invoiceId, salesmanId, amount, note?, paymentMethod?, account? }
 */
export const recordAdvance = asyncHandler(async (req, res) => {
  const { invoiceId, salesmanId, amount, note, paymentMethod, account } = req.body;
  const advance = await advanceService.recordAdvance(
    { invoiceId, salesmanId, amount, note, paymentMethod, account },
    req.audit
  );
  res.status(201).json({ success: true, advance });
});

/**
 * GET /api/v1/advances
 * Query: page, limit, salesmanId, from, to
 */
export const getAllAdvances = asyncHandler(async (req, res) => {
  const {
    page = 1,
    limit = 10,
    salesmanId,
    recovered,
    from,
    to,
    search = ''
  } = req.query;

  const result = await advanceService.getAllAdvances({
    filters: { salesmanId, recovered },
    dateRange: { from, to },
    search,
    page: Number(page),
    limit: Number(limit)
  }, req.audit);

  res.status(200).json({ success: true, ...result });
});

/**
 * GET /api/v1/advances/:id
 */
export const getAdvanceById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const advance = await advanceService.getAdvanceById(id, req.audit);
  res.status(200).json({ success: true, advance });
});

/**
 * PUT /api/v1/advances/:id
 * Body: { note?, recovered? }
 */
export const updateAdvance = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const updateData = req.body;
  const advance = await advanceService.updateAdvance(id, updateData, req.audit);
  res.status(200).json({ success: true, advance });
});

/**
 * DELETE /api/v1/advances/:id
 */
export const deleteAdvance = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const advance = await advanceService.deleteAdvance(id, req.audit);
  res.status(200).json({ success: true, advance });
});


================================================================================
// FILE: server\src\controllers\auditController.js
================================================================================

import { asyncHandler } from '../utils/asyncHandler.js';
import * as auditService from '../services/auditService.js';

/**
 * GET /api/v1/audit
 * Query: page, limit, actorId, actorModel, action, collectionName, documentId, from, to
 */
export const getAuditLogs = asyncHandler(async (req, res) => {
  const {
    page           = 1,
    limit          = 10,
    actorId,
    actorModel,
    action,
    collectionName,
    documentId,
    from,
    to
  } = req.query;

  const result = await auditService.getAuditLogs({
    filters: {
      actorId,
      actorModel,
      action,
      collectionName,
      documentId
    },
    from,
    to,
    page:  Number(page),
    limit: Number(limit)
  });

  res.status(200).json({ success: true, ...result });
});

/**
 * GET /api/v1/audit/:id
 */
export const getAuditLogById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const log = await auditService.getAuditLogById(id);
  res.status(200).json({ success: true, log });
});


================================================================================
// FILE: server\src\controllers\authController.js
================================================================================

import { asyncHandler } from "../utils/asyncHandler.js";
import User from "../models/user.model.js";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import nodemailer from "nodemailer";

const generateAccessandRefreshToken = (userID) => {
  try {
    const accessToken = jwt.sign(
      { _id: userID },
      process.env.ACCESS_TOKEN_SECRET,
      { expiresIn: "1d" }
    );

    const refreshToken = jwt.sign(
      { _id: userID },
      process.env.REFRESH_TOKEN_SECRET,
      { expiresIn: "10d" }
    );

    return { accessToken, refreshToken };
  } catch (error) {
    
    throw new Error(
      error.message || "Something went wrong during token generation"
    );
  }
};

///////////////////////////////////////////////////////////////////////////////////////

export const login = asyncHandler(async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    const matchPass = await bcrypt.compare(password, user.password);
    if (!matchPass) {
      return res.status(404).json({
        success: false,
        message: "Invalid password",
      });
    }

    const { accessToken, refreshToken } = generateAccessandRefreshToken(
      user._id
    );

    user.refreshToken = refreshToken;

    const loggedInUser = await user.save();

    const options = {
      httpOnly: true,
      secure: false,
      sameSite: "lax",
    };

    return res
      .status(201)
      .cookie("refreshToken", refreshToken, options)
      .cookie("accessToken", accessToken, options)
      .json({
        success: true,
        message: "Logged in successfully",
        user: {
          id: loggedInUser._id,
          username: loggedInUser.username,
          email: loggedInUser.email,
          role: loggedInUser.role,
          token: accessToken
        },
      });
  } catch (error) {
    console.error("Login error:", error);
    return res
      .status(500)
      .json({ success: false, message: "Something went wrong" });
  }
});

///////////////////////////////////////////////////////////////////////////////////////

export const Signup = asyncHandler(async (req, res) => {
  try {
    const { username, email, password } = req.body;

    // Validate inputs
    if (!username || !email || !password) {
      return res
        .status(400)
        .json({ success: false, message: "Please enter all the fields" });
    }

    if (password.length < 6) {
      return res.status(400).json({
        success: false,
        message: "Please enter a password of at least 6 characters",
      });
    }
    // Check if the email already exists
    const user = await User.findOne({ $or: [{ username }, { email }] });
    if (user) {
      return res
        .status(409)
        .json({ success: false, message: "User or Email already exists" });
    }

    // Hash the password and save the user
    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new User({ username, email, password: hashedPassword });

    if (newUser.email === process.env.ADMIN_EMAIL) {
      newUser.role = "superAdmin";
    }

    await newUser.save();

    return res.status(201).json({
      id: newUser._id,
      user: newUser.username,
      role: newUser.role,
      success: true,
      message: "User registered successfully",
    });
  } catch (error) {
    console.error(error);
    return res
      .status(500)
      .json({ success: false, message: error.message });
  }
});

////////////////////////////////////////////////////////////////////////////////////////

export const logout = asyncHandler(async (req, res) => {
  try {
    const user = req.user;

    await User.findByIdAndUpdate(
      user._id,
      {
        $unset: {
          refreshToken: 1, // this removes the field from document
        },
      },
      {
        new: true,
      }
    );

    const options = {
      httpOnly: true,
      secure: false,
      sameSite: "lax"
    };

    return res
      .status(200)
      .clearCookie("accessToken", options)
      .clearCookie("refreshToken", options)
      .json({
        success: true,
        message: "Logged out successfully",
      });
  } catch (error) {
    return res
      .status(500)
      .json({ success: false, message: "Something went wrong" });
  }
});

////////////////////////////////////////////////////////////////////////////////////////

export const refreshAccessToken = asyncHandler(async (req, res) => {
  const incomingRefreshToken =
    req.cookies.refreshToken || req.body.refreshToken;

  if (!incomingRefreshToken) {
    return res.status(401).json({
      success: false,
      message: "Unauthorized request  no token provided"
    });
  }

  try {
    // Verify the token signature & expiry
    const decoded = jwt.verify(
      incomingRefreshToken,
      process.env.REFRESH_TOKEN_SECRET
    );

    // Find the user
    const user = await User.findById(decoded._id);
    if (!user) {
      return res.status(401).json({
        success: false,
        message: "Invalid refresh token  user not found"
      });
    }

    // Make sure it matches what we have stored
    if (incomingRefreshToken !== user.refreshToken) {
      return res.status(401).json({
        success: false,
        message: "Refresh token expired or already used"
      });
    }

    // Generate a new access token (we're not rotating the refresh token here)
    const { accessToken } = generateAccessandRefreshToken(user._id);

    const cookieOpts = {
      httpOnly: true,
      secure: false,
      sameSite: "lax",
      maxAge: 24 * 60 * 60 * 1000 // 1 day
    };

    // Send back both cookies and JSON
    return res
      .status(200)
      .cookie("accessToken", accessToken, cookieOpts)
      .cookie("refreshToken", incomingRefreshToken, cookieOpts)
      .json({
        success: true,
        message: "Access token refreshed",
        data: {
          accessToken,
          refreshToken: incomingRefreshToken
        }
      });

  } catch (error) {
    // Token verification failed (invalid or expired)
    return res.status(401).json({
      success: false,
      message: error.message || "Invalid or expired refresh token"
    });
  }
});

////////////////////////////////////////////////////////////////////////////////////////

export const resetPassword = asyncHandler(async (req, res) => {
  const { email } = req.body;

  try {
    const user = await User.findOne({ email }); // Corrected find method

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "Email does not exist",
      });
    }

    const resetToken = jwt.sign(
      { _id: user._id },
      process.env.RESET_TOKEN_SECRET,
      { expiresIn: "10m" }
    );

    let mailTransporter = nodemailer.createTransport({
      service: "gmail",
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
      },
    });

    let mailDetails = {
      from: process.env.EMAIL_USER,
      to: user.email,
      subject: "Password Reset Link",
      text: `http://localhost:5173/update-password/${resetToken}`,
    };

    mailTransporter.sendMail(mailDetails, (err, data) => {
      if (err) {
        // console.error("Error Occurred:", err);
        return res.status(500).json({
          success: false,
          message: "Failed to send email. Please try again later." + err,
        });
      } else {
        // console.log("Email sent successfully");
        return res.status(200).json({
          success: true,
          message: "Password reset link has been sent to your email.",
        });
      }
    });
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({
      success: false,
      message: "Internal Server Error",
    });
  }
});

////////////////////////////////////////////////////////////////////////////////////////

export const updatePassword = asyncHandler(async (req, res) => {
  const { resetToken } = req.params;
  const { password } = req.body;

  if (!resetToken) {
    return res.status(400).json({
      success: false,
      message: "Invalid token",
    });
  }

  if (!password) {
    return res.status(400).json({
      success: false,
      message: "Please enter a password",
    });
  }

  try {
    // Verify the token
    let decodedToken;
    try {
      decodedToken = jwt.verify(resetToken, process.env.RESET_TOKEN_SECRET);
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({
          success: false,
          message: "Reset link has expired. Please request a new one.",
        });
      }
      return res.status(401).json({
        success: false,
        message: "Invalid reset link. Please request a new one.",
      });
    }

    if (!decodedToken || !decodedToken._id) {
      return res.status(401).json({
        success: false,
        message: "Invalid reset link. Please request a new one.",
      });
    }

    // Find the user
    const user = await User.findById(decodedToken._id);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found. Please request a new reset link.",
      });
    }

    // Validate password
    if (password.length < 6) {
      return res.status(400).json({
        success: false,
        message: "Password must be at least 6 characters long",
      });
    }

    // Update password
    const hashedPassword = await bcrypt.hash(password, 10);
    user.password = hashedPassword;
    await user.save();

    return res.status(200).json({
      success: true,
      message: "Password updated successfully. Please login with your new password.",
    });
  } catch (error) {
    console.error('Password reset error:', error);
    return res.status(500).json({
      success: false,
      message: "An error occurred while updating your password. Please try again.",
    });
  }
});

////////////////////////////////////////////////////////////////////////////////////////

export const changePassword = asyncHandler(async (req, res) => {
  const { password } = req.body;
  const userId = req.user._id; // From jwtVerify middleware

  if (!password) {
    return res.status(400).json({
      success: false,
      message: "Please enter a new password",
    });
  }

  if (password.length < 6) {
    return res.status(400).json({
      success: false,
      message: "Password must be at least 6 characters long",
    });
  }

  try {
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    user.password = hashedPassword;
    await user.save();

    return res.status(200).json({
      success: true,
      message: "Password changed successfully",
    });
  } catch (error) {
    return res.status(500).json({
      success: false,
      message: "Failed to change password",
    });
  }
});



================================================================================
// FILE: server\src\controllers\bankController.js
================================================================================

import { asyncHandler } from '../utils/asyncHandler.js';
import * as bankService from '../services/bankService.js';

/**
 * POST /api/v1/bank
 * Body: { date?, type, method, reference?, account, amount }
 */
export const recordBankTransaction = asyncHandler(async (req, res) => {
  const { date, type, method, reference, account, amount } = req.body;
  const transaction = await bankService.recordBankTransaction({
    date,
    type,
    method,
    reference,
    account,
    amount
  }, req.audit);
  res.status(201).json({ success: true, transaction });
});

/**
 * GET /api/v1/bank
 * Query: page, limit, account, method, from, to, includeDeleted
 */
export const getAllBankTransactions = asyncHandler(async (req, res) => {
  const {
    page    = 1,
    limit   = 10,
    account,
    method,
    from,
    to,
    includeDeleted = false
  } = req.query;

  const result = await bankService.getAllBankTransactions({
    account,
    method,
    from,
    to,
    page:  Number(page),
    limit: Number(limit),
    includeDeleted: includeDeleted === 'true'
  }, req.audit);

  res.status(200).json({ success: true, ...result });
});

/**
 * GET /api/v1/bank/:id
 * Query: includeDeleted
 */
export const getBankTransactionById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { includeDeleted = false } = req.query;
  const txn = await bankService.getBankTransactionById(id, includeDeleted === 'true');
  res.status(200).json({ success: true, transaction: txn });
});

/**
 * PUT /api/v1/bank/:id
 * Body: { reference }
 */
export const updateBankTransaction = asyncHandler(async (req, res) => {
  const { id }        = req.params;
  const { reference } = req.body;
  const txn = await bankService.updateBankTransaction(id, { reference }, req.audit);
  res.status(200).json({ success: true, transaction: txn });
});

/**
 * DELETE /api/v1/bank-transactions/:id
 */
export const deleteBankTransaction = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const txn = await bankService.deleteBankTransaction(id, req.audit);
  res.status(200).json({ success: true, txn });
});


================================================================================
// FILE: server\src\controllers\cashController.js
================================================================================

import { asyncHandler } from '../utils/asyncHandler.js';
import * as cashService from '../services/cashService.js';

/**
 * POST /api/v1/cash
 * Body: { date?, type, reference?, amount }
 */
export const recordCashEntry = asyncHandler(async (req, res) => {
  const { date, type, reference, amount } = req.body;
  const entry = await cashService.recordCashEntry({ 
    date, 
    type, 
    reference, 
    amount 
  }, req.audit);
  res.status(201).json({ success: true, entry });
});

/**
 * GET /api/v1/cash
 * Query: page, limit, type, from, to, includeDeleted
 */
export const getAllCashEntries = asyncHandler(async (req, res) => {
  const {
    page = 1,
    limit = 10,
    type,
    from,
    to,
    includeDeleted = false
  } = req.query;

  const result = await cashService.getAllCashEntries({
    from,
    to,
    type,
    page: Number(page),
    limit: Number(limit),
    includeDeleted: includeDeleted === 'true'
  });

  res.status(200).json({ success: true, ...result });
});

/**
 * GET /api/v1/cash/:id
 * Query: includeDeleted
 */
export const getCashEntryById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { includeDeleted = false } = req.query;
  const entry = await cashService.getCashEntryById(id, includeDeleted === 'true');
  res.status(200).json({ success: true, entry });
});

/**
 * PUT /api/v1/cash/:id
 * Body: { reference }
 */
export const updateCashEntry = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { reference } = req.body;
  const entry = await cashService.updateCashEntry(id, { reference }, req.audit);
  res.status(200).json({ success: true, entry });
});

/**
 * DELETE /api/v1/cash/:id
 * Soft deletes the cash entry
 */
export const deleteCashEntry = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const entry = await cashService.deleteCashEntry(id, req.audit);
  res.status(200).json({ success: true, entry, message: 'Cash entry soft deleted successfully' });
});

/**
 * POST /api/v1/cash/:id/restore
 * Restores a soft-deleted cash entry
 */
export const restoreCashEntry = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const entry = await cashService.restoreCashEntry(id, req.audit);
  res.status(200).json({ success: true, entry, message: 'Cash entry restored successfully' });
});


================================================================================
// FILE: server\src\controllers\dashboardController.js
================================================================================

import { getDashboardMetrics, getDashboardMetricsForDateRange } from '../services/dashboardService.js';
import { validateDateRange } from '../utils/validators.js';

// Get all dashboard metrics
export async function getAllMetrics(req, res) {
  try {
    const metrics = await getDashboardMetrics();
    res.json(metrics);
  } catch (error) {
    console.error('Error in getAllMetrics controller:', error);
    res.status(500).json({
      message: 'Failed to fetch dashboard metrics',
      error: error.message
    });
  }
}

// Get metrics for a specific date range
export async function getMetricsForDateRange(req, res) {
  try {
    const { startDate, endDate } = req.query;

    // Validate date range
    if (!startDate || !endDate) {
      return res.status(400).json({
        message: 'Both startDate and endDate are required'
      });
    }

    // Validate date format and range
    const validationError = validateDateRange(startDate, endDate);
    if (validationError) {
      return res.status(400).json({
        message: validationError
      });
    }

    const metrics = await getDashboardMetricsForDateRange(startDate, endDate);
    res.json(metrics);
  } catch (error) {
    console.error('Error in getMetricsForDateRange controller:', error);
    res.status(500).json({
      message: 'Failed to fetch dashboard metrics for date range',
      error: error.message
    });
  }
} 

================================================================================
// FILE: server\src\controllers\employeeController.js
================================================================================

// src/controllers/employeeController.js
import { asyncHandler } from '../utils/asyncHandler.js';
import * as employeeService from '../services/employeeService.js';

/**
 * POST /api/v1/employees
 * Body: { employeeData }
 */
export const createEmployee = asyncHandler(async (req, res) => {
  const { employeeData } = req.body;
  const employee = await employeeService.addEmployee(employeeData, req.audit);
  res.status(201).json({ success: true, employee });
});

/**
 * GET /api/v1/employees
 * Query: page, limit, role, status, search
 */
export const getAllEmployees = asyncHandler(async (req, res) => {
  const {
    page   = 1,
    limit  = 10,
    role,
    search = ''
  } = req.query;

  const result = await employeeService.getAllEmployees({
    filters: { role },
    search,
    page:  Number(page),
    limit: Number(limit)
  }, req.audit);

  res.status(200).json({ success: true, ...result });
});

/**
 * GET /api/v1/employees/:id
 */
export const getEmployeeById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const employee = await employeeService.getEmployeeById(id);
  res.status(200).json({ success: true, employee });
});

/**
 * PUT /api/v1/employees/:id
 * Body: any of { name, contact, role, hireDate, salary }
 */
export const updateEmployee = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const updateData = req.body;
  const employee = await employeeService.updateEmployee(id, updateData, req.audit);
  res.status(200).json({ success: true, employee });
});

/**
 * DELETE /api/v1/employees/:id?hardDelete=true
 */
export const deleteEmployee = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const employee = await employeeService.deleteEmployee(id, req.audit);
  res.status(200).json({ success: true, message: 'Employee deleted successfully' });
});


================================================================================
// FILE: server\src\controllers\expenseController.js
================================================================================

import { asyncHandler } from '../utils/asyncHandler.js';
import * as expenseService from '../services/expenseService.js';

/**
 * POST /api/v1/expenses
 * Body: { date?, category, description?, amount, paymentType, paidTo?, paidToModel?, linkedTo?, linkedToModel? }
 */
export const recordExpense = asyncHandler(async (req, res) => {
  const expense = await expenseService.recordExpense(req.body, req.audit);
  res.status(201).json({ success: true, expense });
});

/**
 * GET /api/v1/expenses
 * Query: page, limit, category, paymentType, paidToModel, paidTo, search, from, to, sortBy, sortOrder
 */
export const getAllExpenses = asyncHandler(async (req, res) => {
  const {
    page = 1,
    limit = 10,
    category,
    paymentType,
    paidToModel,
    paidTo,
    search,
    from,
    to,
    sortBy = 'date',
    sortOrder = 'desc'
  } = req.query;

  const result = await expenseService.getAllExpenses({
    category,
    paymentType,
    paidToModel,
    paidTo,
    search,
    from,
    to,
    page: Number(page),
    limit: Number(limit),
    sortBy,
    sortOrder
  }, req.audit);

  res.status(200).json({ success: true, ...result });
});

/**
 * GET /api/v1/expenses/:id
 */
export const getExpenseById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const expense = await expenseService.getExpenseById(id, req.audit);
  res.status(200).json({ success: true, expense });
});

/**
 * PUT /api/v1/expenses/:id
 * Body: { date?, category?, description?, amount?, paymentType?, paidTo?, paidToModel?, linkedTo?, linkedToModel? }
 */
export const updateExpense = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const updateData = req.body;
  const expense = await expenseService.updateExpense(id, updateData, req.audit);
  res.status(200).json({ success: true, expense });
});

/**
 * DELETE /api/v1/expenses/:id
 */
export const deleteExpense = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const expense = await expenseService.deleteExpense(id, req.audit);
  res.status(200).json({ success: true, expense });
});


================================================================================
// FILE: server\src\controllers\invoiceController.js
================================================================================

// src/controllers/invoiceController.js
import { asyncHandler } from '../utils/asyncHandler.js';
import * as invoiceService from '../services/invoiceService.js';

/**
 * POST /api/v1/invoices
 * Body: { invoiceNumber, date?, customerName, salesmanId, items: [], status? }
 */
export const createInvoice = asyncHandler(async (req, res) => {
  const invoiceData = req.body;
  const invoice = await invoiceService.createInvoice(invoiceData, req.audit);
  res.status(201).json({ success: true, invoice });
});

/**
 * GET /api/v1/invoices
 * Query: page, limit, status, salesmanId, from, to, sort, customerName
 */
export const getAllInvoices = asyncHandler(async (req, res) => {
  const {
    page = 1,
    limit = 10,
    status,
    salesmanId,
    from,
    to,
    sort = '-createdAt',
    customerName
  } = req.query;

  const result = await invoiceService.getAllInvoices({
    filters: { status, salesmanId, customerName },
    from,
    to,
    page: Number(page),
    limit: Number(limit),
    sort
  });

  res.status(200).json({ success: true, ...result });
});

/**
 * GET /api/v1/invoices/:id
 */
export const getInvoiceById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const invoice = await invoiceService.getInvoiceById(id);
  res.status(200).json({ success: true, invoice });
});

/**
 * PUT /api/v1/invoices/:id
 * Body: any of { items, status, customerName, date }
 */
export const updateInvoice = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const updateData = req.body;
  const invoice = await invoiceService.updateInvoice(id, updateData, req.audit);
  res.status(200).json({ success: true, invoice });
});

/**
 * DELETE /api/v1/invoices/:id
 */
export const deleteInvoice = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const invoice = await invoiceService.deleteInvoice(id, req.audit);
  res.status(200).json({ success: true, invoice });
});

/**
 * POST /api/v1/invoices/:id/payments
 * Body: { amount, method, account, date }
 */
export const addPayment = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { amount, method, account, date } = req.body;
  const invoice = await invoiceService.addPayment(
    id,
    { amount, method, account, date },
    req.audit
  );
  res.status(200).json({ success: true, invoice });
});

/**
 * POST /api/v1/invoices/:id/payments/:paymentId/reverse
 * Body: { reason }
 */
export const reversePayment = asyncHandler(async (req, res) => {
  const { id, paymentId } = req.params;
  const { reason } = req.body;
  
  if (!reason) {
    return res.status(400).json({ 
      success: false, 
      message: 'Reason for reversal is required' 
    });
  }
  
  const invoice = await invoiceService.reversePayment(
    id,
    paymentId,
    reason,
    req.audit
  );
  res.status(200).json({ success: true, invoice });
});

/**
 * POST /api/v1/invoices/:id/commission
 * Body: { amount, method, account, date, note }
 */
export const updateCommission = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { amount, method, account, date, note } = req.body;
  
  const invoice = await invoiceService.updateCommissionPayment(
    id,
    { amount, method, account, date, note },
    req.audit
  );
  
  res.status(200).json({ success: true, invoice });
});


================================================================================
// FILE: server\src\controllers\payrollController.js
================================================================================

import { asyncHandler } from '../utils/asyncHandler.js';
import * as payrollService from '../services/payrollService.js';

/**
 * POST /api/v1/payroll
 * Body: { month, year, paymentDate? }
 */
export const runPayroll = asyncHandler(async (req, res) => {
  const { month, year, paymentDate } = req.body;

  if (!month || !year) {
    return res.status(400).json({
      success: false,
      message: "Month and year are required"
    });
  }

  const payroll = await payrollService.runPayroll({ month, year, paymentDate }, req.audit);
  res.status(200).json({ success: true, payroll });
});


================================================================================
// FILE: server\src\controllers\reportController.js
================================================================================

import { asyncHandler } from '../utils/asyncHandler.js';
import * as reportService from '../services/reportService.js';

/**
 * GET /api/v1/reports/monthly
 * Query: from, to (ISO date)
 */
export const getMonthlySummary = asyncHandler(async (req, res) => {
  const { from, to } = req.query;

  if (!from || !to) {
    return res.status(400).json({
      success: false,
      message: "Missing 'from' or 'to' query parameters"
    });
  }

  const summary = await reportService.getMonthlySummary({ from, to }, req.audit);
  res.status(200).json({ success: true, summary });
});


================================================================================
// FILE: server\src\controllers\salaryController.js
================================================================================

import { asyncHandler } from '../utils/asyncHandler.js';
import * as salaryService from '../services/salaryService.js';

/**
 * POST /api/v1/salary/payments
 * Body: { employeeId, type, amount, description?, paymentMethod, date? }
 */
export const addSalaryPayment = asyncHandler(async (req, res) => {
  const payment = await salaryService.addSalaryPayment(req.body, req.audit);
  res.status(201).json({ success: true, payment });
});

/**
 * GET /api/v1/salary/employees/:employeeId/history
 * Query: from, to, type
 */
export const getEmployeeSalaryHistory = asyncHandler(async (req, res) => {
  const { employeeId } = req.params;
  const { from, to, type } = req.query;

  const payments = await salaryService.getEmployeeSalaryHistory(employeeId, {
    from,
    to,
    type
  });

  res.status(200).json({ success: true, payments });
});

/**
 * GET /api/v1/salary/employees/:employeeId/summary
 */
export const getEmployeeSalarySummary = asyncHandler(async (req, res) => {
  const { employeeId } = req.params;
  const summary = await salaryService.getEmployeeSalarySummary(employeeId);
  res.status(200).json({ success: true, summary });
});

/**
 * PUT /api/v1/salary/employees/:employeeId
 * Body: { gross, net }
 */
export const updateEmployeeSalary = asyncHandler(async (req, res) => {
  const { employeeId } = req.params;
  const { gross, net } = req.body;
  
  const employee = await salaryService.updateEmployeeSalary(
    employeeId,
    { gross, net },
    req.audit
  );

  res.status(200).json({ success: true, employee });
}); 

================================================================================
// FILE: server\src\controllers\userController.js
================================================================================

import { asyncHandler } from "../utils/asyncHandler.js";
import * as userService from '../services/userService.js';

/**
 * GET /api/v1/users
 * Query parameters:
 * - page: Page number (default: 1)
 * - limit: Items per page (default: 10)
 * - role: Optional role filter
 * - username: Optional username search
 */
export const getAllUsers = asyncHandler(async (req, res) => {
  const {
    page = 1,
    limit = 10,
    role,
    username
  } = req.query;

  // Validate numeric parameters
  const pageNum = Math.max(1, Number(page));
  const limitNum = Math.min(100, Math.max(1, Number(limit)));

  const { users, total } = await userService.getAllUsers({
    page: pageNum,
    limit: limitNum,
    role,
    username
  }, req.audit);

  res.status(200).json({
    success: true,
    users,
    total,
    page: pageNum,
    limit: limitNum,
    totalPages: Math.ceil(total / limitNum)
  });
});

/**
 * GET /api/v1/users/:id
 */
export const getUserById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const user = await userService.getUserById(id, req.audit);
  res.status(200).json({ success: true, user });
});

/**
 * PUT /api/v1/users/:id
 * Body: { username?, email?, role? }
 */
export const updateUser = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const data = req.body;
  const user = await userService.updateUser(id, data, req.audit);
  res.status(200).json({ success: true, user });
});

/**
 * DELETE /api/v1/users/:id
 */
export const deleteUser = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const user = await userService.deleteUser(id, req.audit);
  res.status(200).json({ success: true, user });
});

================================================================================
// FILE: server\src\controllers\vendorController.js
================================================================================

import { asyncHandler } from '../utils/asyncHandler.js';
import * as vendorService from '../services/vendorService.js';

/**
 * POST /api/v1/vendors
 * Body: { name, contact:{ phone, email, address }, openingBalance? }
 */
export const createVendor = asyncHandler(async (req, res) => {
  const vendorData = req.body;
  const vendor = await vendorService.createVendor(vendorData, req.audit);
  res.status(201).json({ success: true, vendor });
});

/**
 * GET /api/v1/vendors
 * Query: page, limit, status, search
 */
export const getAllVendors = asyncHandler(async (req, res) => {
  const {
    page = 1,
    limit = 10,
    search = ''
  } = req.query;

  const result = await vendorService.getAllVendors({
    search,
    page: Number(page),
    limit: Number(limit)
  });

  res.status(200).json({ success: true, ...result });
});

/**
 * GET /api/v1/vendors/:id
 */
export const getVendorById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const vendor = await vendorService.getVendorById(id);
  res.status(200).json({ success: true, vendor });
});

/**
 * PUT /api/v1/vendors/:id
 * Body: any of { name, contact, openingBalance, email }
 */
export const updateVendor = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const updateData = req.body;
  const vendor = await vendorService.updateVendor(id, updateData, req.audit);
  res.status(200).json({ success: true, vendor });
});

/**
 * DELETE /api/v1/vendors/:id
 */
export const deleteVendor = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const vendor = await vendorService.deleteVendor(id, req.audit);
  res.status(200).json({ success: true, vendor });
});


================================================================================
// FILE: server\src\controllers\vendorTransactionController.js
================================================================================

// src/controllers/vendorTransactionController.js
import { asyncHandler } from '../utils/asyncHandler.js';
import * as vendorTxnService from '../services/vendorTxnService.js';

/**
 * POST /api/v1/vendor-transactions
 * Body: { vendorId, type, description?, amount, method, account }
 */
export const addVendorTransaction = asyncHandler(async (req, res) => {
  const { vendorId, type, description, amount, method, account } = req.body;
  const transaction = await vendorTxnService.addVendorTransaction({
    vendorId,
    type,
    description,
    amount,
    method,
    account
  }, req.audit);
  res.status(201).json({ success: true, transaction });
});

/**
 * GET /api/v1/vendor-transactions
 * Query: page, limit, vendorId, from, to
 */
export const getAllVendorTransactions = asyncHandler(async (req, res) => {
  const {
    page     = 1,
    limit    = 10,
    vendorId,
    from,
    to
  } = req.query;

  const result = await vendorTxnService.getAllVendorTransactions({
    vendorId,
    from,
    to,
    page:  Number(page),
    limit: Number(limit)
  });

  res.status(200).json({ success: true, ...result });
});

/**
 * GET /api/v1/vendor-transactions/:id
 */
export const getVendorTransactionById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const transaction = await vendorTxnService.getVendorTransactionById(id);
  res.status(200).json({ success: true, transaction });
});

/**
 * PUT /api/v1/vendor-transactions/:id
 * Body: { description }
 */
export const updateVendorTransaction = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { description } = req.body;
  const transaction = await vendorTxnService.updateVendorTransaction(id, { description }, req.audit);
  res.status(200).json({ success: true, transaction });
});

/**
 * DELETE /api/v1/vendor-transactions/:id
 */
export const deleteVendorTransaction = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const transaction = await vendorTxnService.deleteVendorTransaction(id, req.audit);
  res.status(200).json({ success: true, transaction });
});


================================================================================
// FILE: server\src\db\index.js
================================================================================

import mongoose from "mongoose";

const connectDB = async () => {
try {
    console.log(`Connecting to MongoDB at: ${process.env.MONGODB_URI}`);
    const connectionInstance = await mongoose.connect(`${process.env.MONGODB_URI}`);
    
    console.log(`MongoDB Connected: ${connectionInstance.connection.host}`);
} catch (error) {
    console.error("MONGO Connection ERROR", error);
    process.exit(1);
}
}

export default connectDB;

================================================================================
// FILE: server\src\middlewares\attachAuditContext.js
================================================================================

// src/middleware/attachAuditContext.js
export const attachAuditContext = (req, res, next) => {
    req.audit = {
      actor:     req.actor,            // set by jwtVerify
      ip:        req.ip,
      ua:        req.get('User-Agent')
    };
    next();
  };
  

================================================================================
// FILE: server\src\middlewares\authChecker.js
================================================================================

import jwt from "jsonwebtoken"
import User from "../models/user.model.js";
import { asyncHandler } from "../utils/asyncHandler.js";

export const jwtVerify = asyncHandler (async (req,res,next) => { 
    
    const token  =  req.cookies?.accessToken || req.header("Authorization")?.replace("Bearer ","");
    
    if(!token) {
      return res
      .status(401)
      .json({ success: false, message: "Unauthorized Request" });
    }

    try {
      const decodedToken = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET);

      if(!decodedToken || !decodedToken._id) {
        return res
        .status(401)
        .json({ success: false, message: "Access Denied" });
      }

      const user = await User.findById(decodedToken?._id).select("-password -refreshToken")

        if(!user) {
          return res
          .status(401)
          .json({ success: false, message: "Invalid Access Token" });
        }

        req.user = user;
        req.actor = { id: user._id, model: 'User' };
        next();
    }
    catch(e) 
    {
      return res
          .status(401)
          .json({ success: false, message: "Invalid Access Token" });
       
    }

})

================================================================================
// FILE: server\src\middlewares\authorize.js
================================================================================

// src/middleware/authorize.js
import ApiError from '../utils/ApiError.js';

export const authorize = (...allowedRoles) => (req, res, next) => {
  if (!req.user || !allowedRoles.includes(req.user.role)) {
    return next(new ApiError(403, 'Forbidden'));
  }
  next();
};


================================================================================
// FILE: server\src\middlewares\errorHandler.js
================================================================================

// src/middleware/errorHandler.js
import ApiError from '../utils/ApiError.js';

export const errorHandler = (err, req, res, next) => {
  // If thrown via ApiError, it has a statusCode
  const status = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';

  // Optionally hide stack in production
  const payload = {
    success: false,
    message
  };
  if (process.env.NODE_ENV !== 'production') {
    payload.stack = err.stack;
  }

  res.status(status).json(payload);
};


================================================================================
// FILE: server\src\middlewares\notFound.js
================================================================================

// src/middleware/notFound.js
export const notFound = (req, res, next) => {
    res.status(404).json({
      success: false,
      message: 'Route not found'
    });
  };
  

================================================================================
// FILE: server\src\middlewares\validate.js
================================================================================

// src/middleware/validate.js
import createError from 'http-errors';

export default function validate(schema, property = 'body') {
  return (req, res, next) => {
    const { error, value } = schema.validate(req[property]);
    if (error) {
      return next(createError(400, error.details[0].message));
    }
    req[property] = value;
    next();
  };
}


================================================================================
// FILE: server\src\models\auditLog.model.js
================================================================================

import mongoose from 'mongoose';

const AuditLogSchema = new mongoose.Schema({
  timestamp:      { type: Date, default: Date.now, index: true },

  // dynamic actor: User vs Employee
  actorId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    refPath: 'actorModel',
    index: true
  },
  actorModel: {
    type: String,
    required: true,
    enum: ['User','Employee'],
    index: true
  },

  action: {
    type: String,
    enum: ['CREATE','UPDATE','DELETE','LOGIN','LOGOUT'],
    required: true,
    index: true
  },
  collectionName: { type: String, required: true, index: true },
  documentId:     { type: mongoose.Schema.Types.ObjectId, required: true, index: true },

  before:         mongoose.Schema.Types.Mixed,
  after:          mongoose.Schema.Types.Mixed,
  ipAddress:      String,
  userAgent:      String
}, {
  versionKey: false
});

// Compound index for recent actor activity
AuditLogSchema.index({ timestamp: -1, actorId: 1 });

export default mongoose.model('AuditLog', AuditLogSchema);


================================================================================
// FILE: server\src\models\AuditPlugin.js
================================================================================

// in src/models/AuditPlugin.js
import mongoose from 'mongoose';
import * as audit from '../services/auditService.js';

export function auditPlugin(schema) {

  
  // After a create or update or delete
  // schema.post('save', async function(doc) {
  //   await audit.logAction({

  //     actorId:      this.options.actor.id,
  //     actorModel:   this.options.actor.model,
  //     action:       this.wasNew ? 'CREATE' : 'UPDATE',
  //     collectionName: this.constructor.modelName,
  //     documentId:   doc._id,
  //     before:       this._original,    // see below
  //     after:        doc.toObject(),
  //     ipAddress:    this.options.ip,
  //     userAgent:    this.options.ua
  //   });
  // });

  schema.post('save', async function(doc) {
    // read audit context from document locals (set in service)
    const ctx = this.$locals.audit || {};
    await audit.logAction({
      actorId:      ctx.actorId,
      actorModel:   ctx.actorModel,
      action:       this._wasNew ? 'CREATE' : 'UPDATE',
      collectionName: this.constructor.modelName,
      documentId:   doc._id,
      before:       this._original,
      after:        doc.toObject(),
      ipAddress:    ctx.ip,
      userAgent:    ctx.ua
    });
  });

  schema.pre('save', function(next) {
    // capture whether document is new, stash pre-save snapshot for "before"
    this._wasNew = this.isNew;
    this._original = this.toObject();
    next();
  });

  schema.post('findOneAndUpdate', async function(result) {
    await audit.logAction({
      actorId:        this.options.actor.id,
      actorModel:     this.options.actor.model,
      action:         'UPDATE',
      collectionName: this.model.modelName,
      documentId:     this.getQuery()._id,
      before:         this._original,  // capture in pre hook
      after:          result,
      ipAddress:      this.options.ip,
      userAgent:      this.options.ua
    });
  });

  schema.pre('findOneAndUpdate', async function(next) {
    // fetch the "before" doc
    this._original = await this.model.findOne(this.getQuery()).lean();
    next();
  });

  schema.post('findOneAndDelete', async function(result) {
    await audit.logAction({
      actorId:        this.options.actor.id,
      actorModel:     this.options.actor.model,
      action:         'DELETE',
      collectionName: this.model.modelName,
      documentId:     this.getQuery()._id,
      before:         result,
      after:          null,
      ipAddress:      this.options.ip,
      userAgent:      this.options.ua
    });
  });
}


================================================================================
// FILE: server\src\models\bankTransaction.model.js
================================================================================

// src/models/BankTransaction.js
import mongoose from 'mongoose';
import { auditPlugin } from './AuditPlugin.js';

const BankTransactionSchema = new mongoose.Schema({
  date:      { type: Date, default: Date.now, index: true },
  type:      { type: String, enum: ['Opening','Inflow','Outflow'], required: true },
  method:    { type: String, enum: ['Bank','Shabka'], required: true },
  reference: String,
  amount:    { type: Number, required: true },
  balance:   Number,
  status:    {
    type: String,
    enum: ['active', 'deleted'],
    default: 'active',
    index: true
  }
}, {
  timestamps: true
});


BankTransactionSchema.plugin(auditPlugin);

const BankTransaction = mongoose.models.BankTransaction || mongoose.model('BankTransaction', BankTransactionSchema);

export default BankTransaction;


================================================================================
// FILE: server\src\models\cashRegister.model.js
================================================================================

import mongoose from 'mongoose';
import { auditPlugin } from './AuditPlugin.js';

const CashRegisterSchema = new mongoose.Schema({
  date:      { type: Date, default: Date.now, index: true },
  type:      { type: String, enum: ['Opening','Inflow','Outflow'], required: true },
  reference: String,
  amount:    { type: Number, required: true },
  balance:   Number,
  status:    { type: String, enum: ['active', 'deleted'], default: 'active', index: true }
}, {
  timestamps: true
});

CashRegisterSchema.plugin(auditPlugin);

const CashRegister = mongoose.models.CashRegister || mongoose.model('CashRegister', CashRegisterSchema);

export default CashRegister;


================================================================================
// FILE: server\src\models\employee.model.js
================================================================================

// src/models/Employee.js
import mongoose from 'mongoose';
import { auditPlugin } from './AuditPlugin.js';

const EmployeeSchema = new mongoose.Schema({
  name:    { type: String,  required: true },
  contact: {
    phone:   String,
    email:   { type: String, required: true, unique: true },
    address: String
  },

  // Businessdomain role
  role: {
    type: String,
    enum: ['salesman','regular'],
    required: true,
    index: true
  },

  hireDate: { type: Date, default: Date.now },
  status:   {
    type: String,
    enum: ['active','inactive'],
    default: 'active',
    index: true
  },

  // Base salary configuration
  salary: {
    gross: { type: Number, required: true },
    net: { type: Number },
    lastModified: { type: Date, default: Date.now }
  },

  // Running balances
  salaryBalance: {
    type: Number,
    default: 0,
    required: true
  }
}, {
  timestamps: true
});

// Compound index for quick lookups
EmployeeSchema.index({ role: 1, status: 1 });

// Pre-save middleware to set net salary equal to gross by default
EmployeeSchema.pre('save', function(next) {
  // Set net salary equal to gross for new employees or when gross is updated
  if (this.isNew || this.isModified('salary.gross')) {
    if (!this.salary.net) {
      this.salary.net = this.salary.gross;
    }
    this.salary.lastModified = new Date();
  }
  next();
});

//  Apply the audit plugin here
EmployeeSchema.plugin(auditPlugin);

//  Guard against OverwriteModelError in hotreload or multiple imports
const Employee = mongoose.models.Employee
  || mongoose.model('Employee', EmployeeSchema);

export default Employee;


================================================================================
// FILE: server\src\models\expense.model.js
================================================================================

import mongoose from 'mongoose';
import { auditPlugin } from './AuditPlugin.js';

const ExpenseSchema = new mongoose.Schema({
  date:        { type: Date, default: Date.now, index: true },
  category:    {
    type: String,
    enum: ['Rent','Utilities','Salaries','Commissions','Advances Recovered','Inventory','Miscellaneous'],
    required: true,
    index: true
  },
  description: { type: String, required: true },
  amount:      { 
    type: Number, 
    required: true,
    validate: {
      validator: function(value) {
        // Value can be any number except zero
        return value !== 0;
      },
      message: 'Amount cannot be zero. Use positive for expenses or negative for reversals.'
    }
  },
  paymentType: { 
    type: String, 
    enum: ['Cash','Bank','Shabka'],
    required: true 
  },

  // dynamic reference: Employee vs Vendor
  paidTo: {
    type: mongoose.Schema.Types.ObjectId,
    refPath: 'paidToModel'
  },
  paidToModel: {
    type: String,
    enum: ['Employee','Vendor']
  },

  // e.g. link back to invoice or advance
  linkedTo: {
    type: mongoose.Schema.Types.ObjectId,
    refPath: 'linkedToModel'
  },
  linkedToModel: {
    type: String,
    enum: ['SalesInvoice','SalesmanAdvance']
  },
  
  // Bidirectional reference to the ledger entry
  ledgerEntryId: {
    type: mongoose.Schema.Types.ObjectId,
    refPath: 'ledgerEntryModel'
  },
  ledgerEntryModel: {
    type: String,
    enum: ['CashRegister','BankTransaction']
  },
  status: {
    type: String,
    enum: ['active', 'deleted'],
    default: 'active',
    index: true
  }
}, {
  timestamps: true
});

// Add indexes for common query patterns
ExpenseSchema.index({ category: 1, date: -1 });
ExpenseSchema.index({ paidTo: 1, paidToModel: 1 });
ExpenseSchema.index({ ledgerEntryId: 1, ledgerEntryModel: 1 });
ExpenseSchema.index({ paymentType: 1 });


ExpenseSchema.plugin(auditPlugin);

const Expense = mongoose.models.Expense || mongoose.model('Expense', ExpenseSchema);

export default Expense;


================================================================================
// FILE: server\src\models\salaryPayment.model.js
================================================================================

import mongoose from 'mongoose';
import { auditPlugin } from './AuditPlugin.js';

const SalaryPaymentSchema = new mongoose.Schema({
  employeeId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Employee',
    required: true,
    index: true
  },

  date: { 
    type: Date, 
    default: Date.now, 
    required: true,
    index: true 
  },

  type: {
    type: String,
    enum: ['Basic Salary', 'Salary Payment', 'Advance Salary', 'Extra Commission', 'Recovery Award', 'Deduction'],
    required: true
  },

  amount: {
    type: Number,
    required: true,
    validate: {
      validator: function(value) {
        // Allow both positive and negative values but not zero
        return value !== 0;
      },
      message: 'Amount cannot be zero'
    }
  },

  description: {
    type: String,
    required: true
  },

  paymentMethod: {
    type: String,
    enum: ['Cash', 'Bank', 'Shabka'],
    required: function() {
      return ['Salary Payment', 'Advance Salary'].includes(this.type);
    }
  },

  status: {
    type: String,
    enum: ['pending', 'completed', 'cancelled'],
    default: 'completed'
  },

  // Reference to expense entry
  expenseId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Expense'
  }
}, {
  timestamps: true
});

// Compound indexes for common queries
SalaryPaymentSchema.index({ employeeId: 1, date: -1 });
SalaryPaymentSchema.index({ employeeId: 1, type: 1 });

// Apply the audit plugin
SalaryPaymentSchema.plugin(auditPlugin);

const SalaryPayment = mongoose.models.SalaryPayment
  || mongoose.model('SalaryPayment', SalaryPaymentSchema);

export default SalaryPayment; 

================================================================================
// FILE: server\src\models\salesInvoice.model.js
================================================================================

// src/models/SalesInvoice.js
import mongoose from 'mongoose';
import { auditPlugin } from './AuditPlugin.js';

const SalesInvoiceSchema = new mongoose.Schema({
  invoiceNumber: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  date:         { type: Date, default: Date.now, index: true },
  customerName: String,
  salesmanId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Employee',
    required: true,
    index: true
  },

  items: [{
    description: String,
    quantity:    Number,
    unitPrice:   Number,
    costPrice:   Number,
    vatAmount:   Number,
    lineTotal:   Number
  }],

  totals: {
    subTotal:    Number,
    totalVat:    Number,
    grandTotal:  Number,
    totalCost:   Number,
    totalProfit: Number
  },

  payments: [{
    id:     { type: String, required: true },
    date:   Date,
    amount: Number,
    method: {
      type: String,
      enum: ['Cash','Bank','Shabka']
    },
    account: String
  }],

  status: {
    type: String,
    enum: ['Paid','Partially Paid','Unpaid','deleted'],
    default: 'Unpaid',
    index: true
  },
  
  deletedAt: { 
    type: Date,
    default: null 
  }
}, {
  timestamps: true
});

SalesInvoiceSchema.index({ salesmanId: 1, date: -1 });
SalesInvoiceSchema.index({ status: 1, date: -1 });

SalesInvoiceSchema.plugin(auditPlugin);

const SalesInvoice = mongoose.models.SalesInvoice || mongoose.model('SalesInvoice', SalesInvoiceSchema);

export default SalesInvoice;


================================================================================
// FILE: server\src\models\salesmanAdvance.model.js
================================================================================

// src/models/SalesmanAdvance.js
import mongoose from 'mongoose';
import { auditPlugin } from './AuditPlugin.js';

const SalesmanAdvanceSchema = new mongoose.Schema({
  salesmanId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Employee',
    required: true,
    index: true
  },
  invoiceId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'SalesInvoice',
    required: true
  },
  date:      { type: Date, default: Date.now, index: true },
  amount:    { type: Number, required: true },
  note:      String,
  recovered: { type: Boolean, default: false },
  status:    {
    type: String,
    enum: ['active', 'deleted'],
    default: 'active',
    index: true
  },
  paymentMethod: {
    type: String,
    enum: ['Cash', 'Bank', 'Shabka'],
    default: 'Cash'
  },
  account: {
    type: String,
    // Required only if paymentMethod is not Cash
    required: function() {
      return this.paymentMethod !== 'Cash';
    }
  }
}, {
  timestamps: true
});

// Add compound index for salesman and status
SalesmanAdvanceSchema.index({ salesmanId: 1, status: 1 });

SalesmanAdvanceSchema.plugin(auditPlugin);

const SalesmanAdvance = mongoose.models.SalesmanAdvance || mongoose.model('SalesmanAdvance', SalesmanAdvanceSchema);

export default SalesmanAdvance;


================================================================================
// FILE: server\src\models\user.model.js
================================================================================

// models/User.js
import mongoose from 'mongoose';

const UserSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true, index: true },
  email:    { type: String, required: true, unique: true, index: true },
  password: { type: String, required: true },
  role: {
    type: String,
    enum: ['superAdmin','admin'],
    default: 'admin',
    index: true
  },
  refreshToken: { type: String }
}, {
  timestamps: true
});

const User = mongoose.models.User || mongoose.model('User', UserSchema);

export default User;


================================================================================
// FILE: server\src\models\vendor.model.js
================================================================================

import mongoose from 'mongoose';
import { auditPlugin } from './AuditPlugin.js';

const VendorSchema = new mongoose.Schema({
  name: { 
    type: String, 
    required: true,
    trim: true
  },
  contact: {
    phone: {
      type: String,
      trim: true,
      validate: {
        validator: function(v) {
          return !v || /^[0-9+\-\s()]{6,20}$/.test(v);
        },
        message: props => `${props.value} is not a valid phone number`
      }
    },
    email: {
      type: String,
      trim: true,
      lowercase: true,
      validate: {
        validator: function(v) {
          return !v || /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v);
        },
        message: props => `${props.value} is not a valid email address`
      }
    },
    address: {
      type: String,
      trim: true
    }
  },
  openingBalance: { 
    type: Number, 
    default: 0,
    min: 0
  },
  status: {
    type: String,
    enum: ['active', 'deleted'],
    default: 'active',
    index: true
  }
}, {
  timestamps: true
});

// Compound indexes for common queries
VendorSchema.index({ name: 1, status: 1 }, { name: 'idx_name_status' });
VendorSchema.index({ 'contact.email': 1, status: 1 }, { name: 'idx_email_status' });

VendorSchema.plugin(auditPlugin);

const Vendor = mongoose.models.Vendor || mongoose.model('Vendor', VendorSchema);

export default Vendor;


================================================================================
// FILE: server\src\models\vendorTransaction.model.js
================================================================================

import mongoose from 'mongoose';
import { auditPlugin } from './AuditPlugin.js';

const VendorTransactionSchema = new mongoose.Schema({
  vendorId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vendor',
    required: true,
    index: true
  },
  type: {
    type: String,
    enum: ['Purchase', 'Payment'],
    required: true
  },
  description: {
    type: String,
    required: true,
    trim: true,
    minlength: 3,
    maxlength: 500
  },
  amount: {
    type: Number,
    required: true,
    validate: {
      validator: function(v) {
        // Allow negative amounts for reversals
        if (this.description && this.description.startsWith('Reversal of:')) {
          return v < 0; // Reversals must be negative
        }
        return v > 0; // Normal transactions must be positive
      },
      message: props => {
        const isReversal = this.description && this.description.startsWith('Reversal of:');
        if (isReversal) {
          return `${props.value} must be negative for reversal transactions`;
        }
        return `${props.value} must be positive for normal transactions`;
      }
    }
  },
  balance: {
    type: Number,
    required: true
  },
  date: {
    type: Date,
    default: Date.now,
    index: true
  },
  // Associated ledger entry (cash or bank) for this transaction
  ledgerEntryId: {
    type: mongoose.Schema.Types.ObjectId
  },
  ledgerEntryModel: {
    type: String,
    enum: ['CashRegister','BankTransaction']
  },
  method: {
    type: String,
    enum: ['Cash', 'Bank', 'Shabka'],
    required: function() {
      return this.type === 'Payment'; // Only required for Payment transactions
    }
  },
  status: {
    type: String,
    enum: ['active', 'deleted'],
    default: 'active',
    index: true
  }
}, {
  timestamps: true
});

// Compound indexes for common queries
VendorTransactionSchema.index(
  { vendorId: 1, date: -1 },
  { name: 'idx_vendor_date' }
);
VendorTransactionSchema.index(
  { vendorId: 1, status: 1 },
  { name: 'idx_vendor_status' }
);

VendorTransactionSchema.plugin(auditPlugin);

const VendorTransaction = mongoose.models.VendorTransaction || mongoose.model('VendorTransaction', VendorTransactionSchema);

export default VendorTransaction;


================================================================================
// FILE: server\src\routes\advanceRoutes.js
================================================================================

// src/routes/advanceRoutes.js
import { Router } from 'express';
import { authorize } from '../middlewares/authorize.js';
import validate from '../middlewares/validate.js';
import {
  recordAdvance,
  getAllAdvances,
  getAdvanceById,
  updateAdvance,
  deleteAdvance
} from '../controllers/advanceController.js';
import {
  createAdvanceSchema,
  listAdvancesSchema,
  updateAdvanceSchema
} from '../validators/advance.validator.js';

const router = Router();

// Anyone logged-in (employee+) can record, list, view, update advances
const guardBasic = [authorize('employee','admin','superAdmin')];
// Only admin+ can delete
const guardAdmin = [authorize('admin','superAdmin')];

router
  .route('/')
  .post(...guardBasic, validate(createAdvanceSchema), recordAdvance)
  .get(...guardBasic, validate(listAdvancesSchema, 'query'), getAllAdvances);

router
  .route('/:id')
  .get(...guardBasic, getAdvanceById)
  .put(...guardBasic, validate(updateAdvanceSchema), updateAdvance)
  .delete(...guardAdmin, deleteAdvance);

export default router;


================================================================================
// FILE: server\src\routes\auditRoutes.js
================================================================================

import { Router } from 'express';
import { authorize } from '../middlewares/authorize.js';
import {
  getAuditLogs,
  getAuditLogById
} from '../controllers/auditController.js';

const router = Router();

// Only admins and superAdmins can view audit logs
router
  .route('/')
  .get(
    authorize('admin', 'superAdmin'),
    getAuditLogs
  );

router
  .route('/:id')
  .get(
    authorize('admin', 'superAdmin'),
    getAuditLogById
  );

export default router;


================================================================================
// FILE: server\src\routes\authRoutes.js
================================================================================

import { Router } from "express";
import {
  login,
  Signup,
  logout,
  resetPassword,
  updatePassword,
  refreshAccessToken,
  changePassword
} from "../controllers/authController.js";
import { jwtVerify } from "../middlewares/authChecker.js";
const router = Router();

router.route("/signup").post(Signup);
router.route("/login").post(login);
router.route("/logout").post(jwtVerify, logout);
router.route("/refresh").post(refreshAccessToken);

router.route("/reset-password").post(resetPassword);
router.route("/update-password/:resetToken").post(updatePassword);
router.route("/change-password").post(jwtVerify, changePassword);

router.route("/verify").post(jwtVerify, (req, res) => {
  return res.status(200).json({ success: true, message: "Token is valid" });
});

export default router;


================================================================================
// FILE: server\src\routes\bankRoutes.js
================================================================================

import { Router } from 'express';
import { authorize } from '../middlewares/authorize.js';
import {
  recordBankTransaction,
  getAllBankTransactions,
  getBankTransactionById,
  updateBankTransaction,
  deleteBankTransaction
} from '../controllers/bankController.js';

const router = Router();

// Employees and above can create, list, view, update
const guardBasic = [  authorize('employee','admin','superAdmin') ];
// Only admins and superAdmins can delete
const guardAdmin = [  authorize('admin','superAdmin') ];

router
  .route('/')
  .post(...guardBasic, recordBankTransaction)
  .get (...guardBasic, getAllBankTransactions);

router
  .route('/:id')
  .get   (...guardBasic, getBankTransactionById)
  .put   (...guardBasic, updateBankTransaction)
  .delete(...guardAdmin,   deleteBankTransaction);

export default router;


================================================================================
// FILE: server\src\routes\cashRoutes.js
================================================================================

import { Router } from 'express';
import { authorize } from '../middlewares/authorize.js';
import {
  recordCashEntry,
  getAllCashEntries,
  getCashEntryById,
  updateCashEntry,
  deleteCashEntry,
  restoreCashEntry
} from '../controllers/cashController.js';

const router = Router();

const guard = authorize('employee','admin','superAdmin');
const admin = authorize('admin','superAdmin');

router
  .route('/')
  .post(guard,recordCashEntry)
  .get(guard,getAllCashEntries);

router
  .route('/:id')
  .get(guard,getCashEntryById)
  .put(guard,updateCashEntry)
  .delete(admin,deleteCashEntry);

// Restore a soft-deleted cash entry
router.post('/:id/restore', admin, restoreCashEntry);

export default router;


================================================================================
// FILE: server\src\routes\dashboardRoutes.js
================================================================================

import express from 'express';
import { getAllMetrics, getMetricsForDateRange } from '../controllers/dashboardController.js';

const router = express.Router();

// Get all metrics
router.get('/metrics', getAllMetrics);

// Get metrics for date range
router.get('/metrics/range', getMetricsForDateRange);

export default router; 

================================================================================
// FILE: server\src\routes\employeeRoutes.js
================================================================================

import { Router } from 'express';
import validate from '../middlewares/validate.js';
import { authorize } from '../middlewares/authorize.js';

import {
  createEmployeeSchema,
  listEmployeesSchema,
  getEmployeeByIdSchema,
  updateEmployeeSchema,
  deleteEmployeeSchema
} from '../validators/employee.validator.js';

import {
  createEmployee,
  getAllEmployees,
  getEmployeeById,
  updateEmployee,
  deleteEmployee
} from '../controllers/employeeController.js';

const router = Router();
const guard = authorize('admin','superAdmin');

// POST & GET /api/v1/employees
router.route('/')
  .post(
    guard,
    validate(createEmployeeSchema, 'body'),
    createEmployee
  )
  .get(
    guard,
    validate(listEmployeesSchema, 'query'),
    getAllEmployees
  );

// GET, PUT, DELETE /api/v1/employees/:id
router.route('/:id')
  .get(
    guard,
    validate(getEmployeeByIdSchema, 'params'),
    getEmployeeById
  )
  .put(
    guard,
    validate(getEmployeeByIdSchema, 'params'),
    validate(updateEmployeeSchema,  'body'),
    updateEmployee
  )
  .delete(
    guard,
    validate(getEmployeeByIdSchema, 'params'),
    validate(deleteEmployeeSchema,  'query'),
    deleteEmployee
  );

export default router;



================================================================================
// FILE: server\src\routes\expenseRoutes.js
================================================================================

import { Router } from 'express';
import { authorize } from '../middlewares/authorize.js';
import {
  recordExpense,
  getAllExpenses,
  getExpenseById,
  updateExpense,
  deleteExpense
} from '../controllers/expenseController.js';

const router = Router();

// All employees can create, view, and update expenses
const guardBasic = [ authorize('employee', 'admin', 'superAdmin') ];
// Only admin+ can delete
const guardAdmin = [ authorize('admin', 'superAdmin') ];

router
  .route('/')
  .post(...guardBasic, recordExpense)
  .get (...guardBasic, getAllExpenses);

router
  .route('/:id')
  .get   (...guardBasic, getExpenseById)
  .put   (...guardBasic, updateExpense)
  .delete(...guardAdmin, deleteExpense);

export default router;


================================================================================
// FILE: server\src\routes\invoiceRoutes.js
================================================================================

import { Router } from 'express';
import validate from '../middlewares/validate.js';
import { authorize } from '../middlewares/authorize.js';

import {
  createInvoiceSchema,
  listInvoicesSchema,
  getInvoiceByIdSchema,
  updateInvoiceSchema,
  deleteInvoiceSchema,
  addPaymentSchema,
  reversePaymentSchema,
  paymentIdParamSchema,
  commissionPaymentSchema
} from '../validators/invoice.validator.js';

import {
  createInvoice,
  getAllInvoices,
  getInvoiceById,
  updateInvoice,
  deleteInvoice,
  addPayment,
  reversePayment,
  updateCommission
} from '../controllers/invoiceController.js';

const router = Router();
// Auth middleware definitions - can be used optionally based on environment
const basic = authorize('employee','admin','superAdmin');
const admin = authorize('admin','superAdmin');

// POST & GET /api/v1/invoices
router.route('/')
  .post(
    basic,
    validate(createInvoiceSchema, 'body'),
    createInvoice
  )
  .get(
    basic,
    validate(listInvoicesSchema, 'query'),
    getAllInvoices
  );

// GET, PUT, DELETE /api/v1/invoices/:id
router.route('/:id')
  .get(
    basic,
    validate(getInvoiceByIdSchema, 'params'),
    getInvoiceById
  )
  .put(
    basic,
    validate(getInvoiceByIdSchema, 'params'),
    validate(updateInvoiceSchema,    'body'),
    updateInvoice
  )
  .delete(
    admin,
    validate(deleteInvoiceSchema, 'params'),
    deleteInvoice
  );

// Route for adding a payment
router.route('/:id/payments')
  .post(
    validate(getInvoiceByIdSchema, 'params'),
    validate(addPaymentSchema, 'body'),
    addPayment
  );

// Route for reversing a payment
router.route('/:id/payments/:paymentId/reverse')
  .post(
    validate(paymentIdParamSchema, 'params'),
    validate(reversePaymentSchema, 'body'),
    reversePayment
  );

// Route for updating commission payment
router.route('/:id/commission')
  .post(
    validate(getInvoiceByIdSchema, 'params'),
    validate(commissionPaymentSchema, 'body'),
    updateCommission
  );

export default router;


================================================================================
// FILE: server\src\routes\payrollRoutes.js
================================================================================

import { Router } from 'express';
import { authorize } from '../middlewares/authorize.js';
import { runPayroll } from '../controllers/payrollController.js';

const router = Router();

// Only admin and superAdmin can run payroll
router.post(
  '/',
  authorize('admin', 'superAdmin'),
  runPayroll
);

export default router;


================================================================================
// FILE: server\src\routes\reportRoutes.js
================================================================================

import { Router } from 'express';
import { authorize } from '../middlewares/authorize.js';
import { getMonthlySummary } from '../controllers/reportController.js';

const router = Router();

// Only admins and superAdmins can view reports
router.get(
  '/monthly',
  authorize('admin', 'superAdmin'),
  getMonthlySummary
);

export default router;


================================================================================
// FILE: server\src\routes\salaryRoutes.js
================================================================================

import { Router } from 'express';
import validate from '../middlewares/validate.js';
import { authorize } from '../middlewares/authorize.js';
import {
  addSalaryPayment,
  getEmployeeSalaryHistory,
  getEmployeeSalarySummary,
  updateEmployeeSalary
} from '../controllers/salaryController.js';

import {
  addSalaryPaymentSchema,
  getSalaryHistorySchema,
  updateSalarySchema
} from '../validators/salary.validator.js';

const router = Router();
const guard = authorize('admin', 'superAdmin');

// POST /api/v1/salary/payments
router.post(
  '/payments',
  guard,
  validate(addSalaryPaymentSchema, 'body'),
  addSalaryPayment
);

// GET /api/v1/salary/employees/:employeeId/history
router.get(
  '/employees/:employeeId/history',
  guard,
  validate(getSalaryHistorySchema, 'query'),
  getEmployeeSalaryHistory
);

// GET /api/v1/salary/employees/:employeeId/summary
router.get(
  '/employees/:employeeId/summary',
  guard,
  getEmployeeSalarySummary
);

// PUT /api/v1/salary/employees/:employeeId
router.put(
  '/employees/:employeeId',
  guard,
  validate(updateSalarySchema, 'body'),
  updateEmployeeSalary
);

export default router; 

================================================================================
// FILE: server\src\routes\userRoutes.js
================================================================================

import { Router } from 'express';
import validate from '../middlewares/validate.js';
import { authorize } from '../middlewares/authorize.js';

import {
  getAllUsersSchema,
  getUserByIdSchema,
  updateUserSchema,
  deleteUserSchema
} from '../validators/user.validator.js';

import {
  getAllUsers,
  getUserById,
  updateUser,
  deleteUser
} from '../controllers/userController.js';

const router = Router();

// GET  /api/v1/users
router.get(
  "/",
  authorize('admin','superAdmin'),
  validate(getAllUsersSchema, 'query'),
  getAllUsers
);

// GET /api/v1/users/:id
router.get(
  '/:id',
  authorize('admin','superAdmin'),
  validate(getUserByIdSchema, 'params'),
  getUserById
);

// PUT /api/v1/users/:id
router.put(
  '/:id',
  authorize('admin','superAdmin'),
  validate(getUserByIdSchema, 'params'),
  validate(updateUserSchema, 'body'),
  updateUser
);

// DELETE /api/v1/users/:id
router.delete(
  '/:id',
  authorize('superAdmin'),
  validate(deleteUserSchema, 'params'),
  deleteUser
);

export default router;


================================================================================
// FILE: server\src\routes\vendorRoutes.js
================================================================================

import { Router } from 'express';
import { authorize } from '../middlewares/authorize.js';
import {
  createVendor,
  getAllVendors,
  getVendorById,
  updateVendor,
  deleteVendor
} from '../controllers/vendorController.js';

const router = Router();

// Admins and superAdmins only
const guard = [  authorize('admin','superAdmin') ];

router
  .route('/')
  .post(...guard, createVendor)
  .get (...guard, getAllVendors);

router
  .route('/:id')
  .get   (...guard, getVendorById)
  .put   (...guard, updateVendor)
  .delete(...guard, deleteVendor);

export default router;


================================================================================
// FILE: server\src\routes\vendorTransactionRoutes.js
================================================================================

// src/routes/vendorTransactionRoutes.js
import { Router } from 'express';
import { authorize } from '../middlewares/authorize.js';
import validate from '../middlewares/validate.js';
import {
  addVendorTransaction,
  getAllVendorTransactions,
  getVendorTransactionById,
  updateVendorTransaction,
  deleteVendorTransaction
} from '../controllers/vendorTransactionController.js';
import {
  createVendorTransactionSchema,
  updateVendorTransactionSchema,
  listVendorTransactionsSchema
} from '../validators/vendor.validator.js';

const router = Router();

// Only admins and superAdmins manage vendor transactions
const guardAdmin = [authorize('admin','superAdmin')];

router
  .route('/')
  .post(...guardAdmin, validate(createVendorTransactionSchema), addVendorTransaction)
  .get(...guardAdmin, validate(listVendorTransactionsSchema, 'query'), getAllVendorTransactions);

router
  .route('/:id')
  .get(...guardAdmin, getVendorTransactionById)
  .put(...guardAdmin, validate(updateVendorTransactionSchema), updateVendorTransaction)
  .delete(...guardAdmin, deleteVendorTransaction);

export default router;


================================================================================
// FILE: server\src\services\advanceService.js
================================================================================

// src/services/advanceService.js
import mongoose from 'mongoose';
import SalesmanAdvance from '../models/salesmanAdvance.model.js';
import SalesInvoice     from '../models/salesInvoice.model.js';
import * as cashService from './cashService.js';
import * as bankService from './bankService.js';

/**
 * Record a new advance (cash draw) by a salesman on an invoice.
 * Also increments `salesInvoice.advance.taken` and updates `lastTaken`.
 *
 * @param {Object} params
 * @param {string} params.invoiceId
 * @param {string} params.salesmanId
 * @param {number} params.amount
 * @param {string} [params.note]
 * @param {string} [params.paymentMethod] - 'Cash', 'Bank', or 'Shabka', defaults to 'Cash'
 * @param {string} [params.account] - Required if paymentMethod is 'Bank' or 'Shabka'
 * @param {Object} audit       { actor, ip, ua } from attachAuditContext
 */
export async function recordAdvance(
  { invoiceId, salesmanId, amount, note = '', paymentMethod = 'Cash', account },
  { actor, ip, ua }
) {
  if (!mongoose.Types.ObjectId.isValid(invoiceId) ||
      !mongoose.Types.ObjectId.isValid(salesmanId)) {
    throw new Error('Invalid invoice or salesman ID');
  }

  // Validate payment method
  if (!['Cash', 'Bank', 'Shabka'].includes(paymentMethod)) {
    throw new Error("Payment method must be 'Cash', 'Bank', or 'Shabka'");
  }

  // Require account for bank methods
  if (paymentMethod !== 'Cash' && !account) {
    throw new Error(`Account information is required for ${paymentMethod} payment method`);
  }

  const session = await mongoose.startSession();
  session.startTransaction();
  try {
    // Get invoice details for reference
    const invoice = await SalesInvoice.findById(invoiceId)
      .session(session)
      .setOptions({ actor, ip, ua });
    
    if (!invoice) {
      throw new Error('Invoice not found');
    }
    
    // 1) Create the advance record (triggers save hook)
    const advance = await new SalesmanAdvance({
      invoiceId, 
      salesmanId, 
      amount, 
      note,
      paymentMethod,
    }).save({ session, actor, ip, ua });

    // 2) Update the invoice's advance summary (triggers findOneAndUpdate hook)
    await SalesInvoice.findByIdAndUpdate(
      invoiceId,
      {
        $inc: { 'advance.taken': amount },
        $set: { 'advance.lastTaken': advance.date }
      },
      { session, actor, ip, ua }
    );

    // 3) Record the cash or bank outflow
    const reference = `Advance for Invoice ${invoice.invoiceNumber}`;
    if (paymentMethod === 'Cash') {
      await cashService.recordCashEntry({
        date: advance.date,
        type: 'Outflow',
        reference,
        amount
      }, {
        session,
        actor,
        ip,
        ua
      });
    } else {
      // Bank or Shabka payment
      await bankService.recordBankTransaction({
        date: advance.date,
        type: 'Outflow',
        method: paymentMethod,
        reference,
        account,
        amount
      }, {
        session,
        actor,
        ip,
        ua
      });
    }

    await session.commitTransaction();
    return advance.toObject();
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}

/**
 * List advances, optionally filtered by salesman and date range,
 * with pagination.
 *
 * @param {Object} opts
 * @param {Object} [opts.filters] - { salesmanId, recovered }
 * @param {Object} [opts.dateRange] - { from, to }
 * @param {string} [opts.search]
 * @param {number} [opts.page=1]
 * @param {number} [opts.limit=10]
 */
export async function getAllAdvances({
  filters = {},
  dateRange = {},
  search = '',
  page = 1,
  limit = 10
} = {}, auditContext) {
  const query = { status: 'active' }; // Only show active advances by default
  
  // Apply filters
  if (filters.salesmanId) query.salesmanId = filters.salesmanId;
  if (filters.recovered !== undefined) query.recovered = filters.recovered;
  
  // Apply date range
  if (dateRange.from || dateRange.to) {
    query.date = {};
    if (dateRange.from) query.date.$gte = new Date(dateRange.from);
    if (dateRange.to) query.date.$lte = new Date(dateRange.to);
  }
  
  // Apply search if provided - search by note
  if (search) {
    query.note = { $regex: search, $options: 'i' };
  }

  const skip = (page - 1) * limit;
  const [ total, advances ] = await Promise.all([
    SalesmanAdvance.countDocuments(query),
    SalesmanAdvance.find(query)
      .populate('salesmanId', 'name contact')
      .populate('invoiceId', 'invoiceNumber date')
      .sort({ date: -1 })
      .skip(skip)
      .limit(limit)
      .setOptions({
        actor: auditContext.actor,
        ip: auditContext.ip,
        ua: auditContext.ua
      })
      .lean()
  ]);

  return {
    advances,
    pagination: {
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
      hasNextPage: page < Math.ceil(total / limit),
      hasPrevPage: page > 1
    }
  };
}

/**
 * Fetch a single advance by ID.
 *
 * @param {string} id
 */
export async function getAdvanceById(id, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid advance ID');
  }
  const adv = await SalesmanAdvance.findById(id)
    .populate('salesmanId', 'name contact')
    .populate('invoiceId',   'invoiceNumber date')
    .setOptions({
      actor: auditContext.actor,
      ip: auditContext.ip,
      ua: auditContext.ua
    })
    .lean();
  if (!adv) {
    throw new Error('Advance not found');
  }
  return adv;
}

/**
 * Update an advance's mutable fields.
 *
 * @param {string} id
 * @param {Object} data        { note?, recovered? }
 */
export async function updateAdvance(
  id,
  { note, recovered },
  { actor, ip, ua }
) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid advance ID');
  }

  // Start a session if recovering advance to handle the financial transaction
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    // Get the advance record before updating
    const advanceBefore = await SalesmanAdvance.findById(id)
      .session(session)
      .setOptions({ actor, ip, ua });
    
    if (!advanceBefore) {
      throw new Error('Advance not found');
    }
    
    // Check if we're changing the recovered status to true (recovery action)
    const isRecovering = recovered === true && advanceBefore.recovered !== true;
    
    // Prepare updates
    const updates = {};
    if (note !== undefined) updates.note = note;
    if (recovered !== undefined) updates.recovered = recovered;

    // Update the advance record
    const adv = await SalesmanAdvance.findByIdAndUpdate(
      id,
      updates,
      {
        new: true,
        runValidators: true,
        session,
        actor,
        ip,
        ua
      }
    )
      .populate('salesmanId', 'name contact')
      .populate('invoiceId', 'invoiceNumber date');

    // If we're recovering the advance, record an inflow in the appropriate ledger
    if (isRecovering) {
      const recoveredDate = new Date(); // Use current date for recovery
      const reference = `Recovery of advance for Invoice ${adv.invoiceId.invoiceNumber}`;
      
      // Determine payment method - use the one on record or default to Cash
      const paymentMethod = advanceBefore.paymentMethod || 'Cash';
      
      if (paymentMethod === 'Cash') {
        await cashService.recordCashEntry({
          date: recoveredDate,
          type: 'Inflow',
          reference,
          amount: advanceBefore.amount
        }, {
          session,
          actor,
          ip,
          ua
        });
      } else {
        // Bank or Shabka payment recovery
        await bankService.recordBankTransaction({
          date: recoveredDate,
          type: 'Inflow',
          method: paymentMethod,
          reference,
          amount: advanceBefore.amount
        }, {
          session,
          actor,
          ip,
          ua
        });
      }
    }
    
    await session.commitTransaction();
    return adv.toObject();
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}

/**
 * Soft delete an advance record.
 * Also decrements the invoice.advance.taken and resets lastTaken if needed.
 *
 * @param {string} id
 * @param {Object} audit       { actor, ip, ua }
 */
export async function deleteAdvance(
  id,
  { actor, ip, ua }
) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid advance ID');
  }
  const session = await mongoose.startSession();
  session.startTransaction();
  try {
    // 1) Load & soft delete the advance
    const adv = await SalesmanAdvance.findByIdAndUpdate(
      id,
      { status: 'deleted' },
      { 
        session, 
        actor, 
        ip, 
        ua,
        new: true 
      }
    );
    if (!adv) throw new Error('Advance not found');

    // 2) Decrement invoice.advance.taken & update lastTaken
    const invoice = await SalesInvoice.findById(adv.invoiceId)
      .session(session)
      .setOptions({ actor, ip, ua });
    if (invoice) {
      // Find the most recent active advance for this invoice (if any)
      const latestAdvance = await SalesmanAdvance.findOne({
        invoiceId: adv.invoiceId,
        status: 'active',
        _id: { $ne: id } // Exclude the one we're deleting
      })
        .sort({ date: -1 })
        .session(session);

      await SalesInvoice.findByIdAndUpdate(
        invoice._id,
        {
          $inc: { 'advance.taken': -adv.amount },
          $set: { 'advance.lastTaken': latestAdvance ? latestAdvance.date : null }
        },
        { session, actor, ip, ua }
      );
    }

    // 3) Create a reversal entry in the appropriate ledger
    const reversalReference = `Reversal of advance for deleted record ID: ${adv._id}`;
    
    // Check if the advance has a paymentMethod field - if it exists and is Bank/Shabka, use bankService
    // Otherwise default to cash (which is the standard for advances)
    if (adv.paymentMethod && ['Bank', 'Shabka'].includes(adv.paymentMethod)) {
      await bankService.recordBankTransaction(
        {
          date: new Date(),
          type: 'Inflow', // Inflow because we're returning the funds
          method: adv.paymentMethod,
          reference: reversalReference,
          amount: adv.amount
        },
        { 
          session,
          actor,
          ip,
          ua
        }
      );
    } else {
      // Default case - treat as cash advance
      await cashService.recordCashEntry(
        {
          date: new Date(),
          type: 'Inflow', // Inflow because we're returning the cash that was taken as an advance
          reference: reversalReference,
          amount: adv.amount
        },
        { 
          session,
          actor,
          ip,
          ua
        }
      );
    }

    await session.commitTransaction();
    return adv;
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}


================================================================================
// FILE: server\src\services\auditService.js
================================================================================

// src/services/auditService.js
import mongoose from 'mongoose';
import AuditLog from '../models/auditLog.model.js';
import User from '../models/user.model.js';
import Employee from '../models/employee.model.js';

/**
 * Log an audit entry.
 *
 * @param {Object} params
 * @param {string} params.actorId          ObjectId of the actor (User or Employee)
 * @param {string} params.actorModel       'User' or 'Employee'
 * @param {string} params.action           'CREATE' | 'UPDATE' | 'DELETE' | 'LOGIN' | 'LOGOUT'
 * @param {string} params.collectionName   name of the collection changed
 * @param {string} params.documentId       ObjectId of the document affected
 * @param {Object} [params.before]         snapshot before change
 * @param {Object} [params.after]          snapshot after change
 * @param {string} [params.ipAddress]
 * @param {string} [params.userAgent]
 * @returns {Promise<Object>}              the saved audit log entry
 */
export async function logAction({
  actorId,
  actorModel,
  action,
  collectionName,
  documentId,
  before = null,
  after = null,
  ipAddress = null,
  userAgent = null
}) {
  // validate IDs
  if (!mongoose.Types.ObjectId.isValid(actorId)) {
    throw new Error('Invalid actorId');
  }
  if (!mongoose.Types.ObjectId.isValid(documentId)) {
    throw new Error('Invalid documentId');
  }

  const entry = new AuditLog({
    actorId,
    actorModel,
    action,
    collectionName,
    documentId,
    before,
    after,
    ipAddress,
    userAgent
  });
  const saved = await entry.save();
  return saved.toObject();
}

/**
 * Fetch a single audit log entry by its ID.
 *
 * @param {string} id
 * @returns {Promise<Object>}
 */
export async function getAuditLogById(id) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid audit log ID');
  }
  const log = await AuditLog.findById(id).lean();
  if (!log) {
    throw new Error('Audit log entry not found');
  }
  return log;
}

/**
 * Query audit log entries with filters, date range, and pagination.
 *
 * @param {Object} opts
 * @param {string} [opts.actorId]
 * @param {string} [opts.actorModel]
 * @param {string} [opts.action]
 * @param {string} [opts.collectionName]
 * @param {string} [opts.documentId]
 * @param {string} [opts.from]    ISO date string
 * @param {string} [opts.to]      ISO date string
 * @param {number} [opts.page=1]
 * @param {number} [opts.limit=10]
 * @returns {Promise<Object>}     { logs: Array, pagination: { total, page, limit, totalPages, hasNextPage, hasPrevPage } }
 */
export async function getAuditLogs({
  actorId,
  actorModel,
  action,
  collectionName,
  documentId,
  from,
  to,
  page = 1,
  limit = 10
} = {}) {
  const query = {};
  if (actorId)        query.actorId        = actorId;
  if (actorModel)     query.actorModel     = actorModel;
  if (action)         query.action         = action;
  if (collectionName) query.collectionName = collectionName;
  if (documentId)     query.documentId     = documentId;
  if (from || to) {
    query.timestamp = {};
    if (from) query.timestamp.$gte = new Date(from);
    if (to)   query.timestamp.$lte = new Date(to);
  }

  const skip = (page - 1) * limit;
  const [ total, logs ] = await Promise.all([
    AuditLog.countDocuments(query),
    AuditLog.find(query)
      .sort({ timestamp: -1 })
      .skip(skip)
      .limit(limit)
      .lean()
  ]);

  // Fetch actor details for each log
  const enhancedLogs = await Promise.all(logs.map(async (log) => {
    let actorDetails = null;
    
    if (log.actorModel === 'User') {
      actorDetails = await User.findById(log.actorId).select('username').lean();
    } else if (log.actorModel === 'Employee') {
      actorDetails = await Employee.findById(log.actorId).select('name').lean();
    }

    return {
      ...log,
      actorDetails: actorDetails || { name: 'Unknown', username: 'Unknown' }
    };
  }));

  const totalPages = Math.ceil(total / limit);
  return {
    logs: enhancedLogs,
    pagination: {
      total,
      page,
      limit,
      totalPages,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1
    }
  };
}


================================================================================
// FILE: server\src\services\bankService.js
================================================================================

// src/services/bankService.js
import mongoose from 'mongoose';
import BankTransaction from '../models/bankTransaction.model.js';

/**
 * Record a new bank or Shabka transaction.
 * Automatically computes the running balance.
 *
 * @param {Object} params
 * @param {string} [params.date]
 * @param {string} params.type
 * @param {string} params.method
 * @param {string} params.reference
 * @param {number} params.amount
 * @param {Object} audit          { actor, ip, ua } from attachAuditContext
 */
export async function recordBankTransaction(
  { date, type, method, reference, amount },
  auditContext
) {
  const { actor, ip, ua, session: externalSession } = auditContext;
  // Use existing session if provided, otherwise create one
  let session = externalSession;
  let ownSession = false;
  if (!session) {
    session = await mongoose.startSession();
    session.startTransaction();
    ownSession = true;
  }

  // Validate required fields
  if (!reference) {
    throw new Error('Reference is required');
  }
  if (amount === undefined || amount === null) {
    throw new Error('Amount is required');
  }
  if (typeof amount !== 'number' || isNaN(amount)) {
    throw new Error('Amount must be a valid number');
  }
  if (amount <= 0) {
    throw new Error('Amount must be greater than zero');
  }

  if (!['Opening','Inflow','Outflow'].includes(type)) {
    throw new Error('Type must be "Opening", "Inflow", or "Outflow"');
  }
  if (!['Bank','Shabka'].includes(method)) {
    throw new Error('Method must be "Bank" or "Shabka"');
  }

  try {
    // Check if we're trying to create an Opening type entry
    if (type === 'Opening') {
      // Check if an Opening entry already exists
      const existingOpening = await BankTransaction.findOne({ 
        type: 'Opening',
        status: 'active'
      }).session(session);
      
      if (existingOpening) {
        throw new Error('An opening balance entry already exists. Only one opening balance is allowed.');
      }
    }

    // 1) Get last balance
    const last = await BankTransaction.findOne({ status: 'active' })
      .sort({ date: -1 })
      .session(session);

    const lastBalance = last ? last.balance : 0;

    // 2) Compute new balance
    let newBalance;
    if (type === 'Opening') {
      newBalance = amount;
    } else {
      newBalance = type === 'Inflow'
        ? lastBalance + amount
        : lastBalance - amount;
    }

    // 3) Create the transaction
    const txn = new BankTransaction({
      date:      date ? new Date(date) : new Date(),
      type,
      method,
      reference,
      amount,
      balance:   newBalance
    });

    // Attach audit metadata via $locals.audit
    txn.$locals = txn.$locals || {};
    txn.$locals.audit = {
      actorId:    actor.id,
      actorModel: actor.model,
      ip:         ip,
      ua:         ua
    };

    // Save under the session so auditPlugin sees $locals.audit
    const saved = await txn.save({ session });

    // Commit if we started the session
    if (ownSession) {
      await session.commitTransaction();
    }
    return saved.toObject();
  } catch (err) {
    if (ownSession) {
      await session.abortTransaction();
    }
    throw err;
  } finally {
    if (ownSession) session.endSession();
  }
}

/**
 * List bank transactions with optional filters & pagination.
 *
 * @param {Object} opts
 * @param {string} [opts.method]
 * @param {string} [opts.from]
 * @param {string} [opts.to]
 * @param {number} [opts.page=1]
 * @param {number} [opts.limit=10]
 * @param {boolean} [opts.includeDeleted=false] - Whether to include soft-deleted entries
 */
export async function getAllBankTransactions({
  method,
  from,
  to,
  page  = 1,
  limit = 10,
  includeDeleted = false
} = {}) {
  const query = {};
  if (method)  query.method  = method;
  if (from || to) {
    query.date = {};
    if (from) query.date.$gte = new Date(from);
    if (to)   query.date.$lte = new Date(to);
  }
  
  // Only include active entries unless specifically requested
  if (!includeDeleted) {
    query.status = 'active';
  }

  const skip = (page - 1) * limit;
  const [ total, txns ] = await Promise.all([
    BankTransaction.countDocuments(query),
    BankTransaction.find(query)
      .sort({ 
        date: -1, // Sort by date descending (newest first)
        // For entries on the same date, sort Opening last (after Inflow/Outflow)
        type: -1 // This works because 'Opening' comes after 'Inflow'/'Outflow' alphabetically when sorted descending
      })
      .skip(skip)
      .limit(limit)
      .lean()
  ]);

  return {
    transactions: txns,
    pagination: {
      total,
      page,
      limit,
      totalPages:  Math.ceil(total / limit),
      hasNextPage: page < Math.ceil(total / limit),
      hasPrevPage: page > 1
    }
  };
}

/**
 * Fetch one bank transaction by ID.
 *
 * @param {string} id
 * @param {boolean} [includeDeleted=false] - Whether to include soft-deleted entries
 */
export async function getBankTransactionById(id, includeDeleted = false) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid transaction ID');
  }
  
  const query = { _id: id };
  if (!includeDeleted) {
    query.status = 'active';
  }
  
  const txn = await BankTransaction.findOne(query).lean();
  if (!txn) {
    throw new Error('Transaction not found');
  }
  return txn;
}

/**
 * Update only the reference text of a bank transaction.
 * (Balances are not recalculated on update.)
 *
 * @param {string} id
 * @param {Object} data      { reference }
 * @param {Object} audit     { actor, ip, ua }
 */
export async function updateBankTransaction(
  id,
  { reference },
  { actor, ip, ua }
) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid transaction ID');
  }

  const txn = await BankTransaction.findOne({ _id: id, status: 'active' });
  if (!txn) {
    throw new Error('Transaction not found or has been deleted');
  }

  // Only update reference if it's provided, otherwise keep the existing one
  if (reference !== undefined) {
    txn.reference = reference;
  }

  // Attach audit metadata via $locals.audit
  txn.$locals = txn.$locals || {};
  txn.$locals.audit = {
    actorId:    actor.id,
    actorModel: actor.model,
    ip:         ip,
    ua:         ua
  };

  const updated = await txn.save();
  return updated.toObject();
}

/**
 * Soft delete a bank transaction.
 * Recalculates all subsequent balances.
 *
 * @param {string} id
 * @param {Object} auditContext          { actor, ip, ua } from attachAuditContext
 */
export async function deleteBankTransaction(id, auditContext) {
  const { actor, ip, ua, session: externalSession } = auditContext;

  // Validate basic actor presence and type
  if (!actor?.id || !['User', 'Employee'].includes(actor.model)) {
    throw new Error('Invalid actor context');
  }

  // Validate transaction ID
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid transaction ID');
  }

  // Use existing session if provided, otherwise create one
  let session = externalSession;
  let ownSession = false;
  if (!session) {
    session = await mongoose.startSession();
    session.startTransaction();
    ownSession = true;
  }

  try {
    // 1) Fetch the transaction to delete
    const txn = await BankTransaction.findOne({ _id: id, status: 'active' }).session(session);
    if (!txn) {
      throw new Error('Transaction not found or has been deleted');
    }

    // 2) Prevent deletion of opening balance if later entries exist
    if (txn.type === 'Opening') {
      const laterTxns = await BankTransaction.findOne({
        date: { $gt: txn.date },
        status: 'active'
      }).session(session);

      if (laterTxns) {
        throw new Error('Cannot delete opening balance when there are later transactions');
      }
    }

    // 3) Soft delete the transaction
    txn.status = 'deleted';

    // Set audit metadata
    txn.$locals = txn.$locals || {};
    txn.$locals.audit = {
      actorId: actor.id,
      actorModel: actor.model,
      ip,
      ua
    };

    await txn.save({ session });

    // 4) Recalculate balances of all subsequent entries
    const subsequent = await BankTransaction.find({
      date: { $gt: txn.date },
      status: 'active'
    })
      .sort({ date: 1 })
      .session(session);

    const previous = await BankTransaction.findOne({
      date: { $lt: txn.date },
      status: 'active'
    })
      .sort({ date: -1 })
      .session(session);

    let runningBalance = previous ? previous.balance : 0;

    for (const next of subsequent) {
      if (next.type === 'Opening') {
        runningBalance = next.amount;
      } else {
        runningBalance = next.type === 'Inflow'
          ? runningBalance + next.amount
          : runningBalance - next.amount;
      }

      next.balance = runningBalance;

      next.$locals = next.$locals || {};
      next.$locals.audit = {
        actorId: actor.id,
        actorModel: actor.model,
        ip,
        ua
      };

      await next.save({ session });
    }

    // Commit if we started the session
    if (ownSession) {
      await session.commitTransaction();
    }

    return txn.toObject();
  } catch (err) {
    if (ownSession) {
      await session.abortTransaction();
    }
    throw err;
  } finally {
    if (ownSession) {
      session.endSession();
    }
  }
}

export async function recalculateBalancesFromDate(startDate, session, auditContext) {
  // Find the last entry before startDate
  const previous = await BankTransaction.findOne({
    date: { $lt: startDate },
    status: 'active'
  }).sort({ date: -1 }).session(session);

  let running = previous ? previous.balance : 0;

  // Get all entries from startDate onwards, sorted by date
  const entries = await BankTransaction.find({
    date: { $gte: startDate },
    status: 'active'
  }).sort({ date: 1 }).session(session);

  for (const e of entries) {
    if (e.type === 'Opening') running = e.amount;
    else if (e.type === 'Inflow') running += e.amount;
    else if (e.type === 'Outflow') running -= e.amount;
    e.balance = running;
    // Set audit context for recalculation
    e.$locals = e.$locals || {};
    e.$locals.audit = auditContext || {
      actorId: 'system',
      actorModel: 'System',
      ip: '127.0.0.1',
      ua: 'balance-recalc'
    };
    await e.save({ session });
  }
}


================================================================================
// FILE: server\src\services\cashService.js
================================================================================

// src/services/cashService.js
import mongoose from 'mongoose';
import CashRegister from '../models/cashRegister.model.js';
import ApiError from '../utils/ApiError.js';

/**
 * Record a new cash register entry (Opening, Inflow, or Outflow).
 * Automatically computes the running balance.
 *
 * @param {Object} params
 * @param {string} [params.date]       ISO date string; defaults to now
 * @param {string} params.type         "Opening" | "Inflow" | "Outflow"
 * @param {string} params.reference    free-text description
 * @param {number} params.amount
 */
export async function recordCashEntry(
  { date, type, reference, amount },
  auditContext
) {
  if (!['Opening','Inflow','Outflow'].includes(type)) {
    throw new Error('Type must be "Opening", "Inflow", or "Outflow"');
  }
  // Use existing session if provided, otherwise create one
  let session = auditContext.session;
  let ownSession = false;
  if (!session) {
    session = await mongoose.startSession();
    session.startTransaction();
    ownSession = true;
  }
  try {
    // Check if we're trying to create an Opening type entry
    if (type === 'Opening') {
      // Check if an Opening entry already exists
      const existingOpening = await CashRegister.findOne({ 
        type: 'Opening',
        status: 'active'
      }).session(session);
      if (existingOpening) {
        throw new Error('An opening balance entry already exists. Only one opening balance is allowed.');
      }
    }
    
    // 1) Determine last balance
    const last = await CashRegister.findOne({ status: 'active' })
      .sort({ date: -1 })
      .session(session);
    const lastBalance = last ? last.balance : 0;
    // 2) Compute new balance
    let newBalance;
    if (type === 'Opening') newBalance = amount;
    else if (type === 'Inflow') newBalance = lastBalance + amount;
    else newBalance = lastBalance - amount;
    // 3) Create the entry
    const entry = new CashRegister({
      date: date ? new Date(date) : new Date(),
      type,
      reference,
      amount,
      balance: newBalance,
      status: 'active'
    });
    
    // Attach audit metadata via $locals.audit
    entry.$locals = entry.$locals || {};
    entry.$locals.audit = {
      actorId:    auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip:         auditContext.ip,
      ua:         auditContext.ua
    };
    
    // Save under the session so auditPlugin sees $locals.audit
    const saved = await entry.save({ session });
    
    // Commit if we started the session
    if (ownSession) {
      await session.commitTransaction();
    }
    return saved.toObject();
  } catch (err) {
    if (ownSession) {
      await session.abortTransaction();
    }
    throw err;
  } finally {
    if (ownSession) session.endSession();
  }
}

/**
 * List cash register entries, with optional date range and type filter,
 * plus pagination.
 *
 * @param {Object} opts
 * @param {string} [opts.from]    ISO date string
 * @param {string} [opts.to]      ISO date string
 * @param {string} [opts.type]    "Opening" | "Inflow" | "Outflow"
 * @param {number} [opts.page=1]
 * @param {number} [opts.limit=10]
 * @param {boolean} [opts.includeDeleted=false] - Whether to include soft-deleted entries
 */
export async function getAllCashEntries({
  from,
  to,
  type,
  page = 1,
  limit = 10,
  includeDeleted = false
} = {}) {
  const query = {};
  if (type) query.type = type;
  if (from || to) {
    query.date = {};
    if (from) query.date.$gte = new Date(from);
    if (to) query.date.$lte = new Date(to);
  }
  
  // Only include active entries unless specifically requested
  if (!includeDeleted) {
    query.status = 'active';
  }

  const skip = (page - 1) * limit;
  const [total, entries] = await Promise.all([
    CashRegister.countDocuments(query),
    CashRegister.find(query)
      .sort({ 
        date: -1, // Sort by date descending (newest first)
        // For entries on the same date, sort Opening last (after Inflow/Outflow)
        type: -1 // This works because 'Opening' comes after 'Inflow'/'Outflow' alphabetically when sorted descending
      })
      .skip(skip)
      .limit(limit)
      .lean()
  ]);

  return {
    entries,
    pagination: {
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
      hasNextPage: page < Math.ceil(total / limit),
      hasPrevPage: page > 1
    }
  };
}

/**
 * Fetch a single cash entry by ID.
 *
 * @param {string} id
 * @param {boolean} [includeDeleted=false] - Whether to include soft-deleted entries
 */
export async function getCashEntryById(id, includeDeleted = false) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid cash entry ID');
  }
  
  const query = { _id: id };
  if (!includeDeleted) {
    query.status = 'active';
  }
  
  const entry = await CashRegister.findOne(query).lean();
  if (!entry) {
    throw new Error('Cash entry not found');
  }
  return entry;
}

/**
 * Update only the reference text of a cash entry.
 *
 * @param {string} id
 * @param {Object} data  { reference }
 */
export async function updateCashEntry(id, { reference }, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid cash entry ID');
  }
  
  // First find the entry to update
  const entry = await CashRegister.findOne({ _id: id, status: 'active' });
  if (!entry) {
    throw new Error('Cash entry not found or has been deleted');
  }
  
  // Update the reference
  entry.reference = reference;
  
  // Attach audit metadata via $locals.audit
  entry.$locals = entry.$locals || {};
  entry.$locals.audit = {
    actorId:    auditContext.actor.id,
    actorModel: auditContext.actor.model,
    ip:         auditContext.ip,
    ua:         auditContext.ua
  };
  
  // Save the updated entry
  const updatedEntry = await entry.save();
  return updatedEntry.toObject();
}

/**
 * Soft delete a cash entry and re-calculate subsequent running balances.
 *
 * @param {string} id
 */
export async function deleteCashEntry(id, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid cash entry ID');
  }

  const session = await mongoose.startSession();
  session.startTransaction();
  try {
    // 1) Fetch the target entry
    const toDelete = await CashRegister.findOne({ _id: id, status: 'active' }).session(session);
    if (!toDelete) throw new Error('Cash entry not found or has been deleted');
    
    // Check if entry is an opening balance
    if (toDelete.type === 'Opening') {
      // Get all entries after this one
      const laterEntries = await CashRegister.countDocuments({
        date: { $gt: toDelete.date },
        status: 'active'
      }).session(session);
      
      if (laterEntries > 0) {
        throw new Error('Cannot delete opening balance entry when later entries exist');
      }
    }
    
    // Store entry info before soft deletion
    const deletedEntry = toDelete.toObject();
    
    // Soft delete by changing status
    toDelete.status = 'deleted';
    
    // Attach audit metadata via $locals.audit
    toDelete.$locals = toDelete.$locals || {};
    toDelete.$locals.audit = {
      actorId:    auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip:         auditContext.ip,
      ua:         auditContext.ua
    };
    
    // Save the updated status
    await toDelete.save({ session });

    // 3) Find all entries that need balance recalculation
    // Only recalculate active entries with a date >= the deleted entry's date
    const entries = await CashRegister.find({
      date: { $gte: deletedEntry.date },
      status: 'active'
    })
      .sort({ date: 1 })
      .session(session);
      
    if (entries.length === 0) {
      // No entries to recalculate
      await session.commitTransaction();
      return deletedEntry;
    }
    
    // 4) Find the last active entry before the deleted one to get starting balance
    const previousEntry = await CashRegister.findOne({
      date: { $lt: deletedEntry.date },
      status: 'active'
    })
      .sort({ date: -1 })
      .session(session);
    
    // Start with previous balance or 0 if no previous entry
    let running = previousEntry ? previousEntry.balance : 0;
    
    // 5) Recalculate all balances after the deleted entry
    for (const e of entries) {
      if (e.type === 'Opening') {
        running = e.amount;
      } else if (e.type === 'Inflow') {
        running += e.amount;
      } else if (e.type === 'Outflow') {
        running -= e.amount;
      }
      
      // Update the balance while preserving audit tracking
      e.balance = running;
      
      // Attach audit metadata via $locals.audit
      e.$locals = e.$locals || {};
      e.$locals.audit = {
        actorId:    auditContext.actor.id,
        actorModel: auditContext.actor.model,
        ip:         auditContext.ip,
        ua:         auditContext.ua
      };
      
      await e.save({ session });
    }

    await session.commitTransaction();
    return deletedEntry;
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}

/**
 * Restore a soft-deleted cash entry.
 *
 * @param {string} id
 */
export async function restoreCashEntry(id, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid cash entry ID');
  }

  const session = await mongoose.startSession();
  session.startTransaction();
  try {
    // 1) Fetch the deleted entry
    const toRestore = await CashRegister.findOne({ _id: id, status: 'deleted' }).session(session);
    if (!toRestore) throw new Error('Deleted cash entry not found');
    
    // 2) Restore the entry
    toRestore.status = 'active';
    
    // Attach audit metadata
    toRestore.$locals = toRestore.$locals || {};
    toRestore.$locals.audit = {
      actorId:    auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip:         auditContext.ip,
      ua:         auditContext.ua
    };
    
    await toRestore.save({ session });
    
    // 3) Recalculate balances for all entries including and after this one
    const entries = await CashRegister.find({
      date: { $gte: toRestore.date },
      status: 'active'
    })
      .sort({ date: 1 })
      .session(session);
    
    // Find the previous active entry to get the starting balance
    const previousEntry = await CashRegister.findOne({
      date: { $lt: toRestore.date },
      status: 'active'
    })
      .sort({ date: -1 })
      .session(session);
    
    let running = previousEntry ? previousEntry.balance : 0;
    
    // Recalculate all balances
    for (const e of entries) {
      if (e.type === 'Opening') {
        running = e.amount;
      } else if (e.type === 'Inflow') {
        running += e.amount;
      } else if (e.type === 'Outflow') {
        running -= e.amount;
      }
      
      // Update balance and audit
      e.balance = running;
      e.$locals = e.$locals || {};
      e.$locals.audit = {
        actorId:    auditContext.actor.id,
        actorModel: auditContext.actor.model,
        ip:         auditContext.ip,
        ua:         auditContext.ua
      };
      
      await e.save({ session });
    }
    
    await session.commitTransaction();
    return toRestore.toObject();
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}

export async function recalculateBalancesFromDate(startDate, session, auditContext) {
  // Find the last entry before startDate
  const previous = await CashRegister.findOne({
    date: { $lt: startDate },
    status: 'active'
  }).sort({ date: -1 }).session(session);

  let running = previous ? previous.balance : 0;

  // Get all entries from startDate onwards, sorted by date
  const entries = await CashRegister.find({
    date: { $gte: startDate },
    status: 'active'
  }).sort({ date: 1 }).session(session);

  for (const e of entries) {
    if (e.type === 'Opening') running = e.amount;
    else if (e.type === 'Inflow') running += e.amount;
    else if (e.type === 'Outflow') running -= e.amount;
    e.balance = running;
    // Set audit context for recalculation
    e.$locals = e.$locals || {};
    e.$locals.audit = auditContext || {
      actorId: 'system',
      actorModel: 'System',
      ip: '127.0.0.1',
      ua: 'balance-recalc'
    };
    await e.save({ session });
  }
}


================================================================================
// FILE: server\src\services\dashboardService.js
================================================================================

import mongoose from 'mongoose';
import SalesInvoice from '../models/salesInvoice.model.js';
import Expense from '../models/expense.model.js';
import Employee from '../models/employee.model.js';
import Vendor from '../models/vendor.model.js';

export async function getDashboardMetrics() {
  try {
    // Get all sales metrics
    const salesMetrics = await SalesInvoice.aggregate([
      {
        $match: {
          status: { $ne: 'deleted' }
        }
      },
      {
        $group: {
          _id: null,
          totalSales: { $sum: '$totals.grandTotal' },
          totalProfit: { $sum: '$totals.totalProfit' },
          totalVat: { $sum: '$totals.totalVat' },
          grossProfit: { $sum: { $subtract: ['$totals.grandTotal', '$totals.totalCost'] } }
        }
      }
    ]);

    // Get credit and debit totals from sales
    const paymentMetrics = await SalesInvoice.aggregate([
      {
        $match: {
          status: { $ne: 'deleted' }
        }
      },
      {
        $unwind: '$payments'
      },
      {
        $group: {
          _id: '$payments.method',
          total: { $sum: '$payments.amount' }
        }
      }
    ]);

    // Get top 5 salesmen
    const topSalesmen = await SalesInvoice.aggregate([
      {
        $match: {
          status: { $ne: 'deleted' }
        }
      },
      {
        $group: {
          _id: '$salesmanId',
          totalSales: { $sum: '$totals.grandTotal' },
          totalTransactions: { $sum: 1 }
        }
      },
      {
        $lookup: {
          from: 'employees',
          localField: '_id',
          foreignField: '_id',
          as: 'employee'
        }
      },
      {
        $unwind: '$employee'
      },
      {
        $project: {
          _id: 1,
          name: '$employee.name',
          totalSales: 1,
          totalTransactions: 1,
          averageTransaction: { $divide: ['$totalSales', '$totalTransactions'] }
        }
      },
      {
        $sort: { totalSales: -1 }
      },
      {
        $limit: 5
      }
    ]);

    // Get top 5 vendors by transaction value
    const topVendors = await Expense.aggregate([
      {
        $match: {
          status: 'active',
          paidToModel: 'Vendor'
        }
      },
      {
        $group: {
          _id: '$paidTo',
          totalPurchases: { $sum: '$amount' },
          totalTransactions: { $sum: 1 }
        }
      },
      {
        $lookup: {
          from: 'vendors',
          localField: '_id',
          foreignField: '_id',
          as: 'vendor'
        }
      },
      {
        $unwind: '$vendor'
      },
      {
        $project: {
          _id: 1,
          name: '$vendor.name',
          totalPurchases: 1,
          totalTransactions: 1,
          averageTransaction: { $divide: ['$totalPurchases', '$totalTransactions'] }
        }
      },
      {
        $sort: { totalPurchases: -1 }
      },
      {
        $limit: 5
      }
    ]);

    // Calculate total expenses
    const expenseMetrics = await Expense.aggregate([
      {
        $match: {
          status: 'active'
        }
      },
      {
        $group: {
          _id: null,
          totalExpenses: { $sum: '$amount' }
        }
      }
    ]);

    // Format the response
    const metrics = {
      financial: {
        totalSales: salesMetrics[0]?.totalSales || 0,
        totalProfit: salesMetrics[0]?.totalProfit || 0,
        totalVat: salesMetrics[0]?.totalVat || 0,
        grossProfit: salesMetrics[0]?.grossProfit || 0,
        netProfit: (salesMetrics[0]?.totalProfit || 0) - (expenseMetrics[0]?.totalExpenses || 0),
        totalCredit: paymentMetrics.find(p => p._id === 'Cash')?.total || 0,
        totalDebit: paymentMetrics.find(p => p._id === 'Bank')?.total || 0,
        totalExpenses: expenseMetrics[0]?.totalExpenses || 0
      },
      topPerformers: {
        salesmen: topSalesmen,
        vendors: topVendors
      }
    };

    return metrics;
  } catch (error) {
    console.error('Error in getDashboardMetrics:', error);
    throw error;
  }
}

// Get metrics for a specific date range
export async function getDashboardMetricsForDateRange(startDate, endDate) {
  try {
    const dateMatch = {
      date: {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      }
    };

    // Get sales metrics for date range
    const salesMetrics = await SalesInvoice.aggregate([
      {
        $match: {
          ...dateMatch,
          status: { $ne: 'deleted' }
        }
      },
      {
        $group: {
          _id: null,
          totalSales: { $sum: '$totals.grandTotal' },
          totalProfit: { $sum: '$totals.totalProfit' },
          totalVat: { $sum: '$totals.totalVat' },
          grossProfit: { $sum: { $subtract: ['$totals.grandTotal', '$totals.totalCost'] } }
        }
      }
    ]);

    // Get payment metrics for date range
    const paymentMetrics = await SalesInvoice.aggregate([
      {
        $match: {
          ...dateMatch,
          status: { $ne: 'deleted' }
        }
      },
      {
        $unwind: '$payments'
      },
      {
        $group: {
          _id: '$payments.method',
          total: { $sum: '$payments.amount' }
        }
      }
    ]);

    // Get top salesmen for date range
    const topSalesmen = await SalesInvoice.aggregate([
      {
        $match: {
          ...dateMatch,
          status: { $ne: 'deleted' }
        }
      },
      {
        $group: {
          _id: '$salesmanId',
          totalSales: { $sum: '$totals.grandTotal' },
          totalTransactions: { $sum: 1 }
        }
      },
      {
        $lookup: {
          from: 'employees',
          localField: '_id',
          foreignField: '_id',
          as: 'employee'
        }
      },
      {
        $unwind: '$employee'
      },
      {
        $project: {
          _id: 1,
          name: '$employee.name',
          totalSales: 1,
          totalTransactions: 1,
          averageTransaction: { $divide: ['$totalSales', '$totalTransactions'] }
        }
      },
      {
        $sort: { totalSales: -1 }
      },
      {
        $limit: 5
      }
    ]);

    // Get top vendors for date range
    const topVendors = await Expense.aggregate([
      {
        $match: {
          ...dateMatch,
          status: 'active',
          paidToModel: 'Vendor'
        }
      },
      {
        $group: {
          _id: '$paidTo',
          totalPurchases: { $sum: '$amount' },
          totalTransactions: { $sum: 1 }
        }
      },
      {
        $lookup: {
          from: 'vendors',
          localField: '_id',
          foreignField: '_id',
          as: 'vendor'
        }
      },
      {
        $unwind: '$vendor'
      },
      {
        $project: {
          _id: 1,
          name: '$vendor.name',
          totalPurchases: 1,
          totalTransactions: 1,
          averageTransaction: { $divide: ['$totalPurchases', '$totalTransactions'] }
        }
      },
      {
        $sort: { totalPurchases: -1 }
      },
      {
        $limit: 5
      }
    ]);

    // Get expense metrics for date range
    const expenseMetrics = await Expense.aggregate([
      {
        $match: {
          ...dateMatch,
          status: 'active'
        }
      },
      {
        $group: {
          _id: null,
          totalExpenses: { $sum: '$amount' }
        }
      }
    ]);

    // Format the response
    const metrics = {
      financial: {
        totalSales: salesMetrics[0]?.totalSales || 0,
        totalProfit: salesMetrics[0]?.totalProfit || 0,
        totalVat: salesMetrics[0]?.totalVat || 0,
        grossProfit: salesMetrics[0]?.grossProfit || 0,
        netProfit: (salesMetrics[0]?.totalProfit || 0) - (expenseMetrics[0]?.totalExpenses || 0),
        totalCredit: paymentMetrics.find(p => p._id === 'Cash')?.total || 0,
        totalDebit: paymentMetrics.find(p => p._id === 'Bank')?.total || 0,
        totalExpenses: expenseMetrics[0]?.totalExpenses || 0
      },
      topPerformers: {
        salesmen: topSalesmen,
        vendors: topVendors
      },
      dateRange: {
        startDate,
        endDate
      }
    };

    return metrics;
  } catch (error) {
    console.error('Error in getDashboardMetricsForDateRange:', error);
    throw error;
  }
} 

================================================================================
// FILE: server\src\services\employeeService.js
================================================================================

// src/services/employeeService.js
import mongoose from 'mongoose';
import Employee from '../models/employee.model.js';

/**
 * Add a new employee
 * @param {Object} employeeData  { name, contact, role, hireDate, salary }
 */
export async function addEmployee(employeeData, auditContext) {

  const employee = new Employee(employeeData);
  
  // Set the audit context properly
  
  // employee.options = {
  //   actor: {
  //     id: auditContext.actor.id,
  //     model: auditContext.actor.model
  //   },
  //   ip: auditContext.ip,
  //   ua: auditContext.ua
  // };

  employee.$locals.audit = {
    actorId:    auditContext.actor.id,
    actorModel: auditContext.actor.model,
    ip:         auditContext.ip,
    ua:         auditContext.ua
  };
  
  const newEmp = await employee.save();
  return newEmp.toObject();
}

/**
 * List employees with filters, search, and pagination.
 * @param {Object} opts
 * @param {Object} opts.filters   { role, status }
 * @param {string} opts.search    matches name or contact.email
 * @param {number} opts.page      defaults to 1
 * @param {number} opts.limit     defaults to 10
 */
// export async function getAllEmployees({
//   filters = {},
//   search  = '',
//   page    = 1,
//   limit   = 10
// }, auditContext) {
//   const query = { ...filters };
//   if (search) {
//     query.$or = [
//       { name: { $regex: search, $options: 'i' } },
//       { 'contact.email': { $regex: search, $options: 'i' } },
//       { 'contact.phone': { $regex: search, $options: 'i' } }
//     ];
//   }

//   const skip = (page - 1) * limit;
//   const [ total, employees ] = await Promise.all([
//     Employee.countDocuments(query),
//     Employee.find(query)
//       .sort({ createdAt: -1 })
//       .skip(skip)
//       .limit(limit)
//       .setOptions({ 
//         actor: auditContext.actor,
//         ip: auditContext.ip,
//         ua: auditContext.ua
//       })
//   ]);

//   return {
//     employees,
//     pagination: {
//       total,
//       page,
//       limit,
//       totalPages:  Math.ceil(total / limit),
//       hasNextPage: page < Math.ceil(total / limit),
//       hasPrevPage: page > 1
//     }
//   };
// }

export async function getAllEmployees(
  { filters = {}, search = '', page = 1, limit = 10 } = {},
  /* auditContext (optional) */
) {
  // 1) Build the Mongo query
  const query = {};
  if (filters.role)   query.role   = filters.role;
  if (filters.status) query.status = filters.status;

  if (search) {
    const re = new RegExp(search, 'i');
    query.$or = [
      { name:           re },
      { 'contact.email':re },
      { 'contact.phone':re }
    ];
  }

  // 2) Pagination math
  const skip = (page - 1) * limit;

  // 3) Fire both count + find
  const [ total, employees ] = await Promise.all([
    Employee.countDocuments(query),
    Employee.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean()      // return plain JS objects
  ]);

  // 4) Package up your response
  return {
    employees,
    pagination: {
      total,
      page,
      limit,
      totalPages:  Math.ceil(total / limit),
      hasNextPage: page < Math.ceil(total / limit),
      hasPrevPage: page > 1
    }
  };
}

/**
 * Fetch a single employee by ID
 */
export async function getEmployeeById(id) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid employee ID');
  }
  const emp = await Employee.findById(id).lean();
  if (!emp) {
    throw new Error('Employee not found');
  }
  return emp;
}

/**
 * Update an employee's fields
 */
export async function updateEmployee(id, updateData, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid employee ID');
  }
  const emp = await Employee.findByIdAndUpdate(
    id,
    updateData,
    {
      new: true,
      runValidators: true,
      actor: auditContext.actor,
      ip: auditContext.ip,
      ua: auditContext.ua
    }
  )
  .lean();
  if (!emp) {
    throw new Error('Employee not found');
  }
  return emp;
}

/**
 * Soft-delete (deactivate) or hard-delete an employee.
 */
export async function deleteEmployee(id, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid employee ID');
  }

  let emp;

    emp = await Employee.findByIdAndDelete(
      id,
      {
        new: true,
        actor: auditContext.actor,
        ip: auditContext.ip,
        ua: auditContext.ua
      }
    )
    .lean();
  

  if (!emp) {
    throw new Error('Employee not found');
  }
  return emp;
}


================================================================================
// FILE: server\src\services\expenseService.js
================================================================================

// src/services/expenseService.js
import mongoose from 'mongoose';
import Expense from '../models/expense.model.js';
import CashRegister from '../models/cashRegister.model.js';
import * as cashService from './cashService.js';
import * as bankService from './bankService.js';

/**
 * Record a new expense or expense reversal.
 * @param {Object} data
 * @param {string} [data.date]            ISO date string (defaults to now)
 * @param {string} data.category          one of ['Rent','Utilities','Salaries','Commissions','Advances Recovered','Inventory','Miscellaneous']
 * @param {string} data.description       Free-text explanation of the expense
 * @param {number} data.amount            Positive number for normal expenses, negative for reversals
 * @param {string} data.paymentType       one of ['Cash','Bank','Shabka']
 * @param {string} [data.paidTo]          ObjectId of Employee or Vendor
 * @param {string} [data.paidToModel]     'Employee' or 'Vendor'
 * @param {string} [data.linkedTo]        ObjectId of SalesInvoice or SalesmanAdvance
 * @param {string} [data.linkedToModel]   'SalesInvoice' or 'SalesmanAdvance'
 */
export async function recordExpense(data, auditContext) {
  // Validate required fields
  if (!data.category) {
    throw new Error('Category is required');
  }
  if (!data.description) {
    throw new Error('Description is required');
  }
  if (data.amount === undefined || data.amount === null) {
    throw new Error('Amount is required');
  }
  if (!data.paymentType) {
    throw new Error('Payment type is required');
  }
  
  // Validate field values
  const validCategories = ['Rent','Utilities','Salaries','Commissions','Advances Recovered','Inventory','Miscellaneous'];
  if (!validCategories.includes(data.category)) {
    throw new Error(`Invalid category. Must be one of: ${validCategories.join(', ')}`);
  }
  
  const validPaymentTypes = ['Cash','Bank','Shabka'];
  if (!validPaymentTypes.includes(data.paymentType)) {
    throw new Error(`Invalid payment type. Must be one of: ${validPaymentTypes.join(', ')}`);
  }
  

  // If paidTo is provided, paidToModel is required
  if (data.paidTo) {
    if (!data.paidToModel) {
      throw new Error('paidToModel is required when paidTo is provided');
    }
    if (!['Employee','Vendor'].includes(data.paidToModel)) {
      throw new Error('paidToModel must be "Employee" or "Vendor"');
    }
    if (!mongoose.Types.ObjectId.isValid(data.paidTo)) {
      throw new Error('Invalid paidTo ID');
    }
  }
  
  // If linkedTo is provided, linkedToModel is required
  if (data.linkedTo) {
    if (!data.linkedToModel) {
      throw new Error('linkedToModel is required when linkedTo is provided');
    }
    if (!['SalesInvoice','SalesmanAdvance'].includes(data.linkedToModel)) {
      throw new Error('linkedToModel must be "SalesInvoice" or "SalesmanAdvance"');
    }
    if (!mongoose.Types.ObjectId.isValid(data.linkedTo)) {
      throw new Error('Invalid linkedTo ID');
    }
  }
  
  // Use existing session if provided, otherwise create one
  let session = auditContext.session;
  let ownSession = false;
  if (!session) {
    session = await mongoose.startSession();
    session.startTransaction();
    ownSession = true;
  }
  
  // Check for opening balances based on payment type
  if (data.paymentType === 'Cash') {
    // Check if cash opening balance exists
    const cashOpening = await CashRegister.findOne({ 
      type: 'Opening',
      status: 'active'
    }).session(session);
    
    if (!cashOpening) {
      throw new Error('Cash opening balance is required before recording cash expenses. Please create a cash opening balance first.');
    }
  } else if (data.paymentType === 'Bank' || data.paymentType === 'Shabka') {
    // Check if bank opening balance exists
    const BankTransaction = mongoose.model('BankTransaction');
    const bankOpening = await BankTransaction.findOne({ 
      type: 'Opening',
      status: 'active'
    }).session(session);
    
    if (!bankOpening) {
      throw new Error(`${data.paymentType} opening balance is required before recording ${data.paymentType.toLowerCase()} expenses. Please create a ${data.paymentType.toLowerCase()} opening balance first.`);
    }
  }
  
  try {
    // Create the expense record
    const expense = new Expense({
      date: data.date ? new Date(data.date) : new Date(),
      category: data.category,
      description: data.description,
      amount: data.amount,
      paymentType: data.paymentType,
      paidTo: data.paidTo,
      paidToModel: data.paidToModel,
      linkedTo: data.linkedTo,
      linkedToModel: data.linkedToModel
    });
    // Attach audit metadata via $locals.audit
    expense.$locals = expense.$locals || {};
    expense.$locals.audit = {
      actorId:    auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip:         auditContext.ip,
      ua:         auditContext.ua
    };
    
    // Save the expense with audit context
    const saved = await expense.save({ 
      session,
      actor: auditContext.actor,
      ip: auditContext.ip,
      ua: auditContext.ua
    });
    
    // Determine the ledger entry type (Inflow or Outflow)
    const entryType = data.amount < 0 ? 'Inflow' : 'Outflow';
    const entryAmount = Math.abs(data.amount);
    const reference = `Expense: ${data.description}`;
    
    // Record the ledger entry (cash or bank)
    let ledgerEntry;
    
    if (data.paymentType === 'Cash') {
      ledgerEntry = await cashService.recordCashEntry(
        {
          date: data.date || new Date(),
          type: entryType,
          reference: reference,
          amount: entryAmount
        },
        {
          session,
          actor: auditContext.actor,
          ip: auditContext.ip,
          ua: auditContext.ua
        }
      );
      
      // Store reference to the ledger entry
      saved.ledgerEntryId = ledgerEntry._id;
      saved.ledgerEntryModel = 'CashRegister';
      // Recalculate balances for all subsequent cash entries, except for Opening
      if (ledgerEntry.type !== 'Opening') {
        await cashService.recalculateBalancesFromDate(
          ledgerEntry.date,
          session,
          {
            actorId: auditContext.actor.id,
            actorModel: auditContext.actor.model,
            ip: auditContext.ip,
            ua: auditContext.ua
          }
        );
      }
      
    } else {
      // For Bank or Shabka payments
      ledgerEntry = await bankService.recordBankTransaction(
        {
          date: data.date || new Date(),
          type: entryType,
          method: data.paymentType,
          reference: reference,
          amount: entryAmount
        },
        {
          session,
          actor: auditContext.actor,
          ip: auditContext.ip,
          ua: auditContext.ua
        }
      );
      
      // Store reference to the ledger entry
      saved.ledgerEntryId = ledgerEntry._id;
      saved.ledgerEntryModel = 'BankTransaction';
      // Recalculate balances for all subsequent bank entries, except for Opening
      if (ledgerEntry.type !== 'Opening') {
        await bankService.recalculateBalancesFromDate(
          ledgerEntry.date,
          session,
          {
            actorId: auditContext.actor.id,
            actorModel: auditContext.actor.model,
            ip: auditContext.ip,
            ua: auditContext.ua
          }
        );
      }
    }
    
    // Update the expense with the ledger entry reference
    await Expense.findByIdAndUpdate(
      saved._id,
      { 
        ledgerEntryId: ledgerEntry._id,
        ledgerEntryModel: data.paymentType === 'Cash' ? 'CashRegister' : 'BankTransaction'
      },
      { 
        session,
        actor: auditContext.actor,
        ip: auditContext.ip,
        ua: auditContext.ua
      }
    );
    
    // Commit if we started the session
    if (ownSession) {
      await session.commitTransaction();
    }
    
    // Return the complete expense record with ledger references
    return {
      ...saved.toObject(),
      ledgerEntryId: ledgerEntry._id,
      ledgerEntryModel: data.paymentType === 'Cash' ? 'CashRegister' : 'BankTransaction'
    };
  } catch (err) {
    if (ownSession) {
      await session.abortTransaction();
    }
    throw err;
  } finally {
    if (ownSession) {
      session.endSession();
    }
  }
}

/**
 * List expenses with optional filters, pagination, and text search.
 * @param {Object} opts
 * @param {string} [opts.category]        - Filter by expense category
 * @param {string} [opts.paymentType]     - Filter by payment method (Cash, Bank, Shabka)
 * @param {string} [opts.paidToModel]     - Filter by payee type (Employee, Vendor)
 * @param {string} [opts.paidTo]          - Filter by specific payee ID
 * @param {string} [opts.search]          - Text search across description field
 * @param {string} [opts.from]            - Start date (ISO string)
 * @param {string} [opts.to]              - End date (ISO string)
 * @param {number} [opts.page=1]          - Page number for pagination
 * @param {number} [opts.limit=10]        - Items per page
 * @param {string} [opts.sortBy='date']   - Field to sort by
 * @param {string} [opts.sortOrder='desc'] - Sort order (asc or desc)
 */
export async function getAllExpenses({
  category,
  paymentType,
  paidToModel,
  paidTo,
  search,
  from,
  to,
  page = 1,
  limit = 10,
  sortBy = 'date',
  sortOrder = 'desc'
} = {}, auditContext) {
  const query = { status: 'active' };
  
  // Apply filters if provided
  if (category)    query.category    = category;
  if (paymentType) query.paymentType = paymentType;
  if (paidToModel) query.paidToModel = paidToModel;
  if (paidTo)      query.paidTo      = mongoose.Types.ObjectId.isValid(paidTo) ? paidTo : null;
  
  // Date range filter
  if (from || to) {
    query.date = {};
    if (from) query.date.$gte = new Date(from);
    if (to)   query.date.$lte = new Date(to);
  }
  
  // Text search - case insensitive
  if (search) {
    query.$or = [
      { description: { $regex: search, $options: 'i' } },
      // If the system has references to employees or vendors, we could expand this
      // to search their names as well through aggregation or lookups
    ];
  }

  // Determine sort direction
  const sortDirection = sortOrder === 'asc' ? 1 : -1;
  
  // Create sort object
  const sort = {};
  sort[sortBy] = sortDirection;
  
  // Always add secondary sort by date for consistency
  if (sortBy !== 'date') {
    sort.date = -1;
  }

  const skip = (page - 1) * limit;
  
  // Execute query with proper pagination
  const [ total, expenses ] = await Promise.all([
    Expense.countDocuments(query),
    Expense.find(query)
      .sort(sort)
      .skip(skip)
      .limit(limit)
      // Populate references for more complete data
      .populate('paidTo', 'name') // Assuming both Employee and Vendor have name field
      .populate('linkedTo')
      .populate('ledgerEntryId')
      .setOptions({
        actor: auditContext.actor,
        ip: auditContext.ip,
        ua: auditContext.ua
      })
      .lean()
  ]);

  return {
    expenses,
    pagination: {
      total,
      page,
      limit,
      totalPages:  Math.ceil(total / limit),
      hasNextPage: page < Math.ceil(total / limit),
      hasPrevPage: page > 1
    }
  };
}

/**
 * Fetch one expense by ID.
 * @param {string} id
 */
export async function getExpenseById(id, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid expense ID');
  }
  const exp = await Expense.findOne({ _id: id, status: 'active' })
    .populate('paidTo', 'name') // Assuming both Employee and Vendor have name field
    .populate('linkedTo')
    .populate('ledgerEntryId')
    .setOptions({
      actor: auditContext.actor,
      ip: auditContext.ip,
      ua: auditContext.ua
    })
    .lean();
  if (!exp) {
    throw new Error('Expense not found');
  }
  return exp;
}

/**
 * Update an expense.
 * @param {string} id
 * @param {Object} updateData  subset of 
 *    { date, category, description, amount, paymentType, paidTo, paidToModel, linkedTo, linkedToModel }
 */
export async function updateExpense(id, updateData, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid expense ID');
  }

  if (!auditContext?.actor?.id || !auditContext?.actor?.model) {
    throw new Error('Missing or invalid audit actor');
  }

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const currentExpense = await Expense.findById(id).session(session);
    if (!currentExpense) {
      throw new Error('Expense not found');
    }

    // === Validations ===
    const validCategories = ['Rent', 'Utilities', 'Salaries', 'Commissions', 'Advances Recovered', 'Inventory', 'Miscellaneous'];
    const validPaymentTypes = ['Cash', 'Bank', 'Shabka'];

    if (updateData.category && !validCategories.includes(updateData.category)) {
      throw new Error(`Invalid category. Must be one of: ${validCategories.join(', ')}`);
    }

    if (updateData.paymentType && !validPaymentTypes.includes(updateData.paymentType)) {
      throw new Error(`Invalid payment type. Must be one of: ${validPaymentTypes.join(', ')}`);
    }

    const paymentType = updateData.paymentType || currentExpense.paymentType;


    if (updateData.amount !== undefined && updateData.amount === 0) {
      throw new Error('Amount cannot be zero.');
    }

    if (updateData.paidTo && !updateData.paidToModel && !currentExpense.paidToModel) {
      throw new Error('paidToModel is required when paidTo is provided');
    }

    if (updateData.linkedTo && !updateData.linkedToModel && !currentExpense.linkedToModel) {
      throw new Error('linkedToModel is required when linkedTo is provided');
    }

    // === Ledger Update Logic ===
    // Only update ledger if paymentType, date, or amount has changed
    const paymentTypeChanged = updateData.paymentType !== undefined && updateData.paymentType !== currentExpense.paymentType;
    const dateChanged = updateData.date !== undefined && new Date(updateData.date).getTime() !== new Date(currentExpense.date).getTime();
    const amountChanged = updateData.amount !== undefined && updateData.amount !== currentExpense.amount;

    const needsLedgerUpdate = paymentTypeChanged || dateChanged || amountChanged;

    if (needsLedgerUpdate && currentExpense.ledgerEntryId) {
      const amount = updateData.amount !== undefined ? updateData.amount : currentExpense.amount;
      let date;
      if (updateData.date) {
        // Preserve the time component when updating the date
        const currentDate = new Date(currentExpense.date);
        const newDate = new Date(updateData.date);
        newDate.setHours(currentDate.getHours());
        newDate.setMinutes(currentDate.getMinutes());
        newDate.setSeconds(currentDate.getSeconds());
        newDate.setMilliseconds(currentDate.getMilliseconds());
        date = newDate;
      } else {
        date = currentExpense.date;
      }
      const category = updateData.category || currentExpense.category;
      const description = updateData.description || currentExpense.description;
      const reference = `Expense: ${category} - ${description}`;
      const entryType = amount >= 0 ? 'Outflow' : 'Inflow';
      const entryAmount = Math.abs(amount);
      // Always delete the old ledger entry to ensure proper balance recalculation
      if (currentExpense.ledgerEntryModel === 'CashRegister') {
        await cashService.deleteCashEntry(
          currentExpense.ledgerEntryId,
          { ...auditContext, session }
        );
      } else if (currentExpense.ledgerEntryModel === 'BankTransaction') {
        await bankService.deleteBankTransaction(
          currentExpense.ledgerEntryId,
          { ...auditContext, session }
        );
      }
      // Create new ledger entry
      let newLedgerEntry;
      if (paymentTypeChanged ? updateData.paymentType === 'Cash' : currentExpense.paymentType === 'Cash') {
        newLedgerEntry = await cashService.recordCashEntry(
          { date, type: entryType, reference, amount: entryAmount },
          { ...auditContext, session }
        );
        currentExpense.ledgerEntryId = newLedgerEntry._id;
        currentExpense.ledgerEntryModel = 'CashRegister';
        await cashService.recalculateBalancesFromDate(
          date,
          session,
          {
            actorId: auditContext.actor.id,
            actorModel: auditContext.actor.model,
            ip: auditContext.ip,
            ua: auditContext.ua
          }
        );
      } else {
        newLedgerEntry = await bankService.recordBankTransaction(
          { date, type: entryType, method: paymentTypeChanged ? updateData.paymentType : currentExpense.paymentType, reference, amount: entryAmount },
          { ...auditContext, session }
        );
        currentExpense.ledgerEntryId = newLedgerEntry._id;
        currentExpense.ledgerEntryModel = 'BankTransaction';
        await bankService.recalculateBalancesFromDate(
          date,
          session,
          {
            actorId: auditContext.actor.id,
            actorModel: auditContext.actor.model,
            ip: auditContext.ip,
            ua: auditContext.ua
          }
        );
      }
    }

    // === Apply Updates ===
    for (const field of [
      'category', 'description', 'date', 'amount', 'paymentType',
      'paidTo', 'paidToModel', 'linkedTo', 'linkedToModel'
    ]) {
      if (updateData[field] !== undefined) {
        currentExpense[field] = updateData[field];
      }
    }

    // === Audit Info ===
    currentExpense.$locals = {
      audit: {
        actorId: auditContext.actor.id,
        actorModel: auditContext.actor.model,
        ip: auditContext.ip,
        ua: auditContext.ua
      }
    };

    const saved = await currentExpense.save({ session });
    await session.commitTransaction();

    return saved.toObject();
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}
/**
 * Delete an expense and its associated ledger entry.
 * @param {string} id
 */
export async function deleteExpense(id, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid expense ID');
  }

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    // 1) Load the expense so we know which ledger row to remove
    const expense = await Expense.findById(id).session(session);
    if (!expense) {
      throw new Error('Expense not found');
    }

    // 2) If it has a linked ledger entry, remove & rebalance via your helpers
    if (expense.ledgerEntryId) {
      if (expense.ledgerEntryModel === 'CashRegister') {
        await cashService.deleteCashEntry(
          expense.ledgerEntryId,
          {
            session,
            actor: auditContext.actor,
            ip:    auditContext.ip,
            ua:    auditContext.ua
          }
        );
      } else if (expense.ledgerEntryModel === 'BankTransaction') {
        await bankService.deleteBankTransaction(
          expense.ledgerEntryId,
          {
            session,
            actor: auditContext.actor,
            ip:    auditContext.ip,
            ua:    auditContext.ua
          }
        );
      }
    }

    // 3) Soft delete the Expense itself
    expense.status = 'deleted';
    expense.$locals = expense.$locals || {};
    expense.$locals.audit = {
      actorId:    auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip:         auditContext.ip,
      ua:         auditContext.ua
    };
    await expense.save({ session });

    await session.commitTransaction();
    return expense.toObject();
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}


================================================================================
// FILE: server\src\services\invoiceService.js
================================================================================

// src/services/invoiceService.js
import mongoose from 'mongoose';
import SalesInvoice from '../models/salesInvoice.model.js';
import * as cashService from './cashService.js';
import * as bankService from './bankService.js';
import * as expenseService from './expenseService.js';
import CashRegister from '../models/cashRegister.model.js';
import BankTransaction from '../models/bankTransaction.model.js';

/**
 * Validates invoice data for creation and updates
 * @param {Object} data - Invoice data to validate
 * @throws {Error} If validation fails
 */
function validateInvoiceData(data) {
  // Check for required fields during creation
  if (!data.invoiceNumber) {
    throw new Error('Invoice number is required');
  }
  
  if (!data.salesmanId) {
    throw new Error('Salesman ID is required');
  }
  
  // Validate items
  if (!data.items || !Array.isArray(data.items) || data.items.length === 0) {
    throw new Error('Invoice must contain at least one item');
  }
  
  // Validate each item
  data.items.forEach((item, index) => {
    if (!item.description) {
      throw new Error(`Item at index ${index} is missing a description`);
    }
    
    if (typeof item.quantity !== 'number' || item.quantity <= 0) {
      throw new Error(`Item at index ${index} has an invalid quantity`);
    }
    
    if (typeof item.unitPrice !== 'number' || item.unitPrice < 0) {
      throw new Error(`Item at index ${index} has an invalid unit price`);
    }
    
    if (typeof item.costPrice !== 'number' || item.costPrice < 0) {
      throw new Error(`Item at index ${index} has an invalid cost price`);
    }
    
    if (item.vatAmount && (typeof item.vatAmount !== 'number' || item.vatAmount < 0)) {
      throw new Error(`Item at index ${index} has an invalid VAT amount`);
    }
  });
  
  // Validate payment data if provided
  if (data.payments && Array.isArray(data.payments)) {
    const validMethods = ['Cash', 'Bank', 'Shabka'];
    
    data.payments.forEach((payment, index) => {
      if (typeof payment.amount !== 'number' || payment.amount <= 0) {
        throw new Error(`Payment at index ${index} has an invalid amount`);
      }
      
      if (!validMethods.includes(payment.method)) {
        throw new Error(`Payment at index ${index} has an invalid method. Must be one of: ${validMethods.join(', ')}`);
      }
      

    });
  }
  
  // Validate status if provided
  if (data.status) {
    const validStatuses = ['Paid', 'Partially Paid', 'Unpaid', 'deleted'];
    if (!validStatuses.includes(data.status)) {
      throw new Error(`Invalid status. Must be one of: ${validStatuses.join(', ')}`);
    }
  }
}

/**
 * Validates status transitions
 * @param {string} currentStatus - Current invoice status
 * @param {string} newStatus - Proposed new status
 * @throws {Error} If transition is invalid
 */
function validateStatusTransition(currentStatus, newStatus) {
  const validTransitions = {
    'Unpaid': ['Partially Paid', 'Paid', 'deleted'],
    'Partially Paid': ['Paid', 'Unpaid', 'deleted'],
    'Paid': ['Partially Paid', 'Unpaid', 'deleted'],
    'deleted': []
  };
  
  if (!validTransitions[currentStatus].includes(newStatus)) {
    throw new Error(`Cannot transition from ${currentStatus} to ${newStatus}`);
  }
}

/**
 * Check if opening balances exist for cash and bank transactions
 * @throws {Error} If no opening balances exist
 */
async function validateOpeningBalances(session) {
  // Check for cash opening balance
  const cashOpening = await CashRegister.findOne({ 
    type: 'Opening',
    status: 'active'
  }).session(session);

  // Check for bank opening balance
  const bankOpening = await BankTransaction.findOne({ 
    type: 'Opening',
    status: 'active'
  }).session(session);

  if (!cashOpening && !bankOpening) {
    throw new Error('No opening balances found. Please create opening balances for cash and/or bank accounts before creating invoices.');
  }
}

/**
 * Create a new sales invoice, computing totals and profit.
 * @param {Object} data  {
 *   invoiceNumber,
 *   date,
 *   customerName,
 *   salesmanId,
 *   items: [{ description, quantity, unitPrice, costPrice, vatAmount }],
 *   payments?: [{ date?, method, amount }],
 *   status?         // defaults to "Unpaid"
 * }
 */
export async function createInvoice(data, auditContext) {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    // Validate invoice data
    validateInvoiceData(data);
    
    // Check for opening balances
    await validateOpeningBalances(session);
    
    // Check for duplicate invoice number
    const existingInvoice = await SalesInvoice.findOne({ 
      invoiceNumber: data.invoiceNumber,
      status: { $ne: 'deleted' }
    });
    
    if (existingInvoice) {
      throw new Error(`Invoice number ${data.invoiceNumber} already exists`);
    }

    // 1) Compute item lineTotals
    const items = data.items.map(item => ({
      ...item,
      lineTotal: item.unitPrice * item.quantity + (item.vatAmount || 0)
    }));

    // 2) Compute totals
    const subTotal   = items.reduce((sum, i) => sum + i.unitPrice * i.quantity, 0);
    const totalVat   = items.reduce((sum, i) => sum + (i.vatAmount || 0), 0);
    const grandTotal = subTotal + totalVat;
    const totalCost  = items.reduce((sum, i) => sum + i.costPrice * i.quantity, 0);
    const totalProfit= subTotal - totalCost;

    // Validate calculated totals
    if (grandTotal <= 0) {
      throw new Error('Invoice total amount must be greater than zero');
    }

    // 3) Build invoice
    const inv = new SalesInvoice({
      invoiceNumber: data.invoiceNumber,
      date:          data.date || new Date(),
      customerName:  data.customerName,
      salesmanId:    data.salesmanId,
      items,
      totals: {
        subTotal, totalVat, grandTotal, totalCost, totalProfit
      },
      payments: [],
      status:   data.status || 'Unpaid'
    });

    // 4) Set audit metadata
    inv.$locals = inv.$locals || {};
    inv.$locals.audit = {
      actorId:    auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip:         auditContext.ip,
      ua:         auditContext.ua
    };

    // 5) Save invoice
    const saved = await inv.save({ session });

    // 6) Handle any initial payments
    if (data.payments && data.payments.length > 0) {
      let paidAmt = 0;
      
      for (const pay of data.payments) {
        // Validate payment amount
        if (typeof pay.amount !== 'number' || pay.amount <= 0) {
          throw new Error('Payment amount must be positive');
        }
        
        // Validate total payments don't exceed invoice total
        if (paidAmt + pay.amount > grandTotal) {
          throw new Error(`Total payments (${paidAmt + pay.amount}) exceed invoice total (${grandTotal})`);
        }
        
        const paymentDate = pay.date || new Date();
        const reference = `Payment for Invoice ${inv.invoiceNumber}`;
        
        // Record payment in invoice with unique ID
        saved.payments.push({
          id: new mongoose.Types.ObjectId().toString(),
          date: paymentDate,
          amount: pay.amount,
          method: pay.method,
          status: 'completed'
        });
        
        // Record in appropriate ledger
        if (pay.method === 'Cash') {
          await cashService.recordCashEntry(
            {
              date: paymentDate,
              type: 'Inflow',
              reference,
              amount: pay.amount
            },
            {
              session,
              actor: auditContext.actor,
              ip: auditContext.ip,
              ua: auditContext.ua
            }
          );
        } else {
          await bankService.recordBankTransaction(
            {
              date: paymentDate,
              type: 'Inflow',
              method: pay.method,
              reference,
              amount: pay.amount
            },
            {
              session,
              actor: auditContext.actor,
              ip: auditContext.ip,
              ua: auditContext.ua
            }
          );
        }
        
        paidAmt += pay.amount;
      }
      
      // Update status based on payment amount
      if (paidAmt >= grandTotal) {
        saved.status = 'Paid';
      } else if (paidAmt > 0) {
        saved.status = 'Partially Paid';
      }
      
      await saved.save({ session });
    }

    await session.commitTransaction();
    return saved.toObject();
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}

/**
 * List invoices with optional filters, pagination, and date range.
 * @param {Object} opts  { filters:{ status, salesmanId }, from, to, page=1, limit=10, includeDeleted=false }
 */
export async function getAllInvoices({
  filters = {},
  from,
  to,
  page = 1,
  limit = 10,
  includeDeleted = false,
  sort = '-createdAt'
} = {}) {
  const query = {};
  
  // Apply filters
  if (filters.status) {
    query.status = filters.status;
  } else if (!includeDeleted) {
    // By default, exclude deleted invoices
    query.status = { $ne: 'deleted' };
  }
  
  if (filters.salesmanId) {
    if (!mongoose.Types.ObjectId.isValid(filters.salesmanId)) {
      throw new Error('Invalid salesman ID');
    }
    query.salesmanId = filters.salesmanId;
  }

  // Add customer name filter with case-insensitive regex
  if (filters.customerName) {
    query.customerName = { $regex: filters.customerName, $options: 'i' };
  }
  
  // Apply date range
  if (from || to) {
    query.date = {};
    if (from) query.date.$gte = new Date(from);
    if (to) query.date.$lte = new Date(to);
  }

  // Parse sort parameter into MongoDB format
  let sortCriteria = {};
  if (sort) {
    // Handle multiple sort fields, e.g. '-date,customerName'
    const sortFields = sort.split(',');
    sortFields.forEach(field => {
      const direction = field.startsWith('-') ? -1 : 1;
      const fieldName = field.startsWith('-') ? field.substring(1) : field;
      sortCriteria[fieldName] = direction;
    });
  }
  
  const skip = (page - 1) * limit;
  const [ total, invoices ] = await Promise.all([
    SalesInvoice.countDocuments(query),
    SalesInvoice.find(query)
      .populate('salesmanId', 'name contact')
      .sort(sortCriteria)
      .skip(skip)
      .limit(limit)
      .lean()
  ]);

  return {
    invoices,
    pagination: {
      total,
      page,
      limit,
      totalPages:  Math.ceil(total / limit),
      hasNextPage: page < Math.ceil(total / limit),
      hasPrevPage: page > 1
    }
  };
}

/**
 * Fetch a single invoice by ID.
 */
export async function getInvoiceById(id) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid invoice ID');
  }
  const inv = await SalesInvoice.findById(id)
    .populate('salesmanId', 'name contact')
    .lean();
  if (!inv) {
    throw new Error('Invoice not found');
  }
  return inv;
}

/**
 * Update an invoice's mutable fields.
 * @param {string} id
 * @param {Object} data  {
 *   items?: [{ description, quantity, unitPrice, costPrice, vatAmount }],
 *   status?: string,
 *   customerName?: string,
 *   date?: Date
 * }
 */
export async function updateInvoice(id, data, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid invoice ID');
  }

  // Validate update data for items
  if (data.items && (!Array.isArray(data.items) || data.items.length === 0)) {
    throw new Error('Invoice must contain at least one item');
  }
  
  if (data.items) {
    // Validate each item
    data.items.forEach((item, index) => {
      if (!item.description) {
        throw new Error(`Item at index ${index} is missing a description`);
      }
      
      if (typeof item.quantity !== 'number' || item.quantity <= 0) {
        throw new Error(`Item at index ${index} has an invalid quantity`);
      }
      
      if (typeof item.unitPrice !== 'number' || item.unitPrice < 0) {
        throw new Error(`Item at index ${index} has an invalid unit price`);
      }
      
      if (typeof item.costPrice !== 'number' || item.costPrice < 0) {
        throw new Error(`Item at index ${index} has an invalid cost price`);
      }
      
      if (item.vatAmount && (typeof item.vatAmount !== 'number' || item.vatAmount < 0)) {
        throw new Error(`Item at index ${index} has an invalid VAT amount`);
      }
    });
  }

  // Enforce immutable payment history
  if (data.payments) {
    throw new Error('Direct payment editing is not allowed. Use addPayment endpoint instead.');
  }

  try {
    // STEP 1: First fetch and validate invoice without a session
    const invoiceCheck = await SalesInvoice.findById(id);
    
    if (!invoiceCheck) {
      throw new Error('Invoice not found');
    }
    
    if (invoiceCheck.status === 'deleted') {
      throw new Error('Cannot update a deleted invoice');
    }
    
    const hasPaidStatus = invoiceCheck.status === 'Paid' || invoiceCheck.status === 'Partially Paid';
    
    if (hasPaidStatus) {
      throw new Error('This invoice cannot be updated because it has payments recorded. Please delete this invoice and create a new one instead.');
    }
    
    // Enforce status integrity
    if (data.status) {
      throw new Error('Status cannot be updated directly; it is derived from payments.');
    }
    
    // STEP 2: Now get a fresh copy of the document to modify
    const current = await SalesInvoice.findById(id);
    
    // Basic fields
    if (data.customerName) current.customerName = data.customerName;
    if (data.date) current.date = data.date;
    
    // Complex item update with recalculation requires more work
    if (data.items) {
      // Compute all the derived values
      const items = data.items.map(item => ({
        ...item,
        lineTotal: item.unitPrice * item.quantity + (item.vatAmount || 0)
      }));
      
      const subTotal = items.reduce((sum, i) => sum + i.unitPrice * i.quantity, 0);
      const totalVat = items.reduce((sum, i) => sum + (i.vatAmount || 0), 0);
      const grandTotal = subTotal + totalVat;
      const totalCost = items.reduce((sum, i) => sum + i.costPrice * i.quantity, 0);
      const totalProfit = subTotal - totalCost;
      
      // Validate calculated totals
      if (grandTotal <= 0) {
        throw new Error('Invoice total amount must be greater than zero');
      }
      
      // Get current paid amount
      const currentPaidAmt = current.payments.reduce((sum, p) => sum + p.amount, 0);
      
      // Ensure new total isn't less than what's already been paid
      if (grandTotal < currentPaidAmt) {
        throw new Error(`New invoice total (${grandTotal}) is less than the amount already paid (${currentPaidAmt})`);
      }
      
      // Set all the calculated fields
      current.items = items;
      current.totals = {
        subTotal,
        totalVat,
        grandTotal,
        totalCost,
        totalProfit
      };

       // Update status based on payment
       if (currentPaidAmt >= grandTotal) {
        current.status = 'Paid';
      } else if (currentPaidAmt > 0) {
        current.status = 'Partially Paid';
      } else {
        current.status = 'Unpaid';
      }
    }
    
    // Set audit context
    current.$locals = {
      audit: {
        actorId: auditContext.actor.id,
        actorModel: auditContext.actor.model,
        ip: auditContext.ip,
        ua: auditContext.ua
      }
    };
    
    await current.save();
    
    return current.toObject();
  } catch (error) {
    // Improve error messages for common scenarios
    if (error.name === 'ValidationError') {
      throw new Error(`Validation error: ${error.message}`);
    } else if (error.name === 'MongoServerError' && error.code === 11000) {
      throw new Error('Duplicate key error. This invoice may conflict with an existing one.');
    } else {
      // Log the error for debugging but throw a clean version to the client
      console.error('Error updating invoice:', error);
      throw error;
    }
  }
}

/**
 * Delete an invoice and handle all cascading effects:
 * 1. Reverse any payments (cash or bank)
 * 2. Soft-delete the invoice record
 */
export async function deleteInvoice(id, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid invoice ID');
  }

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    // 1. Get the invoice with all details
    const invoice = await SalesInvoice.findById(id)
      .session(session)
      .setOptions({
        actor: auditContext.actor,
        ip: auditContext.ip,
        ua: auditContext.ua
      });

    if (!invoice) {
      throw new Error('Invoice not found');
    }
    
    // Check if invoice is already deleted
    if (invoice.status === 'deleted') {
      throw new Error('Invoice is already deleted');
    }

    // Store invoice details for reference and return value
    const invoiceData = invoice.toObject();

    // 2. Reverse all payments recorded for this invoice
    for (const payment of invoice.payments) {
      const reversalDate = new Date();
      const reversalReference = `Reversal of payment for deleted invoice ${invoice.invoiceNumber}`;
      
      if (payment.method === 'Cash') {
        // Create a reversal cash entry with correct audit metadata
        await cashService.recordCashEntry(
          {
            date: reversalDate,
            type: 'Outflow',
            reference: reversalReference,
            amount: payment.amount
          },
          { 
            session,
            actor: auditContext.actor,
            ip: auditContext.ip,
            ua: auditContext.ua
          }
        );
      } else {
        // Create a reversal bank entry with correct audit metadata
        await bankService.recordBankTransaction(
          {
            date: reversalDate,
            type: 'Outflow',
            method: payment.method,
            reference: reversalReference,
            amount: payment.amount
          },
          { 
            session,
            actor: auditContext.actor,
            ip: auditContext.ip,
            ua: auditContext.ua
          }
        );
      }
    }
    
    // Clear all payments since they've been reversed
    invoice.payments = [];

    // 3. Soft-delete the invoice
    invoice.status = 'deleted';
    invoice.deletedAt = new Date();
    
    // Set audit context
    invoice.$locals = {
      audit: {
        actorId: auditContext.actor.id,
        actorModel: auditContext.actor.model,
        ip: auditContext.ip,
        ua: auditContext.ua
      }
    };
    
    await invoice.save({ session });
    await session.commitTransaction();
    
    // Add deletion info to the returned data
    invoiceData.status = 'deleted';
    invoiceData.deletedAt = new Date();
    
    return invoiceData;
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}

// Add a payment, update invoice status, and record cash/bank ledger entry
export async function addPayment(
  invoiceId,
  { amount, method, account, date },
  auditContext
) {
  if (!mongoose.Types.ObjectId.isValid(invoiceId)) {
    throw new Error('Invalid invoice ID');
  }
  
  // Validate amount is positive
  if (!amount || amount <= 0) {
    throw new Error('Payment amount must be positive');
  }
  
  // Validate payment method
  const validMethods = ['Cash', 'Bank', 'Shabka'];
  if (!validMethods.includes(method)) {
    throw new Error(`Invalid payment method. Must be one of: ${validMethods.join(', ')}`);
  }
  
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    // Find invoice and lock it for update
    const inv = await SalesInvoice.findById(invoiceId)
      .session(session)
      .setOptions({ 
        actor: auditContext.actor, 
        ip: auditContext.ip, 
        ua: auditContext.ua 
      });
      
    if (!inv) throw new Error('Invoice not found');
    
    // Check if invoice is deleted
    if (inv.status === 'deleted') {
      throw new Error('Cannot add payment to a deleted invoice');
    }

    // Calculate the current amount already paid
    const currentPaidAmt = inv.payments.reduce((sum, p) => sum + p.amount, 0);
    const grandTotal = inv.totals.grandTotal;
    const remainingAmount = grandTotal - currentPaidAmt;

    // Fix floating point precision for comparison
    const round2 = n => Math.round((n + Number.EPSILON) * 100) / 100;
    if (round2(amount) > round2(remainingAmount)) {
      throw new Error(`Payment amount (${round2(amount)}) exceeds the remaining balance (${round2(remainingAmount)})`);
    }

    // Standardize date handling
    const paymentDate = date ? new Date(date) : new Date();
    
    // Generate a unique ID for the payment
    const paymentId = new mongoose.Types.ObjectId().toString();
    
    // Append payment
    inv.payments.push({
      id: paymentId,
      date: paymentDate,
      amount,
      method
    });

    // Recalculate status
    const paidAmt = currentPaidAmt + amount;
    if (paidAmt >= grandTotal) {
      // Check if status transition is valid
      validateStatusTransition(inv.status, 'Paid');
      inv.status = 'Paid';
    } else if (paidAmt > 0) {
      // Check if status transition is valid
      validateStatusTransition(inv.status, 'Partially Paid');
      inv.status = 'Partially Paid';
    }

    // Set audit metadata
    inv.$locals = {
      audit: {
        actorId: auditContext.actor.id,
        actorModel: auditContext.actor.model,
        ip: auditContext.ip,
        ua: auditContext.ua
      }
    };
    
    // Save invoice changes
    await inv.save({ session });

    // Record ledger entry within the same transaction
    const reference = `Payment for Invoice ${inv.invoiceNumber}`;
    
    if (method === 'Cash') {
      await cashService.recordCashEntry(
        { 
          date: paymentDate, 
          type: 'Inflow', 
          reference, 
          amount 
        },
        {
          session,
          actor: auditContext.actor,
          ip: auditContext.ip,
          ua: auditContext.ua
        }
      );
    } else {
      await bankService.recordBankTransaction(
        { 
          date: paymentDate, 
          type: 'Inflow', 
          method, 
          reference, 
          amount 
        },
        {
          session,
          actor: auditContext.actor,
          ip: auditContext.ip,
          ua: auditContext.ua
        }
      );
    }
    
    // Commit the transaction only after all operations succeed
    await session.commitTransaction();
    
    // Return a fresh copy of the invoice with all updates applied
    const updatedInvoice = await SalesInvoice.findById(invoiceId)
      .populate('salesmanId', 'name contact')
      .lean();
      
    return updatedInvoice;
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}

/**
 * Reverse a specific payment on an invoice and update all related records
 * @param {string} invoiceId - The ID of the invoice
 * @param {string} paymentId - The ID of the payment to reverse
 * @param {string} reason - The reason for the reversal
 * @param {Object} auditContext - The audit context
 * @returns {Object} The updated invoice
 */
export async function reversePayment(
  invoiceId,
  paymentId,
  reason,
  auditContext
) {
  if (!mongoose.Types.ObjectId.isValid(invoiceId)) {
    throw new Error('Invalid invoice ID');
  }
  
  if (!paymentId) {
    throw new Error('Payment ID is required');
  }
  
  if (!reason) {
    throw new Error('Reason for reversal is required');
  }
  
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    // Find invoice and lock it for update
    const inv = await SalesInvoice.findById(invoiceId)
      .session(session)
      .setOptions({ 
        actor: auditContext.actor, 
        ip: auditContext.ip, 
        ua: auditContext.ua 
      });
      
    if (!inv) throw new Error('Invoice not found');
    
    // Check if invoice is deleted
    if (inv.status === 'deleted') {
      throw new Error('Cannot reverse payment on a deleted invoice');
    }
    
    // Find the payment to reverse
    const paymentIndex = inv.payments.findIndex(p => p.id === paymentId);
    if (paymentIndex === -1) {
      throw new Error('Payment not found');
    }
    
    const payment = inv.payments[paymentIndex];
    
    // Remove the payment from the array
    inv.payments.splice(paymentIndex, 1);
    
    // Recalculate total paid amount
    const currentPaidAmt = inv.payments.reduce((sum, p) => sum + p.amount, 0);
    
    // Update invoice status based on new payment total
    const grandTotal = inv.totals.grandTotal;
    if (currentPaidAmt >= grandTotal) {
      inv.status = 'Paid';
    } else if (currentPaidAmt > 0) {
      inv.status = 'Partially Paid';
    } else {
      inv.status = 'Unpaid';
    }
    
    // Set audit metadata
    inv.$locals = {
      audit: {
        actorId: auditContext.actor.id,
        actorModel: auditContext.actor.model,
        ip: auditContext.ip,
        ua: auditContext.ua
      }
    };
    
    // Save invoice changes
    await inv.save({ 
      session, 
      actor: auditContext.actor, 
      ip: auditContext.ip, 
      ua: auditContext.ua 
    });
    
    // Create a reversal entry in the appropriate ledger
    const reversalReference = `Reversal of payment for Invoice ${inv.invoiceNumber}: ${reason}`;
    
    if (payment.method === 'Cash') {
      await cashService.recordCashEntry(
        { 
          date: new Date(), 
          type: 'Outflow', 
          reference: reversalReference, 
          amount: payment.amount 
        },
        {
          session,
          actor: auditContext.actor,
          ip: auditContext.ip,
          ua: auditContext.ua
        }
      );
    } else {
      await bankService.recordBankTransaction(
        { 
          date: new Date(), 
          type: 'Outflow', 
          method: payment.method, 
          reference: reversalReference, 
          amount: payment.amount 
        },
        {
          session,
          actor: auditContext.actor,
          ip: auditContext.ip,
          ua: auditContext.ua
        }
      );
    }
    
    // Commit transaction
    await session.commitTransaction();
    
    // Return updated invoice
    const updatedInvoice = await SalesInvoice.findById(invoiceId)
      .populate('salesmanId', 'name contact')
      .lean();
      
    return updatedInvoice;
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}


================================================================================
// FILE: server\src\services\payrollService.js
================================================================================

// src/services/payrollService.js
import mongoose from 'mongoose';
import Employee         from '../models/employee.model.js';
import SalesInvoice     from '../models/salesInvoice.model.js';
import SalesmanAdvance  from '../models/salesmanAdvance.model.js';
import * as expenseService from './expenseService.js';
import * as bankService from './bankService.js';
import * as invoiceService from './invoiceService.js';

const DEFAULT_BANK_ACCOUNT = process.env.DEFAULT_BANK_ACCOUNT || 'Main';

/**
 * Run payroll for a given month/year:
 *  - salary + all commission.balanceDue
 *  - minus all advances taken
 *  - records two Expense entries per salesman
 *  - marks those advances as recovered
 *  - updates each invoice to mark commissions as paid
 *
 * @param {Object} opts
 * @param {number} opts.month         112
 * @param {number} opts.year          full year, e.g. 2025
 * @param {string} [opts.paymentDate]  ISO date string for the expense entries; defaults to month's end
 * @returns {Promise<Array>} Array of { salesmanId, name, salary, totalCommission, totalAdvances, netPay }
 */
export async function runPayroll({ month, year, paymentDate }, auditContext) {
  // 1) Compute date window
  const start = new Date(year, month - 1, 1);
  const end   = paymentDate
    ? new Date(paymentDate)
    : new Date(year, month, 0, 23, 59, 59);

  // 2) Find active salesmen
  const salesmen = await Employee.find({
    role: 'salesman',
    status: 'active'
  })
  .setOptions({
    actor: auditContext.actor,
    ip: auditContext.ip,
    ua: auditContext.ua
  })
  .lean();

  const results = [];

  for (const s of salesmen) {
    const sid = s._id;

    // 3) Find all invoices with outstanding commissions for this salesperson
    const invoicesWithCommission = await SalesInvoice.find({
      salesmanId: sid,
      date: { $gte: start, $lte: end },
      "commission.eligible": true,
      "commission.balanceDue": { $gt: 0 }
    }).lean();
    
    let totalCommission = 0;
    
    // Process each invoice with outstanding commission
    for (const invoice of invoicesWithCommission) {
      const commissionAmount = invoice.commission.balanceDue;
      totalCommission += commissionAmount;
      
      // Mark the commission as paid on the invoice
      try {
        await invoiceService.updateCommissionPayment(
          invoice._id,
          {
            amount: commissionAmount,
            method: 'Bank',
            date: end,
            note: `Commission paid as part of payroll for ${month}/${year}`
          },
          auditContext
        );
      } catch (err) {
        console.error(`Failed to update commission payment for invoice ${invoice._id}:`, err);
        // Continue processing other invoices even if one fails
      }
    }

    // 4) Sum up advances in period (unrecovered)
    const advAgg = await SalesmanAdvance.aggregate([
      { $match: {
          salesmanId: sid,
          date:       { $gte: start, $lte: end },
          recovered:  false
        }
      },
      { $group: {
          _id: null,
          totalAdvances: { $sum: '$amount' }
        }
      }
    ]);

    const totalAdvances = advAgg[0]?.totalAdvances || 0;

    // 5) Compute net pay
    const salary = s.salary;
    const gross   = salary + totalCommission;
    const netPay  = gross - totalAdvances;

    // 6) Record Expenses
    const payDate = end;
    // Salary expense & ledger
    const salaryExp = await expenseService.recordExpense({
      date:        payDate,
      category:    'Salaries',
      description: `Salary for ${s.name} (${month}/${year})`,
      amount:      salary,
      paymentType: 'Bank',
      paidTo:      sid,
      paidToModel: 'Employee'
    }, auditContext);

    // Advances (if any) expense & ledger
    if (totalAdvances > 0) {
      const advExp = await expenseService.recordExpense({
        date:        payDate,
        category:    'Advances Recovered',
        description: `Advances recovered from ${s.name} (${month}/${year})`,
        amount:      totalAdvances,
        paymentType: 'Bank',
        paidTo:      sid,
        paidToModel: 'Employee'
      }, auditContext);
    }

    // 7) Mark advances as recovered
    await SalesmanAdvance.updateMany(
      {
        salesmanId: sid,
        date:       { $gte: start, $lte: end },
        recovered:  false
      },
      { recovered: true },
      {
        actor: auditContext.actor,
        ip: auditContext.ip,
        ua: auditContext.ua
      }
    );

    // 8) Add to results
    results.push({
      salesmanId:     sid,
      name:          s.name,
      salary,
      totalCommission,
      totalAdvances,
      netPay
    });
  }

  return results;
}


================================================================================
// FILE: server\src\services\reportService.js
================================================================================

// src/services/reportService.js
import mongoose from 'mongoose';

/**
 * Produce a financial summary between two dates, grouping credits vs debits
 * by description (all in SAR), plus overall totals.
 *
 * @param {Object} opts
 * @param {string} opts.from   ISO date string (inclusive)
 * @param {string} opts.to     ISO date string (inclusive)
 * @returns {Promise<Object>} { summary: Array, totals: { creditSAR, debitSAR } }
 */
export async function getMonthlySummary({ from, to }, auditContext) {
  const start = new Date(from);
  const end   = new Date(to);

  // Use the raw collection for unionWith
  const coll = mongoose.connection.collection('cashregister');

  const pipeline = [
    // 1) Opening Balances Only
    { $match: { 
        type: 'Opening',
        status: 'active'
    }},
    { $project: {
        desc: 'Opening Balance - Cash',
        type: 'credit',
        amount: '$amount'
      }
    },

    // 2) Union Bank Opening Balances
    { $unionWith: {
        coll: 'banktransactions',
        pipeline: [
          { $match: { 
              type: 'Opening',
              status: 'active'
          }},
          { $project: {
              desc: { $concat: ['Opening Balance - ', { $ifNull: ['$method', 'Bank'] }] },
              type: 'credit',
              amount: '$amount'
            }
          }
        ]
      }
    },

    // 3) Union Sales Invoices - Only show payments
    { $unionWith: {
        coll: 'salesinvoices',
        pipeline: [
          { $match: { 
              date: { $gte: start, $lte: end },
              status: { $ne: 'deleted' },
              'payments.0': { $exists: true }  // Only invoices with payments
          }},
          // Unwind payments to handle each separately
          { $unwind: '$payments' },
          { $project: {
              desc: {
                $concat: [
                  'Sale Payment - Invoice #',
                  '$invoiceNumber',
                  ' (',
                  '$payments.method',
                  ')'
                ]
              },
              type: 'credit',
              amount: '$payments.amount'
          }}
        ]
      }
    },

    // 4) Union Vendor Transactions - only active entries
    { $unionWith: {
        coll: 'vendortransactions',
        pipeline: [
          { $match: { 
              date: { $gte: start, $lte: end },
              status: { $ne: 'deleted' }
          }},
          { $project: {
              desc: { 
                $cond: [
                  { $eq: ['$type', 'Purchase'] },
                  { $concat: ['Vendor Purchase: ', '$description'] },
                  { $concat: ['Vendor Payment: ', '$description, ', { $ifNull: ['$method', ''] }] }
                ]
              },
              type: {
                $cond: [
                  { $eq: ['$type', 'Purchase'] },
                  'debit',    // Purchase increases payable (debit)
                  'debit'     // Payment decreases cash/bank (debit)
                ]
              },
              amount: '$amount'
            }
          }
        ]
      }
    },

    // 5) Union Expense entries - only active entries
    { $unionWith: {
        coll: 'expenses',
        pipeline: [
          { $match: { 
              date: { $gte: start, $lte: end },
              status: { $ne: 'deleted' }
          }},
          { $project: {
              desc: {
                $concat: [
                  'Expense: ',
                  '$description',
                  ' (',
                  { $ifNull: ['$paymentType', 'Cash'] },
                  ')'
                ]
              },
              type: 'debit',
              amount: '$amount'
            }
          }
        ]
      }
    },

    // 6) Group by description & type
    { $group: {
        _id: { desc: '$desc', type: '$type' },
        total: { $sum: '$amount' }
      }
    },

    // 7) Shape into friendly docs
    { $project: {
        _id: 0,
        description: '$_id.desc',
        type: '$_id.type',
        totalSAR: '$total'
      }
    },

    // 8) Sort for consistent display - put opening balances first
    { $sort: { 
        description: {
          $cond: [
            { $regexMatch: { input: "$description", regex: /^Opening Balance/ } },
            0,
            1
          ]
        },
        type: -1,  // Credits before debits
        description: 1
    }}
  ];

  const summary = await coll.aggregate(pipeline).toArray();

  // Compute grand totals
  let creditSAR = 0, debitSAR = 0;
  for (const row of summary) {
    if (row.type === 'credit') creditSAR += row.totalSAR;
    else                       debitSAR  += row.totalSAR;
  }

  return {
    summary,
    totals: { creditSAR, debitSAR }
  };
}


================================================================================
// FILE: server\src\services\salaryService.js
================================================================================

import mongoose from 'mongoose';
import Employee from '../models/employee.model.js';
import SalaryPayment from '../models/salaryPayment.model.js';
import * as expenseService from './expenseService.js';

/**
 * Add a salary payment entry for an employee
 */
export async function addSalaryPayment(data, auditContext) {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const {
      employeeId,
      type,
      amount,
      description,
      paymentMethod,
      date = new Date()
    } = data;

    // 1. Validate employee exists and is active
    const employee = await Employee.findOne({ 
      _id: employeeId,
      status: 'active'
    })
    .session(session);

    // Set audit context for employee
    employee.$locals = {
      audit: {
        actorId: auditContext.actor.id,
        actorModel: auditContext.actor.model,
        ip: auditContext.ip,
        ua: auditContext.ua
      }
    };

    if (!employee) {
      throw new Error('Employee not found or inactive');
    }

    // 2. Create expense entry only for actual salary payments
    let expense = null;
    if (type === 'Salary Payment' || type === 'Advance Salary') {
      if (!paymentMethod) {
        throw new Error('Payment method is required for salary payments');
      }
      expense = await expenseService.recordExpense({
        date,
        category: type === 'Salary Payment' ? 'Salaries' : 'Advances',
        description,
        amount: -Math.abs(amount), // Ensure it's always negative for outflow
        paymentType: paymentMethod,
        paidTo: employeeId,
        paidToModel: 'Employee'
      }, {
        session,
        actor: auditContext.actor,
        ip: auditContext.ip,
        ua: auditContext.ua
      });
    }

    // 3. Create salary payment entry
    const payment = new SalaryPayment({
      employeeId,
      date,
      type,
      amount,
      description,
      ...((['Salary Payment', 'Advance Salary'].includes(type) && paymentMethod) && { paymentMethod }),
      expenseId: expense?._id // Only set if expense was created
    });

    // Set audit context for payment
    payment.$locals = {
      audit: {
        actorId: auditContext.actor.id,
        actorModel: auditContext.actor.model,
        ip: auditContext.ip,
        ua: auditContext.ua
      }
    };

    await payment.save({ session });

    // 4. Update employee's salary based on payment type
    if (type === 'Salary Payment') {
      // For actual salary payments, update the balance (negative because it's a payment)
      employee.salaryBalance -= amount;
    } else {
      // For other types, update the net salary
      const currentNet = employee.salary.net;
      let newNet = currentNet;

      switch (type) {
        case 'Extra Commission':
        case 'Recovery Award':
          newNet = currentNet + amount;
          break;
        case 'Advance Salary':
          if (!paymentMethod) {
            throw new Error('Payment method is required for advance salary');
          }
          newNet = currentNet - amount;
          break;
        case 'Deduction':
          newNet = currentNet - amount;
          break;
      }

      // Handle case where salary is a number instead of object
      const currentGross = typeof employee.salary === 'object' ? employee.salary.gross : employee.salary;
      employee.salary = {
        gross: currentGross,
        net: newNet,
        lastModified: date
      };
    }

    await employee.save({ session });

    await session.commitTransaction();
    
    return payment.toObject();
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}

/**
 * Get salary payment history for an employee
 */
export async function getEmployeeSalaryHistory(employeeId, filters = {}) {
  const query = { employeeId };
  
  if (filters.from || filters.to) {
    query.date = {};
    if (filters.from) query.date.$gte = new Date(filters.from);
    if (filters.to) query.date.$lte = new Date(filters.to);
  }

  if (filters.type) {
    query.type = filters.type;
  }

  const payments = await SalaryPayment.find(query)
    .sort({ date: -1 })
    .lean();

  return payments;
}

/**
 * Get salary summary for an employee
 */
export async function getEmployeeSalarySummary(employeeId) {
  const employee = await Employee.findById(employeeId).lean();
  if (!employee) {
    throw new Error('Employee not found');
  }

  // Get total payments by type
  const summary = await SalaryPayment.aggregate([
    { $match: { employeeId: new mongoose.Types.ObjectId(employeeId) } },
    { $group: {
      _id: '$type',
      total: { $sum: '$amount' }
    }}
  ]);

  return {
    employee: {
      name: employee.name,
      salary: employee.salary,
      balance: employee.salaryBalance
    },
    payments: summary.reduce((acc, curr) => {
      acc[curr._id] = curr.total;
      return acc;
    }, {})
  };
}

/**
 * Update employee's base salary
 */
export async function updateEmployeeSalary(employeeId, { gross, net }, auditContext) {
  const employee = await Employee.findById(employeeId);

  if (!employee) {
    throw new Error('Employee not found');
  }

  // Only allow salary updates for active employees
  if (employee.status !== 'active') {
    throw new Error('Cannot update salary for inactive employee');
  }

  employee.salary = {
    gross,
    net,
    lastModified: new Date()
  };

  // Set audit context
  employee.$locals = {
    audit: {
      actorId: auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip: auditContext.ip,
      ua: auditContext.ua
    }
  };

  await employee.save();
  return employee.toObject();
} 

================================================================================
// FILE: server\src\services\userService.js
================================================================================

// src/services/userService.js
import User from '../models/user.model.js';

/**
 * List users, filter by role/username, paginate.
 * @param {Object} options - Query options
 * @param {number} options.page - Page number (default: 1)
 * @param {number} options.limit - Items per page (default: 10)
 * @param {string} [options.role] - Optional role filter
 * @param {string} [options.username] - Optional username search
 * @param {Object} auditContext - Audit context
 * @returns {Promise<{users: Array, total: number, page: number, limit: number}>}
 */
export async function getAllUsers({ page = 1, limit = 10, role, username } = {}, auditContext) {
  const query = {};
  
  // Only add role to query if it's provided and not empty
  if (role && role.trim()) {
    query.role = role.trim();
  }
  
  // Add username search if provided
  if (username && username.trim()) {
    query.username = new RegExp(username.trim(), 'i');
  }

  const skip = (page - 1) * limit;
  const [ users, total ] = await Promise.all([
    User.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .select('-password -refreshToken')
        .setOptions({
          actor: auditContext.actor,
          ip: auditContext.ip,
          ua: auditContext.ua
        })
        .lean(),
    User.countDocuments(query)
  ]);

  return { users, total, page, limit };
}

/**
 * Fetch one user by ID.
 */
export async function getUserById(id, auditContext) {
  const user = await User.findById(id)
                         .select('-password -refreshToken')
                         .setOptions({
                           actor: auditContext.actor,
                           ip: auditContext.ip,
                           ua: auditContext.ua
                         })
                         .lean();
  if (!user) throw new Error('User not found');
  return user;
}

/**
 * Update only profile fields: username, email, role.
 * (No password changes here.)
 */
export async function updateUser(id, { username, email, role }, auditContext) {
  const updates = {};
  if (username) updates.username = username;
  if (email)    updates.email    = email;
  if (role)     updates.role     = role;

  const user = await User.findByIdAndUpdate(
    id,
    updates,
    {
      new: true,
      actor: auditContext.actor,
      ip: auditContext.ip,
      ua: auditContext.ua
    }
  )
  .select('-password -refreshToken')
  .lean();

  if (!user) throw new Error('User not found');
  return user;
}

/**
 * Remove a user.
 */
export async function deleteUser(id, auditContext) {
  const user = await User.findByIdAndDelete(id)
    .setOptions({
      actor: auditContext.actor,
      ip: auditContext.ip,
      ua: auditContext.ua
    })
    .lean();
  if (!user) throw new Error('User not found');
  return user;
}


================================================================================
// FILE: server\src\services\vendorService.js
================================================================================

// src/services/vendorService.js
import mongoose from 'mongoose';
import Vendor from '../models/vendor.model.js';
import ApiError from '../utils/ApiError.js';

/**
 * Create a new vendor.
 * @param {Object} vendorData  { name, contact:{ phone, email, address }, openingBalance? }
 * @param {Object} auditContext  { actor, ip, ua }
 */
export async function createVendor(vendorData, auditContext) {
  const session = await mongoose.startSession();
  session.startTransaction();
  try {

    const existingVendor = await Vendor.findOne({ 'contact.email': vendorData.contact.email });
    if (existingVendor) {
      throw new Error('Vendor already exists');
    }

    // 1) Build the Vendor document
    const vendor = new Vendor({
      ...vendorData,
      openingBalance: vendorData.openingBalance ?? 0
    });

    // 2) Attach audit metadata via $locals.audit
    vendor.$locals = vendor.$locals || {};
    vendor.$locals.audit = {
      actorId:    auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip:         auditContext.ip,
      ua:         auditContext.ua
    };

    // 3) Save under the session so auditPlugin sees $locals.audit
    const saved = await vendor.save({ session });

    // 4) Commit & return
    await session.commitTransaction();
    return saved.toObject();
  } catch (err) {
    await session.abortTransaction();
    throw err;
  } finally {
    session.endSession();
  }
}

/**
 * List vendors with optional status filter, search by name or email,
 * and pagination.
 * @param {Object} opts
 * @param {Object} opts.filters      { status }
 * @param {string} opts.search       matches name or contact.email
 * @param {number} opts.page=1
 * @param {number} opts.limit=10
 */
export async function getAllVendors({
  filters = {},
  search  = '',
  page    = 1,
  limit   = 10
} = {}) {
  const query = { status: 'active' };  // Only show active vendors by default
  if (filters.status) query.status = filters.status;

  if (search) {
    const re = new RegExp(search, 'i');
    query.$or = [
      { name:           re },
      { 'contact.email': re }
    ];
  }

  const skip = (page - 1) * limit;
  const [ total, vendors ] = await Promise.all([
    Vendor.countDocuments(query),
    Vendor.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean()
  ]);

  return {
    vendors,
    pagination: {
      total,
      page,
      limit,
      totalPages:  Math.ceil(total / limit),
      hasNextPage: page < Math.ceil(total / limit),
      hasPrevPage: page > 1
    }
  };
}

/**
 * Fetch one vendor by its ID.
 * @param {string} id
 */
export async function getVendorById(id) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid vendor ID');
  }
  const v = await Vendor.findById(id)
    .lean();
  if (!v) {
    throw new Error('Vendor not found');
  }
  return v;
}

/**
 * Update a vendor's mutable fields.
 * @param {string} id
 * @param {Object} data  { name?, contact?, status? }
 * @param {Object} auditContext  { actor, ip, ua }
 */
export async function updateVendor(id, data, auditContext) {
  try {
    console.log('Update vendor called with:', { id, data });
    
    if (!mongoose.Types.ObjectId.isValid(id)) {
      throw new ApiError(400, 'Invalid vendor ID');
    }
    
    // 1) Get the existing vendor first
    const existingVendor = await Vendor.findById(id).lean();
    if (!existingVendor) {
      throw new ApiError(404, 'Vendor not found');
    }
    
    // 2) Prepare update data with proper structure
    const updateData = {};
    
    // Handle name updates
    if (data.name !== undefined) {
      const newName = data.name.trim();
      updateData.name = newName;
      
      // Check for name uniqueness (case-insensitive match)
      const nameExists = await Vendor.findOne({
        name: { $regex: `^${escapeRegExp(newName)}$`, $options: 'i' }, // Exact match, ignore case
        _id: { $ne: id },
        status: { $ne: 'deleted' }
      });
      
      console.log('Name uniqueness check:', { name: newName, result: nameExists });
      
      if (nameExists) {
        throw new ApiError(409, 'A vendor with this name already exists');
      }
    }
    
    // Handle contact updates - this preserves all existing contact fields
    if (data.contact || data['contact.email']) {
      updateData.contact = { ...existingVendor.contact }; // Start with existing contact data
      
      // Handle direct contact object updates
      if (data.contact) {
        Object.assign(updateData.contact, data.contact);
      }
      
      // Handle dot notation for email (special case)
      if (data['contact.email'] !== undefined) {
        // Store the email exactly as entered (preserve case)
        updateData.contact.email = data['contact.email'];
      }
      
      // Check email uniqueness if it's being updated (case-insensitive comparison)
      if (updateData.contact.email && 
          updateData.contact.email.toLowerCase() !== existingVendor.contact?.email?.toLowerCase()) {
        const emailExists = await Vendor.findOne({
          'contact.email': { $regex: `^${escapeRegExp(updateData.contact.email)}$`, $options: 'i' },
          _id: { $ne: id },
          status: { $ne: 'deleted' }
        });
        
        console.log('Email uniqueness check:', { 
          email: updateData.contact.email, 
          result: emailExists 
        });
        
        if (emailExists) {
          throw new ApiError(409, 'A vendor with this email already exists');
        }
      }
    }
    
    // Handle status updates
    if (data.status !== undefined) {
      updateData.status = data.status;
    }
    
    console.log('Final update data:', updateData);
    
    // Helper function for escaping special characters in regex
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    
    // 3) Update vendor - use $set to ensure values are stored exactly as provided
    const updatedVendor = await Vendor.findByIdAndUpdate(
      id,
      { $set: updateData },
      {
        new: true,
        actor: auditContext.actor,
        ip: auditContext.ip,
        ua: auditContext.ua,
      }
    ).lean();
    
    if (!updatedVendor) {
      throw new ApiError(404, 'Vendor not found after update attempt');
    }
    
    return updatedVendor;
  } catch (error) {
    console.error('Error in updateVendor:', error);
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw new ApiError(500, error.message || 'Error updating vendor');
    }
  }
}

/**
 * Soft delete a vendor by marking them as deleted.
 * @param {string} id
 * @param {Object} auditContext  { actor, ip, ua }
 */
export async function deleteVendor(id, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid vendor ID');
  }

  const vendor = await Vendor.findById(id).lean();
  if (!vendor) {
    throw new Error('Vendor not found');
  }

  const v = await Vendor.findByIdAndUpdate(
    id,
    { status: 'deleted' },
    {
      new: true,
      actor: auditContext.actor,
      ip: auditContext.ip,
      ua: auditContext.ua
    }
  ).lean();
  if (!v) {
    throw new Error('Vendor not found');
  }
  return v;
}



================================================================================
// FILE: server\src\services\vendorTxnService.js
================================================================================

// src/services/vendorTxnService.js
import mongoose from 'mongoose';
import VendorTransaction from '../models/vendorTransaction.model.js';
import Vendor from '../models/vendor.model.js';
import * as expenseService from './expenseService.js';
import * as cashService from './cashService.js';
import * as bankService from './bankService.js';

/**
 * Record a purchase or payment for a vendor.
 * For Purchase: Only records the transaction and updates balance
 * For Payment: Records transaction, updates balance, and updates cash/bank registers
 *
 * @param {Object} params
 * @param {string} params.vendorId
 * @param {string} params.type          "Purchase" or "Payment"
 * @param {string} params.description
 * @param {number} params.amount
 * @param {string} params.method        Required for Payment type only
 * @param {Object} auditContext         { actor, ip, ua }
 */
export async function addVendorTransaction(
  { vendorId, type, description, amount, method },
  auditContext
) {
  // Validate vendorId and type
  if (!mongoose.Types.ObjectId.isValid(vendorId)) {
    throw new Error('Invalid vendor ID');
  }
  if (!['Purchase','Payment'].includes(type)) {
    throw new Error('Type must be "Purchase" or "Payment"');
  }

  // Validate method is provided for Payment type
  if (type === 'Payment') {
    if (!method) {
      throw new Error('Payment method is required for Payment type');
    }
    if (!['Cash', 'Bank','Shabka'].includes(method)) {
      throw new Error('Payment method must be either Cash or Bank or Shabka');
    }
  }

  // Use existing session if provided, otherwise create one
  let session = auditContext.session;
  let ownSession = false;
  if (!session) {
    session = await mongoose.startSession();
    session.startTransaction();
    ownSession = true;
  }

  try {
    // Load vendor for balance and name
    const vendor = await Vendor.findById(vendorId)
      .session(session)
      .setOptions({ actor: auditContext.actor, ip: auditContext.ip, ua: auditContext.ua });
    if (!vendor) throw new Error('Vendor not found');

    // Determine new payable balance
    const lastTxn = await VendorTransaction.findOne({ vendorId, status: 'active' })
      .sort({ date: -1 })
      .session(session)
      .setOptions({ actor: auditContext.actor, ip: auditContext.ip, ua: auditContext.ua });
    const lastBalance = lastTxn ? lastTxn.balance : vendor.openingBalance;
    const newBalance = type === 'Purchase'
      ? lastBalance + amount
      : lastBalance - amount;

    // Create vendor transaction
    const txn = new VendorTransaction({ 
      vendorId, 
      type,
      method: type === 'Payment' ? method : undefined, // Only set method for Payment type
      description, 
      amount, 
      balance: newBalance 
    });

    // Attach audit metadata via $locals.audit
    txn.$locals = txn.$locals || {};
    txn.$locals.audit = {
      actorId: auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip: auditContext.ip,
      ua: auditContext.ua
    };

    // Save under the session so auditPlugin sees $locals.audit
    const saved = await txn.save({ session });

    // For Payment type only: Record ledger entry and link it
    if (type === 'Payment') {
      const reference = `Vendor Payment - ${vendor.name}`;
      
      if (method === 'Cash') {
        const cashEntry = await cashService.recordCashEntry(
          { date: txn.date, type: 'Outflow', reference, amount },
          { 
            session, 
            actor: auditContext.actor, 
            ip: auditContext.ip, 
            ua: auditContext.ua 
          }
        );
        // Link ledger entry
        await VendorTransaction.findByIdAndUpdate(
          txn._id,
          { ledgerEntryId: cashEntry._id, ledgerEntryModel: 'CashRegister' },
          { 
            session, 
            actor: auditContext.actor, 
            ip: auditContext.ip, 
            ua: auditContext.ua 
          }
        );
      } else if (method === 'Bank') {
        const bankEntry = await bankService.recordBankTransaction(
          { date: txn.date, type: 'Outflow', method, reference, amount },
          { 
            session, 
            actor: auditContext.actor, 
            ip: auditContext.ip, 
            ua: auditContext.ua 
          }
        );
        // Link ledger entry
        await VendorTransaction.findByIdAndUpdate(
          txn._id,
          { ledgerEntryId: bankEntry._id, ledgerEntryModel: 'BankTransaction' },
          { 
            session, 
            actor: auditContext.actor, 
            ip: auditContext.ip, 
            ua: auditContext.ua 
          }
        );
      }
    }

    // Commit if we started the session
    if (ownSession) {
      await session.commitTransaction();
    }
    return saved.toObject();
  } catch (err) {
    if (ownSession) {
      await session.abortTransaction();
    }
    throw err;
  } finally {
    if (ownSession) {
      session.endSession();
    }
  }
}

/**
 * List vendor transactions with optional filters & pagination.
 *
 * @param {Object} opts
 * @param {string} [opts.vendorId]
 * @param {string} [opts.from]    ISO date string
 * @param {string} [opts.to]      ISO date string
 * @param {number} [opts.page=1]
 * @param {number} [opts.limit=10]
 */
export async function getAllVendorTransactions({
  vendorId,
  from,
  to,
  page  = 1,
  limit = 10
} = {}) {
  const query = { status: 'active' };
  if (vendorId) {
    if (!mongoose.Types.ObjectId.isValid(vendorId)) {
      throw new Error('Invalid vendor ID');
    }
    query.vendorId = vendorId;
  }
  if (from || to) {
    query.date = {};
    if (from) query.date.$gte = new Date(from);
    if (to)   query.date.$lte = new Date(to);
  }

  const skip = (page - 1) * limit;
  const [ total, txns ] = await Promise.all([
    VendorTransaction.countDocuments(query),
    VendorTransaction.find(query)
      .populate('vendorId', 'name contact')
      .sort({ date: -1 })
      .skip(skip)
      .limit(limit)
      .lean()
  ]);

  return {
    transactions: txns,
    pagination: {
      total,
      page,
      limit,
      totalPages:  Math.ceil(total / limit),
      hasNextPage: page < Math.ceil(total / limit),
      hasPrevPage: page > 1
    }
  };
}

/**
 * Get one vendor transaction by ID.
 * @param {string} id
 */
export async function getVendorTransactionById(id) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid transaction ID');
  }
  const txn = await VendorTransaction.findById(id)
    .populate('vendorId', 'name contact')
    .lean();
  if (!txn) throw new Error('Transaction not found');
  return txn;
}

/**
 * Update only the description of a vendor transaction.
 * @param {string} id
 * @param {Object} data  { description }
 * @param {Object} auditContext   { actor, ip, ua }
 */
export async function updateVendorTransaction(id, { description }, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid transaction ID');
  }

  // Use existing session if provided, otherwise create one
  let session = auditContext.session;
  let ownSession = false;
  if (!session) {
    session = await mongoose.startSession();
    session.startTransaction();
    ownSession = true;
  }

  try {
    const txn = await VendorTransaction.findById(id).session(session);
    if (!txn) throw new Error('Transaction not found');

    txn.description = description;

    // Attach audit metadata via $locals.audit
    txn.$locals = txn.$locals || {};
    txn.$locals.audit = {
      actorId: auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip: auditContext.ip,
      ua: auditContext.ua
    };

    // Save under the session so auditPlugin sees $locals.audit
    const saved = await txn.save({ session });

    // Commit if we started the session
    if (ownSession) {
      await session.commitTransaction();
    }
    return saved.toObject();
  } catch (err) {
    if (ownSession) {
      await session.abortTransaction();
    }
    throw err;
  } finally {
    if (ownSession) {
      session.endSession();
    }
  }
}

/**
 * Soft delete a vendor transaction and recalculate subsequent balances.
 * For Purchase: Simply marks as deleted
 * For Payment: Reverses the cash/bank entry and marks as deleted
 * 
 * @param {string} id
 * @param {Object} auditContext   { actor, ip, ua }
 */
export async function deleteVendorTransaction(id, auditContext) {
  if (!mongoose.Types.ObjectId.isValid(id)) {
    throw new Error('Invalid transaction ID');
  }

  // Use existing session if provided, otherwise create one
  let session = auditContext.session;
  let ownSession = false;
  if (!session) {
    session = await mongoose.startSession();
    session.startTransaction();
    ownSession = true;
  }

  try {
    // 1. Get the transaction to be deleted
    const toDelete = await VendorTransaction.findById(id)
      .populate('vendorId', 'name')
      .session(session);
    if (!toDelete) throw new Error('Transaction not found');
    if (toDelete.status === 'deleted') throw new Error('Transaction is already deleted');

    const { vendorId, type } = toDelete;

    // 2. Soft delete the transaction
    toDelete.status = 'deleted';
    toDelete.$locals = toDelete.$locals || {};
    toDelete.$locals.audit = {
      actorId: auditContext.actor.id,
      actorModel: auditContext.actor.model,
      ip: auditContext.ip,
      ua: auditContext.ua
    };

    await toDelete.save({ session });

    // 3. For Payment transactions, reverse the cash/bank transaction
    if (type === 'Payment' && toDelete.ledgerEntryId && toDelete.ledgerEntryModel) {
      const reference = `Reversal of payment to ${toDelete.vendorId.name} (deleted transaction)`;
      
      if (toDelete.method === 'Cash') {
        // Create an inflow to reverse the outflow
        await cashService.recordCashEntry(
          {
            date: new Date(),
            type: 'Inflow',
            reference,
            amount: toDelete.amount
          },
          {
            session,
            actor: auditContext.actor,
            ip: auditContext.ip,
            ua: auditContext.ua
          }
        );
      } else if (toDelete.method === 'Bank' || toDelete.method === 'Shabka') {
        // Create a bank inflow to reverse the outflow
        await bankService.recordBankTransaction(
          {
            date: new Date(),
            type: 'Inflow',
            method: toDelete.method,
            reference,
            amount: toDelete.amount
          },
          {
            session,
            actor: auditContext.actor,
            ip: auditContext.ip,
            ua: auditContext.ua
          }
        );
      }
    }

    // 4. Recalculate balances for all remaining active transactions for this vendor
    const txns = await VendorTransaction
      .find({ vendorId, status: 'active' })
      .sort({ date: 1 })
      .session(session);

    // Start from openingBalance
    const vendor = await Vendor.findById(vendorId).session(session);
    let running = vendor.openingBalance;

    for (const t of txns) {
      running = t.type === 'Purchase'
        ? running + t.amount
        : running - t.amount;

      t.balance = running;
      t.$locals = t.$locals || {};
      t.$locals.audit = {
        actorId: auditContext.actor.id,
        actorModel: auditContext.actor.model,
        ip: auditContext.ip,
        ua: auditContext.ua
      };

      await t.save({ session });
    }

    // Commit if we started the session
    if (ownSession) {
      await session.commitTransaction();
    }
    return toDelete.toObject();
  } catch (err) {
    if (ownSession) {
      await session.abortTransaction();
    }
    throw err;
  } finally {
    if (ownSession) {
      session.endSession();
    }
  }
}

================================================================================
// FILE: server\src\utils\ApiError.js
================================================================================

// src/utils/ApiError.js
export default class ApiError extends Error {
    constructor(statusCode, message) {
      super(message);
      this.statusCode = statusCode;
      Error.captureStackTrace(this, this.constructor);
    }
  }
  

================================================================================
// FILE: server\src\utils\ApiResponse.js
================================================================================

// src/utils/ApiResponse.js
export default class ApiResponse {
    /**
     * @param {number} statusCode
     * @param {any}    data
     * @param {string} message
     */
    constructor(statusCode, data, message) {
      this.statusCode = statusCode;
      this.data       = data;
      this.message    = message;
    }
  }
  

================================================================================
// FILE: server\src\utils\asyncHandler.js
================================================================================

export const asyncHandler = (requestHandler) => {
  return (req, res, next) => {
   Promise.resolve(requestHandler(req, res, next)).catch((err) =>
      next(err)
    );
  };
};


================================================================================
// FILE: server\src\utils\validators.js
================================================================================

// Validate date range
export function validateDateRange(startDate, endDate) {
  // Check if dates are valid
  const start = new Date(startDate);
  const end = new Date(endDate);

  if (isNaN(start.getTime())) {
    return 'Invalid start date format';
  }

  if (isNaN(end.getTime())) {
    return 'Invalid end date format';
  }

  // Check if start date is before end date
  if (start > end) {
    return 'Start date must be before end date';
  }

  // Check if date range is not too large (e.g., more than 1 year)
  const oneYear = 365 * 24 * 60 * 60 * 1000; // milliseconds in a year
  if (end - start > oneYear) {
    return 'Date range cannot exceed 1 year';
  }

  return null; // no error
} 

================================================================================
// FILE: server\src\validators\advance.validator.js
================================================================================

import Joi from 'joi';

const idParam = Joi.string().hex().length(24).required();

export const createAdvanceSchema = Joi.object({
  invoiceId: idParam,
  salesmanId: idParam,
  amount: Joi.number().precision(2).positive().required(),
  note: Joi.string().max(200),
  paymentMethod: Joi.string().valid('Cash', 'Bank', 'Shabka').default('Cash'),
  account: Joi.when('paymentMethod', {
    is: Joi.valid('Bank', 'Shabka'),
    then: Joi.string().required(),
    otherwise: Joi.optional()
  })
});

export const listAdvancesSchema = Joi.object({
  page: Joi.number().integer().min(1).default(1),
  limit: Joi.number().integer().min(1).default(10),
  salesmanId: Joi.string().hex().length(24),
  recovered: Joi.boolean(),
  from: Joi.date().iso(),
  to: Joi.date().iso(),
  search: Joi.string()
});

export const updateAdvanceSchema = Joi.object({
  note: Joi.string().max(200),
  recovered: Joi.boolean()
}); 

================================================================================
// FILE: server\src\validators\employee.validator.js
================================================================================

// src/validators/employee.validator.js
import Joi from 'joi';

const idParam = Joi.string().hex().length(24).required();

export const createEmployeeSchema = Joi.object({
  employeeData: Joi.object({
    name: Joi.string().required(),
    contact: Joi.object({
      email:   Joi.string().email().required(),
      phone:   Joi.string().required(),
      address: Joi.string().allow('')
    }).required(),
    role:     Joi.string().valid('salesman','regular').required(),
    hireDate: Joi.date().iso().required(),
    salary:   Joi.number().positive().required()
  }).required()
});

export const listEmployeesSchema = Joi.object({
  page:   Joi.number().integer().min(1).default(1),
  limit:  Joi.number().integer().min(1).default(10),
  role:   Joi.string().valid('salesman','regular'),
  status: Joi.string().valid('active','inactive'),
  search: Joi.string().allow('')
});

export const getEmployeeByIdSchema = Joi.object({ id: idParam });

export const updateEmployeeSchema = Joi.object({
  name:             Joi.string(),
  'contact.email':  Joi.string().email(),
  'contact.phone':  Joi.string(),
  'contact.address':Joi.string().allow(''),
  role:             Joi.string().valid('salesman','regular'),
  hireDate:         Joi.date().iso(),
  salary:           Joi.number().positive()
});

export const deleteEmployeeSchema = Joi.object({
  hardDelete: Joi.boolean().default(false)
});


================================================================================
// FILE: server\src\validators\invoice.validator.js
================================================================================

// src/validators/invoice.validator.js
import Joi from 'joi';

const idParam = Joi.string().hex().length(24).required();

export const createInvoiceSchema = Joi.object({
  invoiceNumber: Joi.string().required(),
  date:          Joi.date().iso(),
  customerName:  Joi.string().required(),
  salesmanId:    idParam,
  items: Joi.array().items(
    Joi.object({
      description: Joi.string().required(),
      quantity:    Joi.number().integer().positive().required(),
      unitPrice:   Joi.number().precision(2).positive().required(),
      costPrice:   Joi.number().precision(2).positive().required(),
      vatAmount:   Joi.number().precision(2).min(0).optional()
    })
  ).min(1).required(),

  payments: Joi.array().items(
    Joi.object({
      method: Joi.string().valid('Cash', 'Bank', 'Shabka').required(),
      amount: Joi.number().min(0).optional(),
      date: Joi.date().optional(), 
    })
  ).optional(),

  status: Joi.string().valid('Paid','Partially Paid','Unpaid')
});

export const listInvoicesSchema = Joi.object({
  page:       Joi.number().integer().min(1).default(1),
  limit:      Joi.number().integer().min(1).default(10),
  status:     Joi.string().valid('Paid','Partially Paid','Unpaid'),
  salesmanId: Joi.string().hex().length(24),
  from:       Joi.date().iso(),
  to:         Joi.date().iso(),
  sort:       Joi.string(),
  customerName: Joi.string()
});

export const getInvoiceByIdSchema   = Joi.object({ id: idParam });
export const updateInvoiceSchema    = Joi.object({
  invoiceNumber: Joi.string(),
  date:          Joi.date().iso(),
  customerName:  Joi.string(),
  salesmanId:    Joi.string().hex().length(24),
  items: Joi.array().items(
    Joi.object({
      description: Joi.string().required(),
      quantity:    Joi.number().integer().positive().required(),
      unitPrice:   Joi.number().precision(2).positive().required(),
      costPrice:   Joi.number().precision(2).positive().required(),
      vatAmount:   Joi.number().precision(2).min(0).required()
    })
  ),
  status: Joi.string().valid('Paid','Partially Paid','Unpaid')
});

export const deleteInvoiceSchema    = Joi.object({ id: idParam });

// Schema for adding a payment to an invoice
export const addPaymentSchema = Joi.object({
  amount: Joi.number().precision(2).positive().required(),
  method: Joi.string().valid('Cash','Bank','Shabka').required(),
  date: Joi.date().iso()
});

// Schema for reversing a payment
export const reversePaymentSchema = Joi.object({
  reason: Joi.string().min(3).max(200).required()
});

// Schema for payment ID parameter
export const paymentIdParamSchema = Joi.object({
  id: idParam,
  paymentId: Joi.string().required()
});

// Schema for commission payment
export const commissionPaymentSchema = Joi.object({
  amount: Joi.number().precision(2).positive().required(),
  method: Joi.string().valid('Cash','Bank','Shabka').required(),
  date: Joi.date().iso(),
  note: Joi.string().max(200)
});


================================================================================
// FILE: server\src\validators\salary.validator.js
================================================================================

import Joi from 'joi';

const idParam = Joi.string().hex().length(24).required();

export const addSalaryPaymentSchema = Joi.object({
  employeeId: idParam,
  type: Joi.string().valid(
    'Basic Salary',
    'Salary Payment',
    'Advance Salary',
    'Extra Commission',
    'Recovery Award',
    'Deduction'
  ).required(),
  amount: Joi.number().not(0).required(),
  description: Joi.string().required(),
  paymentMethod: Joi.string().valid('Cash', 'Bank', 'Shabka').when('type', {
    is: Joi.string().valid('Salary Payment', 'Advance Salary'),
    then: Joi.required(),
    otherwise: Joi.forbidden()
  }),
  date: Joi.date().iso()
});

export const getSalaryHistorySchema = Joi.object({
  from: Joi.date().iso(),
  to: Joi.date().iso(),
  type: Joi.string().valid(
    'Basic Salary',
    'Salary Payment',
    'Advance Salary',
    'Extra Commission',
    'Recovery Award',
    'Deduction'
  )
});

export const updateSalarySchema = Joi.object({
  gross: Joi.number().positive().required(),
  net: Joi.number().positive().required()
}); 

================================================================================
// FILE: server\src\validators\user.validator.js
================================================================================

// src/validators/user.validator.js
import Joi from 'joi';

const idParam = Joi.string().hex().length(24).required();

export const getAllUsersSchema = Joi.object({
  page:     Joi.number().integer().min(1).default(1),
  limit:    Joi.number().integer().min(1).default(10),
  role:     Joi.string().valid('superAdmin','admin','employee'),
  username: Joi.string()
});

export const getUserByIdSchema = Joi.object({
  id: idParam
});

export const updateUserSchema = Joi.object({
  username: Joi.string(),
  email:    Joi.string().email(),
  role:     Joi.string().valid('superAdmin','admin','employee')
});

export const deleteUserSchema = Joi.object({
  id: idParam
});


================================================================================
// FILE: server\src\validators\vendor.validator.js
================================================================================

import Joi from 'joi';

const idParam = Joi.string().hex().length(24).required();

// Schema for creating vendor
export const createVendorSchema = Joi.object({
  name: Joi.string().min(3).max(100).required(),
  contact: Joi.object({
    phone: Joi.string().pattern(/^[0-9+\-\s()]{6,20}$/),
    email: Joi.string().email(),
    address: Joi.string().max(200)
  }),
  openingBalance: Joi.number().min(0).default(0)
});

// Schema for updating vendor
export const updateVendorSchema = Joi.object({
  name: Joi.string().min(3).max(100),
  contact: Joi.object({
    phone: Joi.string().pattern(/^[0-9+\-\s()]{6,20}$/),
    email: Joi.string().email(),
    address: Joi.string().max(200)
  }),
  openingBalance: Joi.number().min(0)
});

// Schema for creating vendor transaction
export const createVendorTransactionSchema = Joi.object({
  vendorId: idParam,
  type: Joi.string().valid('Purchase', 'Payment').required(),
  description: Joi.string().min(3).max(500).required(),
  amount: Joi.number().precision(2).positive().required(),
  method: Joi.string().valid('Cash', 'Bank', 'Shabka')
});

// Schema for updating vendor transaction - only allows description to be updated
export const updateVendorTransactionSchema = Joi.object({
  description: Joi.string().min(3).max(500).required()
});

// Schema for vendor transaction listing
export const listVendorTransactionsSchema = Joi.object({
  page: Joi.number().integer().min(1).default(1),
  limit: Joi.number().integer().min(1).max(100).default(10),
  vendorId: Joi.string().hex().length(24),
  from: Joi.date().iso(),
  to: Joi.date().iso()
}); 

